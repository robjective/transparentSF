<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Monthly Newsletters - WHAT'S HAPPENING IN SF?</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon.png">
    <link rel="manifest" href="/static/site.webmanifest">
    <!-- Dark Mode CSS -->
    <link rel="stylesheet" href="/static/css/darkmode.css">
    <style>
        body { 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
            margin: 0;
            padding: 20px;
            font-size: 14px;
            color: #333;
            background-color: #ffffff;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
        }
        
        h1 {
            margin-top: 0;
            margin-bottom: 10px;
            color: #222;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
            font-size: 24px;
        }
        
        .section {
            margin-bottom: 20px;
            background: #f9f9f9;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
        }
        
        .section h2 {
            margin-top: 0;
            color: #333;
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        .form-group {
            margin-bottom: 10px;
            display: inline-block;
            margin-right: 15px;
            vertical-align: top;
        }
        
        .form-row {
            display: flex;
            align-items: flex-end;
            gap: 15px;
            margin-bottom: 10px;
        }
        
        .form-row .form-group {
            margin-bottom: 0;
            margin-right: 0;
        }
        
        .form-row button {
            margin-top: 0;
            height: 32px;
        }
        
        label {
            display: block;
            margin-bottom: 3px;
            font-weight: 500;
            font-size: 13px;
        }
        
        select, input {
            width: 100%;
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            background-color: #fff;
        }
        
        button {
            background-color: #ad35fa;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
            margin-top: 20px;
        }
        
        button:hover {
            background-color: #0056b3;
        }
        
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        
        .action-btn.available {
            background-color: #ad35fa66; /* Muted purple for available actions */
            color: white;
        }
        
        .action-btn.available:hover {
            background-color: #ad35fa99;
        }
        
        .action-btn.completed {
            background-color: #6c757d; /* Grey for completed actions */
            color: white;
            cursor: pointer; /* Allow clicking even when completed */
        }
        
        .action-btn.completed:hover {
            background-color: #5a6268; /* Slightly lighter grey on hover */
        }
        
        .reports-list {
            margin-top: 20px;
        }
        
        .report-item {
            background: white;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 15px;
            display: flex;
            flex-direction: column;
        }
        
        .report-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .report-info {
            flex: 1;
        }
        
        .report-title {
            font-weight: 500;
            margin-bottom: 5px;
            font-size: 16px;
        }
        
        .report-meta {
            font-size: 12px;
            color: #666;
        }
        
        .report-actions {
            display: flex;
            gap: 10px;
        }
        
        .report-details {
            margin-top: 10px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }
        
        .report-items {
            margin-top: 10px;
        }
        
        .report-item-row {
            background: #f9f9f9;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 8px;
        }
        
        .report-item-title {
            font-weight: 500;
            margin-bottom: 5px;
        }
        
        .report-item-explanation {
            font-size: 13px;
            color: #555;
            margin-bottom: 5px;
        }
        
        .report-item-text {
            font-size: 13px;
            color: #333;
            background: #fff;
            padding: 8px;
            border-radius: 3px;
            border: 1px solid #eee;
        }
        
        .report-links {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .report-link {
            display: inline-flex;
            align-items: center;
            text-decoration: none;
            font-size: 13px;
            padding: 8px 12px;
            border-radius: 4px;
            font-weight: normal;
            background-color: #f5f5f5;
            color: #333;
        }
        
        .report-link:hover {
            background-color: #e0e0e0;
            text-decoration: none;
        }
        
        .report-link svg {
            margin-right: 5px;
            width: 14px;
            height: 14px;
        }
        
        .view-btn {
            background-color: #28a745;
        }
        
        .view-btn:hover {
            background-color: #1e7e34;
        }
        
        .delete-btn {
            background-color: #dc3545;
        }
        
        .delete-btn:hover {
            background-color: #c82333;
        }
        
        .action-btn {
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            margin-right: 5px;
            font-weight: normal;
            border: none;
            background-color: #cbcbcb;
            color: #333;
        }
        
        .action-btn:hover {
            background-color: #e0e0e0;
        }
        
        .action-btn.delete-btn {
            color:crimson/* Removed color and background-color */
        }
        
        .action-btn.delete-btn:hover {
            background-color: #e0e0e0; /* Standard hover */
        }
        
        .action-btn.primary-btn {
            /* Removed background-color and color */
        }
        
        .action-btn.primary-btn:hover {
            background-color: #e0e0e0; /* Standard hover */
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
            vertical-align: middle;
            position: relative;
            top: -1px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .status-message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 4px;
        }
        
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .no-reports {
            text-align: center;
            padding: 30px;
            color: #666;
            font-style: italic;
        }

        .report-selector {
            margin-bottom: 20px;
        }

        .report-details-container {
            display: none;
            margin-top: 20px;
            background: white;
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 20px;
            max-height: 800px;
            overflow-y: auto;
        }

        .report-details-container h2 {
            color: #ad35fa;
            margin-top: 20px;
            margin-bottom: 15px;
            font-size: 1.5em;
        }

        .report-details-container h3 {
            color: #333;
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .report-details-container p {
            margin-bottom: 15px;
            line-height: 1.6;
        }

        .report-details-container ul, .report-details-container ol {
            margin-bottom: 15px;
            padding-left: 20px;
        }

        .report-details-container li {
            margin-bottom: 8px;
        }

        .report-details-container .highlight {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            border-left: 4px solid #ad35fa;
        }

        .report-details-container .chart-container {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 5px;
            border: 1px solid #eee;
        }

        .report-details-container .chart-container img {
            max-width: 100%;
            height: auto;
        }

        .report-details-container .district-official {
            background-color: #e9f7fe;
            padding: 15px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-style: italic;
        }

        .report-details-container .metric-change {
            font-weight: 600;
        }

        .report-details-container .positive-change {
            color: #FFFFFF;
        }

        .report-details-container .negative-change {
            color: #FFFFFF;
        }

        .report-details-container .neutral-change {
            color: #6c757d;
        }

        .metric-details {
            margin-top: 15px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 4px;
        }

        .report-meta {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
            color: #666;
        }
        
        .report-metadata {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .metadata-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
        }
        
        .metadata-item {
            padding: 5px 10px;
            background-color: #fff;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            font-size: 13px;
        }
        
        .metadata-item strong {
            margin-right: 5px;
            color: #555;
        }
        
        .metric-item {
            margin-bottom: 1.5rem;
            padding: 1rem;
            background-color: #f9f9f9;
            border-radius: 4px;
            border-left: 4px solid #4CAF50;
        }

        .metric-item h4 {
            margin-top: 0;
            color: #333;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .metric-item h4::after {
            content: 'â–¼';
            font-size: 12px;
            color: #666;
            transition: transform 0.2s ease;
        }

        .metric-item.collapsed h4::after {
            transform: rotate(-90deg);
        }

        .metric-details {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
            display: none; /* Hidden by default */
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        .metric-item.expanded .metric-details {
            display: block;
        }

        .metrics-container {
            margin-top: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
        }

        .positive-change {
            color: #28a745;
            font-weight: bold;
        }

        .negative-change {
            color: #dc3545;
            font-weight: bold;
        }

        .neutral-change {
            color: #6c757d;
            font-weight: bold;
        }

        #report-metrics {
            margin-top: 20px;
        }

        .report-metadata p {
            margin: 5px 0;
            display: none; /* Hide the old paragraph style */
        }

        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.4);
        }

        .modal-content {
            background-color: #fefefe;
            margin: 15% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 800px;
            border-radius: 8px;
            position: relative;
        }

        .close {
            position: absolute;
            right: 20px;
            top: 10px;
            color: #aaa;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: #000;
        }

        .citation-link {
            color: #ad35fa;
            text-decoration: none;
            font-weight: 500;
        }

        .citation-link:hover {
            text-decoration: underline;
        }

        .citation-item {
            margin-bottom: 8px;
            padding: 5px;
            border-left: 3px solid #ad35fa;
            padding-left: 10px;
            background-color: #f8f9fa;
        }

        .citation-number {
            font-weight: bold;
            color: #ad35fa;
            margin-right: 5px;
        }

        .citation-url {
            color: #ad35fa;
            text-decoration: none;
        }

        .citation-url:hover {
            text-decoration: underline;
        }

        .perplexity-context {
            margin-top: 5px;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            line-height: 1.5;
        }

        .citations-container {
            margin-top: 10px;
            margin-bottom: 15px;
            border-top: 1px solid #eee;
            padding-top: 10px;
        }

        .change-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 16px;
            font-size: 12px;
            font-weight: 700;
            white-space: nowrap;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .positive-change {
            background-color: #28a745;
            color: #ffffff;
        }

        .negative-change {
            background-color: #dc3545;
            color: #ffffff;
        }

        .neutral-change {
            background-color: #e2e3e5;
            color: #383d41;
        }

        .metrics-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .metrics-header h3 {
            margin: 0;
        }

        .metric-header {
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            width: 100%;
            margin: 0;
            padding: 0;
            gap: 10px;
        }

        .metric-header-content {
            display: flex;
            align-items: center;
            flex: 1;
            min-width: 0;
        }

        .metric-title {
            font-weight: 600;
            color: #333;
            margin-right: 10px;
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Conversation link hover effect */
        .metric-header-content a:hover {
            background-color: #f8f0ff;
            border-color: #8b5cf6;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(173, 53, 250, 0.2);
            transition: all 0.2s ease;
        }

        /* Style to indicate the header is clickable */
        .metric-header:hover {
            color: #ad35fa;
        }

        .metrics-actions {
            display: flex;
            gap: 10px;
        }

        .expand-all-btn, .collapse-all-btn {
            padding: 4px 10px;
            font-size: 12px;
        }

        /* Make sure items are initially collapsed after loading */
        .metric-item {
            margin-bottom: 10px;
        }

        .loading-indicator {
            text-align: center;
            padding: 30px;
            color: #666;
        }

        .error-message {
            color: #dc3545;
            padding: 15px;
            font-weight: 500;
            text-align: center;
        }

        .metric-stats {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            margin-left: auto;
            background-color: #f8f9fa;
            padding: 8px 12px;
            border-radius: 6px;
            border: 1px solid #e9ecef;
        }

        .stat-item {
            font-size: 12px;
            color: #495057;
            background-color: #ffffff;
            padding: 4px 8px;
            border-radius: 4px;
            white-space: nowrap;
            border: 1px solid #dee2e6;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .stat-label {
            font-weight: 600;
            color: #212529;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        @media (max-width: 768px) {
            .metric-stats {
                margin-top: 8px;
                margin-left: 0;
                width: 100%;
                gap: 8px;
            }
            
            .metric-header {
                flex-direction: column;
                align-items: flex-start;
            }

            .metric-header-content {
                width: 100%;
                margin-bottom: 8px;
            }

            .metric-title {
                font-size: 14px;
            }

            .stat-item {
                font-size: 11px;
                padding: 3px 6px;
            }

            .stat-label {
                font-size: 10px;
            }
        }

        /* Styles for the prompt editor */
        .prompt-templates {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 15px;
        }

        .prompt-button {
            padding: 8px 15px;
            background-color: #818181;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .prompt-button:hover {
            background-color: #e0e0e0;
        }

        #prompt-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }

        .prompt-modal-content {
            width: 90%;
            max-width: 1000px;
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            margin: 5vh auto;
        }

        .prompt-editor-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            padding: 10px 0;
            flex: 1;
        }

        .editor-row {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .prompt-textarea {
            width: 100%;
            padding: 10px;
            font-family: monospace;
            font-size: 14px;
            line-height: 1.5;
            border: 1px solid #ddd;
            border-radius: 4px;
            resize: vertical;
            min-height: 100px;
        }

        #promptContent {
            height: 500px;
        }

        .editor-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 15px;
        }

        .template-placeholder {
            color: #ad35fa;
            background-color: #e7f1ff;
            padding: 2px 4px;
            border-radius: 2px;
            font-style: italic;
        }

        #savePromptBtn {
            position: relative;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Monthly Newsletters</h1>
        
        <div class="section">
            <h2>Prompt Templates</h2>
            <div class="prompt-templates">
                <div class="loading-indicator" id="prompts-loading">Loading prompts...</div>
                <div id="prompt-buttons" style="display: none; gap: 10px;"></div>
            </div>
        </div>
        
        <div class="section">
            <h2>Generate New Newsletter</h2>
            <form id="generate-report-form">
                <div style="display: flex; align-items: flex-end; gap: 15px; margin-bottom: 10px;">
                    <div style="width: 200px;">
                        <label for="district-select">District</label>
                        <select id="district-select" style="width: 100%;">
                            <option value="0">Citywide</option>
                            <option value="1">District 1</option>
                            <option value="2">District 2</option>
                            <option value="3">District 3</option>
                            <option value="4">District 4</option>
                            <option value="5">District 5</option>
                            <option value="6">District 6</option>
                            <option value="7">District 7</option>
                            <option value="8">District 8</option>
                            <option value="9">District 9</option>
                            <option value="10">District 10</option>
                            <option value="11">District 11</option>
                        </select>
                    </div>
                    
                    <div style="width: 80px;">
                        <label for="max-items">Max Items</label>
                        <input type="number" id="max-items" value="1" min="1" style="width: 100%;">
                    </div>
                    
                    <div style="width: 200px;">
                        <label for="model-select">Model</label>
                        <select id="model-select" style="width: 100%;">
                            <option value="">Loading models...</option>
                        </select>
                    </div>
                    
                    <button type="submit" id="generate-btn" style="height: 32px; margin-left: 20px;">Generate Newsletter</button>
                </div>
                <div id="generate-status" class="status-message" style="display: none;"></div>
            </form>
        </div>
        
        <div class="section">
            <h2>View Newsletters</h2>
            <div class="report-selector" style="display: flex; align-items: flex-end; gap: 15px; margin-bottom: 20px; flex-wrap: wrap;">
                <div style="width: 300px;">
                    <label for="report-select">Select a Newsletter</label>
                    <select id="report-select" style="width: 100%;">
                        <option value="">-- Select a newsletter --</option>
                    </select>
                </div>
                
                <div class="report-actions" style="display: flex; gap: 10px; align-items: flex-end;">
                    <button id="regenerate-newsletter-btn" class="action-btn primary-btn" style="background-color: #28a745; font-weight: bold;">
                        Regenerate Newsletter
                    </button>
                    <button id="reprioritize-deltas-btn" class="action-btn primary-btn">
                        Re-prioritize deltas
                    </button>
                    <button id="reexplain-deltas-btn" class="action-btn primary-btn">
                        Re-explain deltas & generate newsletter text
                    </button>
                    <button id="rerunReportBtn" class="action-btn primary-btn">
                        Re-write newsletter
                    </button>
                    <button id="rerun-proofreading" class="action-btn">Re-run Proofreading</button>
                    <button id="convert-charts-finalize" class="action-btn primary-btn">Convert Charts and Finalize</button>
                    <button id="generate-narration" class="action-btn">Generate Narration</button>
                    <button id="delete-report-btn" class="action-btn delete-btn">Delete Report</button>
                </div>
            </div>
            
            <div id="report-details" class="report-details-container">
                <h3>Newsletter Details</h3>
                <div id="report-metrics"></div>
            </div>
        </div>
    </div>
    
    <div id="reportDetailsModal" class="modal">
        <div class="modal-content">
            <span class="close">&times;</span>
            <h2>Newsletter Details</h2>
            <div id="reportDetails"></div>
        </div>
    </div>
    
    <div id="promptEditModal" class="modal">
        <div class="modal-content prompt-modal-content">
            <span class="close">&times;</span>
            <h2 id="promptModalTitle">Edit Prompt</h2>
            <div class="prompt-editor-container">
                <div class="editor-row">
                    <label for="promptContent">Prompt Content:</label>
                    <textarea id="promptContent" rows="20" class="prompt-textarea"></textarea>
                </div>
                <div class="editor-actions">
                    <button id="savePromptBtn" class="action-btn primary-btn">Save Changes</button>
                    <button id="cancelPromptBtn" class="action-btn">Cancel</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const generateForm = document.getElementById('generate-report-form');
            const generateBtn = document.getElementById('generate-btn');
            const generateStatus = document.getElementById('generate-status');
            const modelSelect = document.getElementById('model-select');
            const reportSelect = document.getElementById('report-select');
            const reportDetails = document.getElementById('report-details');
            const reportMetrics = document.getElementById('report-metrics');
            const reportActions = document.querySelector('.report-actions');
            const modal = document.getElementById('reportDetailsModal');
            const closeBtn = document.querySelector('.close');
            const promptsLoadingEl = document.getElementById('prompts-loading');
            const promptButtonsEl = document.getElementById('prompt-buttons');
            const promptEditModal = document.getElementById('promptEditModal');
            const promptModalCloseBtn = promptEditModal.querySelector('.close');
            const promptModalTitle = document.getElementById('promptModalTitle');
            const promptContent = document.getElementById('promptContent');
            const savePromptBtn = document.getElementById('savePromptBtn');
            const cancelPromptBtn = document.getElementById('cancelPromptBtn');
            
            // Store prompts data globally
            let promptsData = {};
            let currentPromptKey = '';
            let currentPromptCategory = '';
            
            // Variable to store reports data 
            let reportsData = null;
            
            // Load available models for newsletter generation
            async function loadAvailableModels() {
                try {
                    const response = await fetch('/api/monthly-reports/available-models');
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        // Clear existing options
                        modelSelect.innerHTML = '';
                        
                        // Add default option
                        const defaultOption = document.createElement('option');
                        defaultOption.value = '';
                        defaultOption.textContent = `Default (${data.default_model})`;
                        modelSelect.appendChild(defaultOption);
                        
                        // Add available models grouped by provider
                        const modelsByProvider = {};
                        data.models.forEach(model => {
                            if (!modelsByProvider[model.provider]) {
                                modelsByProvider[model.provider] = [];
                            }
                            modelsByProvider[model.provider].push(model);
                        });
                        
                        // Add models by provider
                        Object.keys(modelsByProvider).forEach(provider => {
                            // Add provider header
                            const providerOption = document.createElement('option');
                            providerOption.value = '';
                            providerOption.textContent = `--- ${provider.toUpperCase()} ---`;
                            providerOption.disabled = true;
                            modelSelect.appendChild(providerOption);
                            
                            // Add models for this provider
                            modelsByProvider[provider].forEach(model => {
                                const option = document.createElement('option');
                                option.value = model.key;
                                option.textContent = model.name;
                                modelSelect.appendChild(option);
                            });
                        });
                    } else {
                        console.error('Failed to load models:', data.message);
                        modelSelect.innerHTML = '<option value="">Error loading models</option>';
                    }
                } catch (error) {
                    console.error('Error loading models:', error);
                    modelSelect.innerHTML = '<option value="">Error loading models</option>';
                }
            }
            
            // Define updateReportLinks function globally
            const updateReportLinks = () => {
                const selectedOption = reportSelect.options[reportSelect.selectedIndex];
                if (!selectedOption || !selectedOption.value) return;
                
                const originalFilename = selectedOption.value;
                const revisedFilename = selectedOption.dataset.revisedFilename;
                // Email filename should be based on the revised filename (which is the input to the consolidated function)
                const emailFilename = revisedFilename ? revisedFilename.replace('.html', '_email.html') : 
                                     (originalFilename ? originalFilename.replace('.html', '_email.html') : null);
                
                
                // Original link
                const originalLink = document.getElementById('view-original-report');
                if (originalLink) {
                    originalLink.href = `/backend/monthly-report/file/${originalFilename}`;
                    originalLink.style.display = originalFilename ? 'inline-block' : 'none';
                }
                
                // Revised link
                const revisedLink = document.getElementById('view-revised-report');
                if (revisedLink) {
                    revisedLink.href = revisedFilename ? `/backend/monthly-report/file/${revisedFilename}` : '#';
                    revisedLink.style.display = revisedFilename ? 'inline-block' : 'none';
                }
                
                // Final link (with embedded charts) - only show if charts exist
                const finalLink = document.getElementById('view-final-report');
                if (finalLink) {
                    // Try different possible final filename patterns
                    let possibleFinalFilenames = [];
                    
                    if (revisedFilename) {
                        // Pattern 1: _revised -> _final
                        possibleFinalFilenames.push(revisedFilename.replace('_revised', '_final'));
                        // Pattern 2: _for_proofreading_revised -> _final
                        possibleFinalFilenames.push(revisedFilename.replace('_for_proofreading_revised', '_final'));
                        // Pattern 3: _for_proofreading_revised -> _for_proofreading_revised_final
                        possibleFinalFilenames.push(revisedFilename.replace('_for_proofreading_revised', '_for_proofreading_revised_final'));
                    }
                    
                    if (originalFilename) {
                        // Pattern 4: original -> _final
                        possibleFinalFilenames.push(originalFilename.replace('.html', '_final.html'));
                    }
                    
                    // Pattern 5: Try to construct from the base filename (remove all suffixes)
                    if (originalFilename) {
                        const baseName = originalFilename.replace(/_(revised|for_proofreading|email|with_placeholders)\.html$/, '');
                        possibleFinalFilenames.push(`${baseName}_final.html`);
                    }
                    
                    // Check each possible filename to see if it exists
                    const checkFinalFile = async () => {
                        for (const finalFilename of possibleFinalFilenames) {
                            try {
                                const response = await fetch(`/backend/monthly-report/file/${finalFilename}`, { method: 'HEAD' });
                                if (response.ok) {
                                    finalLink.href = `/backend/monthly-report/file/${finalFilename}`;
                                    finalLink.style.display = 'inline-block';
                                    return;
                                }
                            } catch (e) {
                                // Continue to next filename
                            }
                        }
                        // If no final file found, hide the link
                        finalLink.style.display = 'none';
                    };
                    
                    checkFinalFile();
                }
                
                // Email link - try multiple patterns
                const emailLink = document.getElementById('view-email-report');
                if (emailLink) {
                    // Try different possible email filename patterns
                    let possibleEmailFilenames = [];
                    
                    if (revisedFilename) {
                        // Pattern 1: _revised -> _email
                        possibleEmailFilenames.push(revisedFilename.replace('_revised', '_email'));
                        // Pattern 2: _for_proofreading_revised -> _email
                        possibleEmailFilenames.push(revisedFilename.replace('_for_proofreading_revised', '_email'));
                        // Pattern 3: _for_proofreading_revised -> _for_proofreading_revised_email
                        possibleEmailFilenames.push(revisedFilename.replace('_for_proofreading_revised', '_for_proofreading_revised_email'));
                    }
                    
                    if (originalFilename) {
                        // Pattern 4: original -> _email
                        possibleEmailFilenames.push(originalFilename.replace('.html', '_email.html'));
                    }
                    
                    // Pattern 5: Try to construct from the base filename (remove all suffixes)
                    if (originalFilename) {
                        const baseName = originalFilename.replace(/_(revised|for_proofreading|email|with_placeholders)\.html$/, '');
                        possibleEmailFilenames.push(`${baseName}_email.html`);
                    }
                    
                    // Add the emailFilename we constructed in updateReportLinks (put it first so it's checked first)
                    if (emailFilename) {
                        possibleEmailFilenames.unshift(emailFilename);
                    }
                    
                    // Check each possible filename to see if it exists
                    const checkEmailFile = async () => {
                        for (const emailFilename of possibleEmailFilenames) {
                            try {
                                const response = await fetch(`/backend/monthly-report/file/${emailFilename}`, { method: 'HEAD' });
                                if (response.ok) {
                                    emailLink.href = `/backend/monthly-report/file/${emailFilename}`;
                                    emailLink.style.display = 'inline-block';
                                    return;
                                }
                            } catch (e) {
                                // Continue to next filename
                            }
                        }
                        // If no email file found, hide the link
                        emailLink.style.display = 'none';
                    };
                    
                    checkEmailFile();
                }
                
                // Audio script link
                const audioScriptLink = document.getElementById('view-audio-script');
                if (audioScriptLink) {
                    // Construct the audio script filename from the email version
                    const audioScriptFilename = emailFilename ? emailFilename.replace('.html', '_audio_script.html') : null;
                    
                    if (audioScriptFilename) {
                        audioScriptLink.href = `/backend/monthly-report/file/${audioScriptFilename}`;
                        audioScriptLink.style.display = 'inline-block';
                    } else {
                        audioScriptLink.style.display = 'none';
                    }
                }
                
                // Published link
                const publishedLink = document.getElementById('view-published-report');
                if (publishedLink) {
                    // Find the report in the loaded data
                    const report = reportsData?.reports?.find(r => r.original_filename === originalFilename);
                    
                    if (report && report.published_url) {
                        publishedLink.href = report.published_url;
                        publishedLink.style.display = 'inline-block';
                        console.log("Found published URL:", report.published_url);
                    } else {
                        publishedLink.href = '#';
                        publishedLink.style.display = 'none';
                        console.log("No published URL found for report:", originalFilename);
                    }
                }
                
                // Audio player
                const audioPlayerContainer = document.getElementById('audio-player-container');
                const audioPlayer = document.getElementById('audio-player');
                if (audioPlayerContainer && audioPlayer) {
                    // Construct the audio filename from the email version
                    const audioFilename = emailFilename ? emailFilename.replace('.html', '.mp3') : null;
                    
                    if (audioFilename) {
                        // Check if audio file exists by trying to load it
                        const audioUrl = `/backend/narration/${audioFilename}`;
                        
                        // Test if the audio file exists
                        fetch(audioUrl, { method: 'HEAD' })
                            .then(response => {
                                if (response.ok) {
                                    // Audio file exists, show player
                                    audioPlayer.src = audioUrl;
                                    audioPlayerContainer.style.display = 'flex';
                                    console.log("Audio file found:", audioUrl);
                                } else {
                                    // Audio file doesn't exist, hide player
                                    audioPlayerContainer.style.display = 'none';
                                    console.log("Audio file not found:", audioUrl);
                                }
                            })
                            .catch(error => {
                                // Error checking file, hide player
                                audioPlayerContainer.style.display = 'none';
                                console.log("Error checking audio file:", error);
                            });
                    } else {
                        // No email filename, hide player
                        audioPlayerContainer.style.display = 'none';
                    }
                }
            };
            
            // Initialize the prompt editor components
            initPromptEditor();
            
            // Initially hide the action buttons
            if (reportActions) {
                reportActions.style.display = 'none';
            }
            
            // Load prompts
            loadPrompts();
            
            // Load available models for newsletter generation
            loadAvailableModels();
            
            // Load reports into the selector
            loadReports();
            
            // Modal event handlers for report details
            closeBtn.onclick = function() {
                modal.style.display = "none";
            }
            
            window.onclick = function(event) {
                if (event.target == modal) {
                    modal.style.display = "none";
                } else if (event.target == promptEditModal) {
                    promptEditModal.style.display = "none";
                }
            }
            
            // Modal event handlers for prompt editor
            promptModalCloseBtn.onclick = function() {
                promptEditModal.style.display = "none";
            }
            
            cancelPromptBtn.onclick = function() {
                promptEditModal.style.display = "none";
            }
            
            savePromptBtn.onclick = function() {
                savePromptChanges();
            }
            
            // Function to load prompts from prompts.json
            async function loadPrompts() {
                try {
                    promptsLoadingEl.style.display = 'block';
                    promptButtonsEl.style.display = 'none';
                    
                    const response = await fetch('/backend/get_prompts');
                    const data = await response.json();
                    
                    if (data.status === 'success' && data.prompts) {
                        promptsData = data.prompts;
                        displayPromptButtons();
                    } else {
                        throw new Error(data.message || 'Failed to load prompts');
                    }
                } catch (error) {
                    console.error('Error loading prompts:', error);
                    promptsLoadingEl.textContent = `Error loading prompts: ${error.message}`;
                } finally {
                    promptsLoadingEl.style.display = 'none';
                    promptButtonsEl.style.display = 'flex';
                }
            }
            
            // Function to display prompt buttons
            function displayPromptButtons() {
                promptButtonsEl.innerHTML = '';
                // Only show monthly_report prompts for now
                const monthlyReportPrompts = promptsData.monthly_report || {};
                // Desired order of prompt keys
                const orderedKeys = [
                    'prioritize_deltas',
                    'context_enrichment',
                    'generate_report_text',
                    'generate_report',
                    'proofread',
                    'audio_transformation'
                ];
                orderedKeys.forEach(key => {
                    if (monthlyReportPrompts[key]) {
                        const button = document.createElement('button');
                        button.className = 'prompt-button';
                        button.textContent = key.replace(/_/g, ' ');
                        button.dataset.category = 'monthly_report';
                        button.dataset.key = key;
                        button.onclick = () => openPromptEditor('monthly_report', key);
                        promptButtonsEl.appendChild(button);
                    }
                });
            }
            
            // Function to open the prompt editor
            function openPromptEditor(category, key) {
                const prompt = promptsData[category][key];
                if (!prompt) {
                    alert(`Prompt ${category}.${key} not found`);
                    return;
                }
                
                currentPromptCategory = category;
                currentPromptKey = key;
                
                promptModalTitle.textContent = `Edit Prompt: ${key.replace(/_/g, ' ')}`;
                
                // Set the content - handle both string and object formats
                let promptText = '';
                if (typeof prompt === 'string') {
                    promptText = prompt;
                } else if (typeof prompt === 'object') {
                    // If it's an object, get the prompt field
                    promptText = prompt.prompt || '';
                }
                
                promptContent.value = promptText;
                
                // Optional: Highlight template variables - disabled for now as it affects editing
                // highlightTemplateVariables(promptContent, promptText);
                
                promptEditModal.style.display = 'block';
            }
            
            // Function to highlight template variables
            function highlightTemplateVariables(textarea, text) {
                // This is a basic implementation that could be enhanced with a proper editor like CodeMirror
                const templateVarRegex = /\{([^{}]+)\}/g;
                let matches = [];
                let match;
                
                // Find all template variables
                while ((match = templateVarRegex.exec(text)) !== null) {
                    matches.push({
                        variable: match[0],
                        start: match.index,
                        end: match.index + match[0].length
                    });
                }
                
                // Sort matches by position (in reverse order to avoid index shifting)
                matches.sort((a, b) => b.start - a.start);
                
                // Replace each match with a highlighted version
                let highlightedText = text;
                for (const match of matches) {
                    highlightedText = 
                        highlightedText.substring(0, match.start) + 
                        `<span class="template-placeholder">${match.variable}</span>` + 
                        highlightedText.substring(match.end);
                }
                
                // Create a container for the highlighted text
                const container = document.createElement('div');
                container.innerHTML = highlightedText;
                container.style.position = 'absolute';
                container.style.top = '0';
                container.style.left = '0';
                container.style.right = '0';
                container.style.bottom = '0';
                container.style.pointerEvents = 'none';
                container.style.zIndex = '1';
                container.style.overflow = 'auto';
                
                // Replace the textarea with the highlighted container
                textarea.parentNode.style.position = 'relative';
                textarea.parentNode.appendChild(container);
            }
            
            // Function to save prompt changes
            async function savePromptChanges() {
                if (!currentPromptCategory || !currentPromptKey) {
                    alert('No prompt selected for editing');
                    return;
                }
                
                // Get the current prompt data
                const currentPrompt = promptsData[currentPromptCategory][currentPromptKey];
                
                // Keep the system message if it exists, otherwise use an empty prompt object
                const updatedPrompt = {
                    system: currentPrompt.system || '',
                    prompt: promptContent.value
                };
                
                try {
                    savePromptBtn.disabled = true;
                    const originalText = savePromptBtn.textContent;
                    savePromptBtn.textContent = 'Saving...';
                    
                    const response = await fetch('/backend/update_prompt', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            category: currentPromptCategory,
                            key: currentPromptKey,
                            prompt: updatedPrompt
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        // Update local data
                        if (!promptsData[currentPromptCategory]) {
                            promptsData[currentPromptCategory] = {};
                        }
                        promptsData[currentPromptCategory][currentPromptKey] = updatedPrompt;
                        
                        alert('Prompt updated successfully!');
                        promptEditModal.style.display = 'none';
                    } else {
                        throw new Error(data.message || 'Failed to update prompt');
                    }
                } catch (error) {
                    console.error('Error saving prompt:', error);
                    alert(`Error saving prompt: ${error.message}`);
                } finally {
                    savePromptBtn.disabled = false;
                    savePromptBtn.textContent = 'Save Changes';
                }
            }
            
            // Load reports into the selector
            async function loadReports(preserveSelection = false) {
                try {
                    const response = await fetch('/api/monthly-reports/list');
                    const data = await response.json();
                    
                    console.log("Newsletters data received:", data);
                    reportsData = data; // Store for later use
                    
                    // Store current selection if we want to preserve it
                    const currentSelection = preserveSelection ? reportSelect.value : null;
                    
                    if (data.status === 'success' && data.reports && data.reports.length > 0) {
                        // Log each report's published_url for debugging
                        data.reports.forEach(report => {
                            console.log(`Report ${report.original_filename} published URL: ${report.published_url || 'none'}`);
                        });
                        
                        // Clear existing options except the first one
                        while (reportSelect.options.length > 1) {
                            reportSelect.remove(1);
                        }
                        
                        // Add new options
                        data.reports.forEach(report => {
                            const option = document.createElement('option');
                            // Use the original_filename as the value
                            option.value = report.original_filename;
                            // Show the original filename as the display text
                            option.textContent = report.original_filename;
                            // Store revised filename as a data attribute
                            option.dataset.revisedFilename = report.revised_filename || ''; 
                            reportSelect.appendChild(option);
                            console.log("Added option:", option.value, option.textContent);
                        });
                        
                        // Restore selection if preserving, otherwise auto-select if only one report
                        if (preserveSelection && currentSelection) {
                            reportSelect.value = currentSelection;
                            // Trigger the change event to load the report details
                            const event = new Event('change');
                            reportSelect.dispatchEvent(event);
                        } else if (data.reports.length === 1) {
                            reportSelect.value = data.reports[0].original_filename;
                            // Trigger the change event to load the report details
                            const event = new Event('change');
                            reportSelect.dispatchEvent(event);
                        }
                    } else {
                        console.log("No newsletters found or empty newsletters array");
                        // Add a message if no reports are found
                        const option = document.createElement('option');
                        option.value = "";
                        option.textContent = "No newsletters available";
                        option.disabled = true;
                        reportSelect.appendChild(option);
                    }
                } catch (error) {
                    console.error('Error loading newsletters:', error);
                    // Add an error message to the dropdown
                    const option = document.createElement('option');
                    option.value = "";
                    option.textContent = "Error loading newsletters";
                    option.disabled = true;
                    reportSelect.appendChild(option);
                }
            }
            
            // Function to check if a file exists
            async function checkFileExists(filename) {
                try {
                    const response = await fetch(`/backend/monthly-report/file/${filename}`, { method: 'HEAD' });
                    return response.ok;
                } catch (error) {
                    console.error(`Error checking file ${filename}:`, error);
                    return false;
                }
            }
            
            // Function to update button states based on file existence
            async function updateButtonStates(originalFilename) {
                if (!originalFilename) return;
                
                const baseName = originalFilename.replace(/\.html$/, '');
                
                // Check which files exist
                const filesToCheck = [
                    { suffix: '_revised.html', buttonId: 'rerun-proofreading', buttonText: 'Re-run Proofreading' },
                    { suffix: '_email.html', buttonId: 'convert-charts-finalize', buttonText: 'Convert Charts and Finalize', checkBoth: true },
                    { suffix: '_final.html', buttonId: 'convert-charts-finalize', buttonText: 'Convert Charts and Finalize', checkBoth: true }
                ];
                
                // Check each file and update button state
                const buttonStates = {};
                for (const fileInfo of filesToCheck) {
                    const filename = baseName + fileInfo.suffix;
                    const exists = await checkFileExists(filename);
                    
                    if (fileInfo.checkBoth) {
                        // For the consolidated button, track both email and final file states
                        if (!buttonStates[fileInfo.buttonId]) {
                            buttonStates[fileInfo.buttonId] = { email: false, final: false };
                        }
                        if (fileInfo.suffix === '_email.html') {
                            buttonStates[fileInfo.buttonId].email = exists;
                        } else if (fileInfo.suffix === '_final.html') {
                            buttonStates[fileInfo.buttonId].final = exists;
                        }
                    } else {
                        // For regular buttons
                        const button = document.getElementById(fileInfo.buttonId);
                        if (button) {
                            if (exists) {
                                button.classList.remove('available');
                                button.classList.add('completed');
                                button.disabled = false; // Keep buttons clickable even when completed
                            } else {
                                button.classList.remove('completed');
                                button.classList.add('available');
                                button.disabled = false;
                            }
                        }
                    }
                }
                
                // Update consolidated button state
                for (const [buttonId, state] of Object.entries(buttonStates)) {
                    const button = document.getElementById(buttonId);
                    if (button) {
                        if (state.email && state.final) {
                            button.classList.remove('available');
                            button.classList.add('completed');
                            button.disabled = false;
                        } else if (state.email || state.final) {
                            button.classList.remove('completed');
                            button.classList.add('available');
                            button.disabled = false;
                        } else {
                            // Button is available even if no outputs exist yet
                            button.classList.remove('completed');
                            button.classList.add('available');
                            button.disabled = false;
                        }
                    }
                }
                
                // Special handling for re-prioritize deltas button
                // This should only be available if the original file exists but no revised version
                const reprioritizeBtn = document.getElementById('reprioritize-deltas-btn');
                if (reprioritizeBtn) {
                    const originalExists = await checkFileExists(originalFilename);
                    const revisedExists = await checkFileExists(baseName + '_revised.html');
                    
                    if (originalExists && !revisedExists) {
                        reprioritizeBtn.classList.remove('completed');
                        reprioritizeBtn.classList.add('available');
                        reprioritizeBtn.disabled = false;
                    } else {
                        reprioritizeBtn.classList.remove('available');
                        reprioritizeBtn.classList.add('completed');
                        reprioritizeBtn.disabled = false; // Keep clickable even when completed
                    }
                }
                
                // Special handling for re-explain deltas button
                // This should be available if revised file doesn't exist
                const reexplainBtn = document.getElementById('reexplain-deltas-btn');
                if (reexplainBtn) {
                    const revisedExists = await checkFileExists(baseName + '_revised.html');
                    
                    if (!revisedExists) {
                        reexplainBtn.classList.remove('completed');
                        reexplainBtn.classList.add('available');
                        reexplainBtn.disabled = false;
                    } else {
                        reexplainBtn.classList.remove('available');
                        reexplainBtn.classList.add('completed');
                        reexplainBtn.disabled = false; // Keep clickable even when completed
                    }
                }
                
                // Special handling for re-write newsletter button
                // This should always be available since it regenerates the original newsletter
                const rerunReportBtn = document.getElementById('rerunReportBtn');
                if (rerunReportBtn) {
                    rerunReportBtn.classList.remove('completed');
                    rerunReportBtn.classList.add('available');
                    rerunReportBtn.disabled = false;
                }
                
                // Special handling for regenerate newsletter button
                // This should always be available since it runs the complete workflow
                const regenerateNewsletterBtn = document.getElementById('regenerate-newsletter-btn');
                if (regenerateNewsletterBtn) {
                    regenerateNewsletterBtn.classList.remove('completed');
                    regenerateNewsletterBtn.classList.add('available');
                    regenerateNewsletterBtn.disabled = false;
                }
            }
            
            // Handle report selection
            reportSelect.addEventListener('change', () => {
                const selectedReport = reportSelect.value;
                if (selectedReport) {
                    console.log("Selected newsletter:", selectedReport);
                    reportDetails.style.display = 'block';
                    // Show action buttons
                    if (reportActions) {
                        reportActions.style.display = 'flex';
                    }
                    loadReportDetails(selectedReport);
                    
                    // Set up the delete button
                    const deleteBtn = document.getElementById('delete-report-btn');
                    if (deleteBtn) {
                        deleteBtn.onclick = () => {
                            deleteReport(selectedReport);
                        };
                    }
                    
                    // Update report links for the selected report
                    setTimeout(updateReportLinks, 500);
                    
                    // Update button states based on file existence
                    updateButtonStates(selectedReport);
                    
                    // Set up the re-run generation button
                    const rerunReportBtn = document.getElementById('rerunReportBtn');
                    if (rerunReportBtn) {
                        rerunReportBtn.onclick = () => {
                            console.log("Re-running newsletter generation for:", selectedReport);
                            rerunReportGeneration(selectedReport);
                        };
                    }
                    
                    // Set up the re-run proofreading button
                    const rerunProofreadingBtn = document.getElementById('rerun-proofreading');
                    if (rerunProofreadingBtn) {
                        rerunProofreadingBtn.onclick = () => {
                            console.log("Re-running proofreading for:", selectedReport);
                            rerunProofreading(selectedReport);
                        };
                    }

                    // Set up the generate narration button
                    const generateNarrationBtn = document.getElementById('generate-narration');
                    if (generateNarrationBtn) {
                        generateNarrationBtn.onclick = () => {
                            console.log("Generating narration for:", selectedReport);
                            generateNarration(selectedReport);
                        };
                    }

                    // Set up the re-prioritize deltas button
                    const reprioritizeDeltasBtn = document.getElementById('reprioritize-deltas-btn');
                    if (reprioritizeDeltasBtn) {
                        reprioritizeDeltasBtn.onclick = () => {
                            console.log("Re-prioritizing deltas for:", selectedReport);
                            reprioritizeDeltas(selectedReport);
                        };
                    }

                    // Set up the regenerate newsletter button
                    const regenerateNewsletterBtn = document.getElementById('regenerate-newsletter-btn');
                    if (regenerateNewsletterBtn) {
                        regenerateNewsletterBtn.onclick = () => {
                            console.log("Regenerating complete newsletter for:", selectedReport);
                            regenerateCompleteNewsletter(selectedReport);
                        };
                    }
                    
                    // Set up the re-explain deltas button
                    const reexplainDeltasBtn = document.getElementById('reexplain-deltas-btn');
                    if (reexplainDeltasBtn) {
                        reexplainDeltasBtn.onclick = () => {
                            console.log("Re-explaining deltas for:", selectedReport);
                            reexplainDeltas(selectedReport);
                        };
                    }
                } else {
                    reportDetails.style.display = 'none';
                    // Hide action buttons
                    if (reportActions) {
                        reportActions.style.display = 'none';
                    }
                }
            });
            
            // Handle form submission
            generateForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                
                const district = document.getElementById('district-select').value;
                const maxItems = document.getElementById('max-items').value;
                const modelKey = document.getElementById('model-select').value;
                
                // Disable button and show loading state
                generateBtn.disabled = true;
                generateBtn.innerHTML = '<div style="display: flex; align-items: center; justify-content: center;"><span class="loading"></span> Generating...</div>';
                generateStatus.style.display = 'none';
                
                try {
                    // Call the API to generate the report
                    const response = await fetch('/api/monthly-reports/generate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            district,
                            max_report_items: parseInt(maxItems),
                            model_key: modelKey || null
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        generateStatus.className = 'status-message success';
                        generateStatus.textContent = 'Newsletter generated successfully!';
                        generateStatus.style.display = 'block';
                        
                        // Reload the reports list while preserving selection
                        loadReports(true);
                    } else {
                        throw new Error(data.message || 'Failed to generate newsletter');
                    }
                } catch (error) {
                    generateStatus.className = 'status-message error';
                    generateStatus.textContent = `Error: ${error.message}`;
                    generateStatus.style.display = 'block';
                } finally {
                    // Reset button state
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'Generate Newsletter';
                }
            });
            
            // Function to load report details
            async function loadReportDetails(filename) {
                try {
                    console.log("Loading newsletter details for:", filename);
                    
                    // Show loading state
                    reportMetrics.innerHTML = '<p>Loading newsletter details...</p>';
                    reportDetails.style.display = 'block';
                    
                    // Find the report ID from the reports list
                    const reportsResponse = await fetch('/api/monthly-reports/list');
                    const reportsData = await reportsResponse.json();
                    
                    if (reportsData.status !== 'success' || !reportsData.reports) {
                        throw new Error("Failed to get reports list");
                    }
                    
                    // Find the report with matching filename
                    const report = reportsData.reports.find(r => r.original_filename === filename);
                    if (!report) {
                        throw new Error("Report not found");
                    }
                    
                    // Now fetch the report details using the report ID
                    const reportResponse = await fetch(`/backend/monthly-report/${report.id}`, {
                        headers: {
                            'Accept': 'application/json'
                        }
                    });
                    
                    if (reportResponse.ok) {
                        // Check if the response is JSON
                        const contentType = reportResponse.headers.get("content-type");
                        console.log("Response content type:", contentType);
                        
                        if (contentType && contentType.includes("application/json")) {
                            // Handle JSON response (report data)
                            const reportData = await reportResponse.json();
                            console.log("Report data received:", reportData);
                            
                            if (reportData.status === 'success' && reportData.report) {
                                // Display the report data
                                displayReportDetails(reportData.report);
                                reportDetails.style.display = 'block';
                            } else {
                                reportMetrics.innerHTML = '<p>Error: Invalid report data format.</p>';
                                reportDetails.style.display = 'block';
                            }
                        } else {
                            // Handle HTML response (full report)
                            const html = await reportResponse.text();
                            console.log("HTML report received, length:", html.length);
                            
                            // Create a temporary div to parse the HTML
                            const tempDiv = document.createElement('div');
                            tempDiv.innerHTML = html;
                            
                            // Extract the metrics section - look for content between h2 and footer
                            const h2Elements = tempDiv.querySelectorAll('h2');
                            const footer = tempDiv.querySelector('.footer');
                            
                            if (h2Elements && h2Elements.length > 0) {
                                // Create a container for the metrics
                                let metricsContent = '';
                                
                                // Start from the first h2 (Key Highlights)
                                let currentElement = h2Elements[0];
                                
                                // Collect all content until we reach the footer or another h2
                                while (currentElement) {
                                    // Skip the h2 itself as we'll add it separately
                                    if (currentElement && currentElement.tagName && currentElement.tagName !== 'H2') {
                                        metricsContent += currentElement.outerHTML || '';
                                    }
                                    
                                    // Move to the next element
                                    currentElement = currentElement.nextElementSibling;
                                    
                                    // Stop if we reach the footer or another h2
                                    if (!currentElement || 
                                        (footer && currentElement === footer) || 
                                        (currentElement && currentElement.tagName === 'H2')) {
                                        break;
                                    }
                                }
                                
                                // Add the metrics content to the report-metrics div
                                reportMetrics.innerHTML = metricsContent || 'No metrics content found';
                                reportDetails.style.display = 'block';
                            } else {
                                // If no h2 elements found, try to find any content
                                const bodyContent = tempDiv.querySelector('body');
                                if (bodyContent) {
                                    // Remove the footer if it exists
                                    const footerElement = bodyContent.querySelector('.footer');
                                    if (footerElement) {
                                        footerElement.remove();
                                    }
                                    
                                    reportMetrics.innerHTML = bodyContent.innerHTML;
                                    reportDetails.style.display = 'block';
                                } else {
                                    // If no body content, just display the entire HTML
                                    reportMetrics.innerHTML = html;
                                    reportDetails.style.display = 'block';
                                }
                            }
                        }
                    } else {
                        console.error("Error loading newsletter:", reportResponse.status, reportResponse.statusText);
                        reportMetrics.innerHTML = `<p>Error loading newsletter: ${reportResponse.status} ${reportResponse.statusText}</p>`;
                        reportDetails.style.display = 'block';
                    }
                } catch (error) {
                    console.error('Error loading newsletter details:', error);
                    reportMetrics.innerHTML = `<p>Error loading newsletter details: ${error.message}</p>`;
                    reportDetails.style.display = 'block';
                }
            }
            
            // Function to re-run report generation
            async function rerunReportGeneration(filename) {
                const button = document.getElementById('rerunReportBtn');
                const originalText = button.textContent;
                button.disabled = true;
                button.innerHTML = '<div style="display: flex; align-items: center; justify-content: center;"><span class="loading"></span> Re-writing...</div>';
                
                try {
                    // Find the selected report in the reportsData to get the correct district
                    const report = reportsData?.reports?.find(r => r.original_filename === filename);
                    if (!report) {
                        throw new Error("Could not find report data");
                    }
                    
                    // Get the actual district number, defaulting to 0 if not found
                    const districtNumber = report.district !== undefined ? report.district : '0';
                    
                    // Construct the report path
                    const report_path = `output/reports/${filename}`;
                    
                    // Get the selected model from the dropdown
                    const modelSelect = document.getElementById('model-select');
                    const selectedModel = modelSelect.value;
                    
                    const response = await fetch('/backend/rerun_monthly_report_generation', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            filename,
                            district: districtNumber.toString(),
                            period_type: 'month',
                            max_report_items: 10,
                            only_generate: true,
                            report_path,
                            model_key: selectedModel || null
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        alert('Newsletter has been re-written successfully!');
                        // Reload reports while preserving the current selection
                        await loadReports(true);
                    } else {
                        alert('Error re-writing newsletter: ' + data.message);
                    }
                } catch (error) {
                    alert('Error re-writing newsletter: ' + error.message);
                } finally {
                    button.textContent = originalText;
                    button.disabled = false;
                }
            }
            
            // Function to re-run proofreading
            async function rerunProofreading(filename) {
                try {
                    // Show loading state
                    const rerunProofreadingBtn = document.getElementById('rerun-proofreading');
                    rerunProofreadingBtn.disabled = true;
                    rerunProofreadingBtn.innerHTML = '<div style="display: flex; align-items: center; justify-content: center;"><span class="loading"></span> Re-running...</div>';
                    
                    // Use the output/reports directory path
                    const report_path = `output/reports/${filename}`;
                    
                    // Get the selected model from the dropdown
                    const modelSelect = document.getElementById('model-select');
                    const selectedModel = modelSelect.value;
                    
                    // Call the API to re-run proofreading
                    const response = await fetch('/backend/rerun_monthly_report_proofreading', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            filename,
                            report_path,
                            model_key: selectedModel || null
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        alert('Proofreading re-run successfully!');
                        // Reload the reports list while preserving selection
                        loadReports(true);
                        // Update button states after completion
                        setTimeout(() => updateButtonStates(filename), 1000);
                    } else {
                        throw new Error(data.message || 'Failed to re-run proofreading');
                    }
                } catch (error) {
                    alert(`Error: ${error.message}`);
                } finally {
                    // Reset button state
                    const rerunProofreadingBtn = document.getElementById('rerun-proofreading');
                    rerunProofreadingBtn.disabled = false;
                    rerunProofreadingBtn.textContent = 'Re-run Proofreading';
                }
            }
            
            // Function to delete a report
            async function deleteReport(filename) {
                if (!filename) {
                    alert('No newsletter selected');
                    return;
                }

                if (!confirm('Are you sure you want to delete this newsletter? This action cannot be undone.')) {
                    return;
                }

                try {
                    const deleteBtn = document.getElementById('delete-report-btn');
                    deleteBtn.disabled = true;
                    deleteBtn.innerHTML = '<div style="display: flex; align-items: center; justify-content: center;"><span class="loading"></span> Deleting...</div>';

                    // Get the reports list to find the report ID
                    const reportsResponse = await fetch('/api/monthly-reports/list');
                    const reportsData = await reportsResponse.json();
                    
                    if (reportsData.status !== 'success' || !reportsData.reports) {
                        throw new Error('Failed to get reports list');
                    }

                    // Find the report with matching filename
                    const report = reportsData.reports.find(r => r.original_filename === filename);
                    if (!report) {
                        throw new Error('Report not found');
                    }

                    const reportId = report.id;

                    // Now delete the report using the ID
                    const deleteResponse = await fetch(`/api/monthly-reports/${reportId}`, {
                        method: 'DELETE'
                    });

                    const deleteData = await deleteResponse.json();

                    if (deleteData.status === 'success') {
                        alert('Newsletter deleted successfully!');
                        // Reload the reports list while preserving selection
                        loadReports(true);
                        // Hide the report details
                        reportDetails.style.display = 'none';
                    } else {
                        throw new Error(deleteData.message || 'Failed to delete newsletter');
                    }
                } catch (error) {
                    alert(`Error deleting newsletter: ${error.message}`);
                } finally {
                    const deleteBtn = document.getElementById('delete-report-btn');
                    deleteBtn.disabled = false;
                    deleteBtn.textContent = 'Delete Newsletter';
                }
            }
            
            async function viewReportDetails(reportId) {
                try {
                    const response = await fetch(`/backend/monthly-report/${reportId}`);
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        displayReportDetails(data.report);
                        document.getElementById('reportDetailsModal').style.display = 'block';
                    } else {
                        alert('Error loading newsletter details: ' + data.message);
                    }
                } catch (error) {
                    console.error('Error:', error);
                    alert('Error loading newsletter details');
                }
            }

            function displayReportDetails(report) {
                console.log("Displaying newsletter details:", report);
                const detailsContainer = document.getElementById('reportDetails');
                const metricsContainer = document.getElementById('report-metrics');
                
                if (!report) {
                    metricsContainer.innerHTML = '<p>Error: No newsletter data available</p>';
                    return;
                }
                
                // Format dates
                const createdDate = report.created_at ? new Date(report.created_at).toLocaleString() : 'N/A';
                const updatedDate = report.updated_at ? new Date(report.updated_at).toLocaleString() : 'N/A';
                
                // Create the HTML content for the metrics container
                let metricsHtml = `
                    <div class="report-metadata">
                        <div class="metadata-row">
                            <div class="metadata-item"><strong>District:</strong> ${report.district_name || report.district || 'N/A'}</div>
                            <div class="metadata-item"><strong>Period Type:</strong> ${report.period_type || 'N/A'}</div>
                            <div class="metadata-item"><strong>Max Items:</strong> ${report.max_items || 'N/A'}</div>
                            <div class="metadata-item"><strong>Created:</strong> ${createdDate}</div>
                            <div class="metadata-item"><strong>Last Updated:</strong> ${updatedDate}</div>
                        </div>
                        <div class="published-url-section" style="margin-top: 15px; padding: 15px; background-color: #f8f9fa; border-radius: 5px;">
                            <div style="display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                                <label for="published-url-input" style="font-weight: bold; margin-bottom: 0;">Published URL:</label>
                                <input type="url" id="published-url-input" value="${report.published_url || ''}" 
                                       placeholder="Enter the published URL..." 
                                       style="flex: 1; min-width: 300px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                <button id="update-published-url" class="action-btn primary-btn" style="margin: 0;">Update</button>
                            </div>
                            ${report.published_url ? `
                                <div style="margin-top: 10px;">
                                    <strong>Current Published URL:</strong> 
                                    <a href="${report.published_url}" target="_blank" style="color: #ad35fa; text-decoration: none; margin-left: 5px;">${report.published_url}</a>
                                </div>
                            ` : ''}
                        </div>
                        <div class="report-links" style="margin-top: 15px; display: flex; flex-wrap: wrap; gap: 15px; align-items: center;">
                            <a href="#" id="view-original-report" target="_blank" style="text-decoration: none; color: #ad35fa;">View Original</a>
                            <a href="#" id="view-revised-report" target="_blank" style="text-decoration: none; color: #ad35fa;">View Revised</a>
                            <a href="#" id="view-final-report" target="_blank" style="text-decoration: none; color: #ad35fa;">View Final (with Charts)</a>
                            <a href="#" id="view-email-report" target="_blank" style="text-decoration: none; color: #ad35fa;">Email Version</a>
                            <div id="audio-player-container" style="display: none; align-items: center; gap: 10px;">
                                <span style="color: #ad35fa; font-size: 14px;">ðŸŽ§ Audio:</span>
                                <audio id="audio-player" controls style="height: 32px;">
                                    Your browser does not support the audio element.
                                </audio>
                            </div>
                            <a href="#" id="view-audio-script" target="_blank" style="text-decoration: none; color: #ad35fa;">View Audio Script</a>
                            <a href="#" id="view-published-report" target="_blank" style="text-decoration: none; color: #ad35fa;">View Published Post</a>
                        </div>
                    </div>
                `;
                
                // Display headlines if available
                if (report.headlines && Array.isArray(report.headlines)) {
                    metricsHtml += `
                        <div class="headlines-container" style="margin-top: 20px; margin-bottom: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 8px;">
                            <h2>Headlines</h2>
                            <div class="headlines-list">
                                ${report.headlines.map(headline => {
                                    // Check if headline is an object with headline/subtitle properties
                                    if (typeof headline === 'object' && headline !== null) {
                                        let headlineHtml = '';
                                        if (headline.headline) {
                                            headlineHtml += `<h3 style="margin: 10px 0 5px 0; color: #333;">${headline.headline}</h3>`;
                                        }
                                        if (headline.subtitle) {
                                            headlineHtml += `<h4 style="margin: 5px 0 10px 0; color: #666; font-weight: normal; font-style: italic;">${headline.subtitle}</h4>`;
                                        }
                                        return headlineHtml || `<h3 style="margin: 10px 0; color: #333;">${JSON.stringify(headline)}</h3>`;
                                    } else {
                                        // Handle simple string headlines
                                        return `<h3 style="margin: 10px 0; color: #333;">${headline}</h3>`;
                                    }
                                }).join('')}
                            </div>
                        </div>
                    `;
                } else if (report.headlines && typeof report.headlines === 'object') {
                    // If headlines is a non-array object with values
                    const headlineValues = Object.values(report.headlines);
                    if (headlineValues.length > 0) {
                        metricsHtml += `
                            <div class="headlines-container" style="margin-top: 20px; margin-bottom: 20px; padding: 15px; background-color: #f8f9fa; border-radius: 8px;">
                                <h2>Headlines</h2>
                                <div class="headlines-list">
                                    ${headlineValues.map(headline => {
                                        // Check if headline is an object with headline/subtitle properties
                                        if (typeof headline === 'object' && headline !== null) {
                                            let headlineHtml = '';
                                            if (headline.headline) {
                                                headlineHtml += `<h3 style="margin: 10px 0 5px 0; color: #333;">${headline.headline}</h3>`;
                                            }
                                            if (headline.subtitle) {
                                                headlineHtml += `<h4 style="margin: 5px 0 10px 0; color: #666; font-weight: normal; font-style: italic;">${headline.subtitle}</h4>`;
                                            }
                                            return headlineHtml || `<h3 style="margin: 10px 0; color: #333;">${JSON.stringify(headline)}</h3>`;
                                        } else {
                                            // Handle simple string headlines
                                            return `<h3 style="margin: 10px 0; color: #333;">${headline}</h3>`;
                                        }
                                    }).join('')}
                                </div>
                            </div>
                        `;
                    }
                }
                
                // Display proofread feedback if available
                if (report.proofread_feedback) {
                    metricsHtml += `
                        <div class="proofread-feedback-container" style="margin-top: 20px; margin-bottom: 20px; padding: 15px; background-color: #e8f4fd; border-radius: 8px; border-left: 4px solid #007bff;">
                            <h2 style="margin: 0 0 10px 0; color: #007bff;">ðŸ“ Proofreading Feedback</h2>
                            <div class="proofread-feedback-content" style="color: #333; line-height: 1.6;">
                                ${report.proofread_feedback.replace(/\n/g, '<br>')}
                            </div>
                        </div>
                    `;
                }
                
                // Check if metrics exist in the report
                if (report.metrics && Array.isArray(report.metrics) && report.metrics.length > 0) {
                    metricsHtml += `
                        <div class="metrics-container">
                            <div class="metrics-header">
                                <h3>Items</h3>
                                <div class="metrics-actions">
                                    <button class="action-btn collapse-all-btn">Collapse All</button>
                                    <button class="action-btn expand-all-btn">Expand All</button>
                                </div>
                            </div>
                            ${report.metrics.map((metric, index) => {
                                if (!metric) return '';
                                
                                // Determine the change color class based on change_type from metadata
                                let changeClass = 'neutral-change';
                                
                                // Try to get change_type from metadata first
                                if (metric.metadata) {
                                    try {
                                        const metadata = typeof metric.metadata === 'string' 
                                            ? JSON.parse(metric.metadata) 
                                            : metric.metadata;
                                        
                                        const changeType = metadata.change_type;
                                        if (changeType === 'positive') {
                                            changeClass = 'positive-change';
                                        } else if (changeType === 'negative') {
                                            changeClass = 'negative-change';
                                        }
                                    } catch (error) {
                                        console.error('Error parsing metadata for change_type:', error);
                                    }
                                }
                                
                                // Fallback to raw percent_change if no change_type in metadata
                                if (changeClass === 'neutral-change') {
                                    if (metric.percent_change > 0) {
                                        changeClass = 'positive-change';
                                    } else if (metric.percent_change < 0) {
                                        changeClass = 'negative-change';
                                    }
                                }
                                
                                // Extract perplexity context and citations from metadata if they exist
                                let perplexityContext = '';
                                let citations = '';
                                let citationLinks = [];
                                let chartsHtml = '';
                                let trendAnalysis = '';

                                if (metric.metadata) {
                                    try {
                                        // If metadata is a string, try to parse it as JSON
                                        const metadata = typeof metric.metadata === 'string' 
                                            ? JSON.parse(metric.metadata) 
                                            : metric.metadata;
                                        
                                        perplexityContext = metadata.perplexity_context || '';
                                        trendAnalysis = metadata.trend_analysis || '';
                                        
                                        // Get charts from metadata
                                        if (metadata.charts) {
                                            let charts = [];
                                            
                                            // Handle different chart formats
                                            if (typeof metadata.charts === 'string') {
                                                try {
                                                    charts = JSON.parse(metadata.charts);
                                                } catch (e) {
                                                    // If it's not valid JSON, it might be a single chart reference
                                                    charts = [metadata.charts];
                                                }
                                            } else if (Array.isArray(metadata.charts)) {
                                                charts = metadata.charts;
                                            } else if (typeof metadata.charts === 'object') {
                                                // In case it's an object with chart info
                                                charts = [metadata.charts];
                                            }
                                            
                                            // Generate HTML for each chart
                                            if (charts.length > 0) {
                                                chartsHtml = '<div class="charts-container"><h4>Charts</h4>';
                                                
                                                charts.forEach(chart => {
                                                    if (typeof chart === 'string') {
                                                        // For simple chart references like [CHART:time_series:1:0:year]
                                                        chartsHtml += `
                                                            <div class="chart-placeholder">
                                                                ${chart}
                                                            </div>
                                                        `;
                                                    } else if (typeof chart === 'object') {
                                                        // For chart objects with more data - create an expand button instead of showing JSON
                                                        const chartTitle = chart.title || 'Chart';
                                                        let chartRef = '';
                                                        
                                                        // Try to construct a chart reference from the object
                                                        if (chart.type === 'anomaly' && chart.id) {
                                                            chartRef = `[CHART:anomaly:${chart.id}]`;
                                                        } else if (chart.type === 'time_series' && chart.metric_id) {
                                                            const district = chart.district || '0';
                                                            const period = chart.period_type || 'month';
                                                            chartRef = `[CHART:time_series:${chart.metric_id}:${district}:${period}]`;
                                                        } else if (chart.type === 'map' && chart.map_id) {
                                                            chartRef = `[CHART:map:${chart.map_id}]`;
                                                        } else if (chart.reference && chart.reference.startsWith('[CHART:')) {
                                                            // Use the reference field if it contains a chart reference
                                                            chartRef = chart.reference;
                                                        } else if (chart.html) {
                                                            // If chart has HTML, still use placeholder for consistency
                                                            // The HTML will be expanded later in the process
                                                            chartRef = `[CHART:html_chart:${chartTitle}]`;
                                                        } else if (chart.url) {
                                                            // If chart has URL, still use placeholder for consistency
                                                            // The URL will be expanded later in the process
                                                            chartRef = `[CHART:url_chart:${chart.url}]`;
                                                        } else {
                                                            // Fallback for unknown chart objects
                                                            chartRef = JSON.stringify(chart);
                                                        }
                                                        
                                                        // Create chart placeholder for expandable charts
                                                        chartsHtml += `
                                                            <div class="chart-placeholder">
                                                                ${chartRef}
                                                            </div>
                                                        `;
                                                    }
                                                });
                                                
                                                chartsHtml += '</div>';
                                            }
                                        }
                                        
                                        // Get citations from perplexity_response if available
                                        if (metadata.perplexity_response && metadata.perplexity_response.citations) {
                                            // Store the original citations array for creating links
                                            citationLinks = Array.isArray(metadata.perplexity_response.citations) 
                                                ? metadata.perplexity_response.citations 
                                                : [metadata.perplexity_response.citations];
                                            
                                            // Format citations for display
                                            citations = citationLinks.map((citation, idx) => {
                                                const anchorId = `citation-${idx + 1}`;
                                                if (typeof citation === 'string') {
                                                    return `<div id="${anchorId}" class="citation-item"><span class="citation-number">[${idx + 1}]</span> ${citation}</div>`;
                                                } else if (citation.url && citation.title) {
                                                    return `<div id="${anchorId}" class="citation-item"><span class="citation-number">[${idx + 1}]</span> <a href="${citation.url}" target="_blank" class="citation-url">${citation.title}</a>${citation.text ? ` - ${citation.text}` : ''}</div>`;
                                                } else {
                                                    return `<div id="${anchorId}" class="citation-item"><span class="citation-number">[${idx + 1}]</span> ${JSON.stringify(citation)}</div>`;
                                                }
                                            }).join('');
                                            
                                            // Replace citation references in perplexity context with hyperlinks
                                            if (perplexityContext && citationLinks.length > 0) {
                                                // Regular expression to find citation references like [1], [2], etc.
                                                const citationRegex = /\[(\d+)\]/g;
                                                perplexityContext = perplexityContext.replace(citationRegex, (match, citationNumber) => {
                                                    const idx = parseInt(citationNumber) - 1;
                                                    if (idx >= 0 && idx < citationLinks.length) {
                                                        const citation = citationLinks[idx];
                                                        if (typeof citation === 'string') {
                                                            return `<a href="#citation-${idx+1}" class="citation-link">[${citationNumber}]</a>`;
                                                        } else if (citation.url) {
                                                            return `<a href="${citation.url}" target="_blank" class="citation-link">[${citationNumber}]</a>`;
                                                        }
                                                    }
                                                    return match; // Keep original if no matching citation
                                                });
                                            }
                                        } else {
                                            citations = '';
                                        }
                                    } catch (error) {
                                        console.error('Error parsing metadata:', error);
                                    }
                                }
                                
                                // Format the percent change to display with one decimal point
                                const formatPercentChange = (value) => {
                                    console.log('formatPercentChange called with value:', value, 'type:', typeof value);
                                    if (!value && value !== 0) return 'N/A';
                                    
                                    // Convert to number if it's a string
                                    const numValue = typeof value === 'string' ? parseFloat(value) : value;
                                    
                                    // Check if it's a valid number
                                    if (isNaN(numValue)) return 'N/A';
                                    
                                    // Round to one decimal place and add % sign
                                    return numValue.toFixed(1) + '%';
                                };

                                // Format number with commas and decimal places
                                const formatNumber = (value, decimals = 1) => {
                                    if (value === undefined || value === null) return 'N/A';
                                    
                                    // Convert to number if it's a string
                                    const numValue = typeof value === 'string' ? parseFloat(value) : value;
                                    
                                    // Check if it's a valid number
                                    if (isNaN(numValue)) return 'N/A';
                                    
                                    // Format with commas and specified decimal places
                                    return numValue.toLocaleString(undefined, {
                                        minimumFractionDigits: decimals,
                                        maximumFractionDigits: decimals
                                    });
                                };

                                // Extract statistical values from metric data
                                let recentMean = 'N/A';
                                let comparisonMean = 'N/A';
                                let difference = 'N/A';
                                let stdDev = 'N/A';

                                // Try to extract values directly from metric first
                                recentMean = metric.recent_mean !== undefined ? formatNumber(metric.recent_mean) : 'N/A';
                                comparisonMean = metric.comparison_mean !== undefined ? formatNumber(metric.comparison_mean) : 'N/A';
                                difference = metric.difference !== undefined ? formatNumber(metric.difference) : 'N/A';
                                stdDev = metric.std_dev !== undefined ? formatNumber(metric.std_dev) : 'N/A';

                                // If not found in metric, try metadata
                                if ((recentMean === 'N/A' || comparisonMean === 'N/A' || difference === 'N/A' || stdDev === 'N/A') && metric.metadata) {
                                    try {
                                        const metadata = typeof metric.metadata === 'string' 
                                            ? JSON.parse(metric.metadata) 
                                            : metric.metadata;
                                        
                                        if (recentMean === 'N/A') {
                                            recentMean = metadata.recent_mean !== undefined ? formatNumber(metadata.recent_mean) : 'N/A';
                                        }
                                        if (comparisonMean === 'N/A') {
                                            comparisonMean = metadata.comparison_mean !== undefined ? formatNumber(metadata.comparison_mean) : 'N/A';
                                        }
                                        if (difference === 'N/A') {
                                            difference = metadata.difference !== undefined ? formatNumber(metadata.difference) : 'N/A';
                                        }
                                        if (stdDev === 'N/A') {
                                            stdDev = metadata.std_dev !== undefined ? formatNumber(metadata.std_dev) : 'N/A';
                                        }
                                    } catch (error) {
                                        console.error('Error parsing metadata for statistical values:', error);
                                    }
                                }

                                // Check for session_id in metadata to create conversation viewer link
                                let conversationLink = '';
                                if (metric.metadata) {
                                    try {
                                        const metadata = typeof metric.metadata === 'string' 
                                            ? JSON.parse(metric.metadata) 
                                            : metric.metadata;
                                        
                                        if (metadata.session_id) {
                                            conversationLink = `
                                                <a href="/backend/conversation?session=${metadata.session_id}" 
                                                   target="_blank" 
                                                   style="color: #ad35fa; text-decoration: none; font-weight: 500; padding: 4px 8px; border: 1px solid #ad35fa; border-radius: 4px; display: inline-block; font-size: 0.85em; margin-left: 10px; transition: all 0.2s ease;"
                                                   title="View AI Conversation">
                                                    ðŸ“‹ Session
                                                </a>
                                            `;
                                        }
                                    } catch (error) {
                                        console.error('Error parsing metadata for session_id:', error);
                                    }
                                }

                                return `
                                    <div class="metric-item collapsed">
                                        <h4 class="metric-header">
                                            <div class="metric-header-content">
                                                <div class="metric-title">${metric.item_title || metric.metric_name || 'Unnamed Item'}</div>
                                                ${conversationLink}
                                            </div>
                                            <div class="metric-stats">
                                                <span class="stat-item"><span class="stat-label">Recent Mean:</span> ${recentMean}</span>
                                                <span class="stat-item"><span class="stat-label">Comparison Mean:</span> ${comparisonMean}</span>
                                                <span class="stat-item"><span class="stat-label">Difference:</span> ${difference}</span>
                                                <span class="stat-item"><span class="stat-label">Std Dev:</span> ${stdDev}</span>
                                                <span class="change-badge ${changeClass}">${(() => {
                                                    console.log('Badge debug - metric.percent_change:', metric.percent_change, 'metric.change_percentage:', metric.change_percentage);
                                                    return formatPercentChange(metric.percent_change || metric.change_percentage);
                                                })()}</span>
                                            </div>
                                        </h4>
                                        <div class="metric-details">
                                            <p><strong>Rationale:</strong></p>
                                            <p>${metric.rationale || 'No rationale available'}</p>

                                            <p><strong>Explanation:</strong></p>
                                            <p>${metric.explanation || 'No explanation available'}</p>

                                            <p><strong>Newsletter Narrative:</strong></p>
                                            <p>${metric.report_text || 'No newsletter narrative available'}</p>

                                            ${trendAnalysis ? `
                                                <p><strong>Trend Analysis:</strong></p>
                                                <p>${trendAnalysis}</p>
                                            ` : ''}
                                            ${chartsHtml ? chartsHtml : ''}
                                            ${perplexityContext ? `
                                                <p><strong>Perplexity Context:</strong></p>
                                                <div class="perplexity-context">${perplexityContext}</div>
                                            ` : ''}
                                            ${citations ? `
                                                <p><strong>Citations:</strong></p>
                                                <div class="citations-container">${citations}</div>
                                            ` : ''}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `;
                    
                    // After setting the HTML, add event listeners for the expand/collapse all buttons
                    setTimeout(() => {
                        // Set up the published URL update button
                        const updatePublishedUrlBtn = document.getElementById('update-published-url');
                        const publishedUrlInput = document.getElementById('published-url-input');
                        
                        if (updatePublishedUrlBtn && publishedUrlInput) {
                            updatePublishedUrlBtn.addEventListener('click', async (e) => {
                                e.preventDefault();
                                
                                const newUrl = publishedUrlInput.value.trim();
                                
                                // Basic URL validation
                                if (newUrl && !isValidUrl(newUrl)) {
                                    alert('Please enter a valid URL (must start with http:// or https://)');
                                    return;
                                }
                                
                                try {
                                    // Show loading state
                                    updatePublishedUrlBtn.disabled = true;
                                    const originalText = updatePublishedUrlBtn.textContent;
                                    updatePublishedUrlBtn.innerHTML = '<span class="loading"></span> Updating...';
                                    
                                    // Get the report ID from the selected option
                                    const selectedOption = reportSelect.options[reportSelect.selectedIndex];
                                    const originalFilename = selectedOption.value;
                                    
                                    // Find the report in the loaded data to get the ID
                                    const report = reportsData?.reports?.find(r => r.original_filename === originalFilename);
                                    if (!report) {
                                        throw new Error("Could not find report data");
                                    }
                                    
                                    // Call the API to update the published URL
                                    const response = await fetch(`/backend/update_published_url/${report.id}`, {
                                        method: 'POST',
                                        headers: {
                                            'Content-Type': 'application/json'
                                        },
                                        body: JSON.stringify({
                                            published_url: newUrl || null
                                        })
                                    });
                                    
                                    const data = await response.json();
                                    
                                    if (data.status === 'success') {
                                        alert('Published URL updated successfully!');
                                        
                                        // Update the local data
                                        if (reportsData && reportsData.reports) {
                                            const reportIndex = reportsData.reports.findIndex(r => r.id === report.id);
                                            if (reportIndex !== -1) {
                                                reportsData.reports[reportIndex].published_url = newUrl || null;
                                            }
                                        }
                                        
                                        // Refresh the display
                                        loadReportDetails(originalFilename);
                                    } else {
                                        throw new Error(data.message || 'Failed to update published URL');
                                    }
                                } catch (error) {
                                    console.error('Error updating published URL:', error);
                                    alert(`Error updating published URL: ${error.message}`);
                                } finally {
                                    // Reset button state
                                    updatePublishedUrlBtn.disabled = false;
                                    updatePublishedUrlBtn.textContent = 'Update';
                                }
                            });
                        }
                        
                        const expandAllBtn = document.querySelector('.expand-all-btn');
                        const collapseAllBtn = document.querySelector('.collapse-all-btn');
                        
                        // Make sure all items are initially collapsed
                        document.querySelectorAll('.metric-item').forEach(item => {
                            item.classList.add('collapsed');
                            item.classList.remove('expanded');
                        });
                        
                        // Add click handlers to all metric headers
                        document.querySelectorAll('.metric-header').forEach(header => {
                            header.addEventListener('click', () => {
                                const parent = header.closest('.metric-item');
                                parent.classList.toggle('collapsed');
                                parent.classList.toggle('expanded');
                            });
                        });
                        
                        // Process any chart placeholders to expand them
                        const chartPlaceholders = document.querySelectorAll('.chart-placeholder');
                        console.log('Found chart placeholders:', chartPlaceholders.length);
                        
                        chartPlaceholders.forEach((placeholder, index) => {
                            const chartRef = placeholder.textContent.trim();
                            console.log(`Processing placeholder ${index}:`, chartRef);
                            
                            if (chartRef.startsWith('[CHART:')) {
                                console.log('Found chart reference:', chartRef);
                                
                                // Expand chart references when clicked
                                placeholder.style.cursor = 'pointer';
                                placeholder.style.backgroundColor = '#f0f0f0';
                                placeholder.style.padding = '10px';
                                placeholder.style.borderRadius = '5px';
                                placeholder.style.marginBottom = '10px';
                                placeholder.style.display = 'block';
                                placeholder.style.textAlign = 'center';
                                
                                placeholder.innerHTML = `
                                    <div>
                                        <div>${chartRef}</div>
                                        <button class="action-btn expand-chart-btn" style="margin-top: 10px;">Expand Chart</button>
                                    </div>
                                `;
                                
                                const expandBtn = placeholder.querySelector('.expand-chart-btn');
                                console.log('Found expand button:', expandBtn);
                                
                                if (expandBtn) {
                                    expandBtn.addEventListener('click', (e) => {
                                        console.log('Chart expand button clicked!', chartRef);
                                        e.preventDefault();
                                        e.stopPropagation();
                                        
                                        // Extract chart type and params
                                        const chartMatch = chartRef.match(/\[CHART:([^:]+):([^\]]+)\]/);
                                        if (chartMatch) {
                                            const chartType = chartMatch[1];
                                            const params = chartMatch[2];
                                            const paramParts = params.split(':');
                                            
                                            if (chartType === 'time_series' || chartType === 'time_series_id') {
                                                // For time series charts: [CHART:time_series:metric_id:district:period] or [CHART:time_series_id:chart_id]
                                                if (paramParts.length === 1) {
                                                    // Chart ID format: [CHART:time_series_id:chart_id]
                                                    const chartId = paramParts[0];
                                                    placeholder.innerHTML = `
                                                        <div>
                                                            <iframe src="/backend/time-series-chart?chart_id=${chartId}" 
                                                                    style="width: 100%; height: 400px; border: none;" frameborder="0">
                                                            </iframe>
                                                        </div>
                                                    `;
                                                } else {
                                                    // Metric format: [CHART:time_series:metric_id:district:period]
                                                    const metricId = paramParts[0];
                                                    const district = paramParts[1] || '0';
                                                    const period = paramParts[2] || 'month';
                                                    placeholder.innerHTML = `
                                                        <div>
                                                            <iframe src="/backend/time-series-chart?metric_id=${metricId}&district=${district}&period_type=${period}" 
                                                                    style="width: 100%; height: 400px; border: none;" frameborder="0">
                                                            </iframe>
                                                        </div>
                                                    `;
                                                }
                                            } else if (chartType === 'anomaly') {
                                                // For anomaly: [CHART:anomaly:anomaly_id]
                                                const anomalyId = paramParts[0];
                                                
                                                // Create iframe for anomaly chart
                                                placeholder.innerHTML = `
                                                    <div>
                                                        <iframe src="/anomaly-analyzer/anomaly-chart?id=${anomalyId}" 
                                                                style="width: 100%; height: 600px; border: none;" frameborder="0" scrolling="yes">
                                                        </iframe>
                                                    </div>
                                                `;
                                            } else if (chartType === 'map') {
                                                // For map: [CHART:map:map_id]
                                                const mapId = paramParts[0];
                                                
                                                // Create iframe for map chart
                                                placeholder.innerHTML = `
                                                    <div>
                                                        <iframe src="/backend/map-chart?id=${mapId}" 
                                                                style="width: 100%; height: 400px; border: none;" frameborder="0">
                                                        </iframe>
                                                    </div>
                                                `;
                                            } else {
                                                // Unknown chart type
                                                placeholder.innerHTML = `
                                                    <div style="color: red; padding: 20px;">
                                                        <p>Unknown chart type: ${chartType}</p>
                                                        <p>Chart reference: ${chartRef}</p>
                                                    </div>
                                                `;
                                            }
                                        } else {
                                            // Invalid chart reference format
                                            placeholder.innerHTML = `
                                                <div style="color: red; padding: 20px;">
                                                    <p>Invalid chart reference format</p>
                                                    <p>Chart reference: ${chartRef}</p>
                                                </div>
                                            `;
                                        }
                                    });
                                }
                            } else if (chartRef.startsWith('{') || chartRef.startsWith('[')) {
                                // Handle JSON objects that might represent chart data
                                console.log('Found JSON chart data:', chartRef);
                                
                                placeholder.style.cursor = 'pointer';
                                placeholder.style.backgroundColor = '#f0f0f0';
                                placeholder.style.padding = '10px';
                                placeholder.style.borderRadius = '5px';
                                placeholder.style.marginBottom = '10px';
                                placeholder.style.display = 'block';
                                placeholder.style.textAlign = 'center';
                                
                                placeholder.innerHTML = `
                                    <div>
                                        <div>Chart Data Available</div>
                                        <button class="action-btn expand-chart-btn" style="margin-top: 10px;">Show Chart Data</button>
                                    </div>
                                `;
                                
                                const expandBtn = placeholder.querySelector('.expand-chart-btn');
                                console.log('Found JSON expand button:', expandBtn);
                                
                                if (expandBtn) {
                                    expandBtn.addEventListener('click', (e) => {
                                        console.log('JSON chart button clicked!', chartRef);
                                        e.preventDefault();
                                        e.stopPropagation();
                                        
                                        // Try to parse and format the JSON
                                        try {
                                            const chartData = JSON.parse(chartRef);
                                            const formattedJson = JSON.stringify(chartData, null, 2);
                                            
                                            placeholder.innerHTML = `
                                                <div style="text-align: left;">
                                                    <h5>Chart Data:</h5>
                                                    <pre style="background: #f8f8f8; padding: 15px; border-radius: 5px; overflow-x: auto; font-size: 12px;">${formattedJson}</pre>
                                                    <button class="action-btn" style="margin-top: 10px;" onclick="this.parentElement.parentElement.querySelector('.chart-placeholder').style.display='none'">Hide</button>
                                                </div>
                                            `;
                                        } catch (e) {
                                            placeholder.innerHTML = `
                                                <div style="text-align: left;">
                                                    <h5>Raw Chart Data:</h5>
                                                    <pre style="background: #f8f8f8; padding: 15px; border-radius: 5px; overflow-x: auto; font-size: 12px;">${chartRef}</pre>
                                                    <button class="action-btn" style="margin-top: 10px;" onclick="this.parentElement.parentElement.querySelector('.chart-placeholder').style.display='none'">Hide</button>
                                                </div>
                                            `;
                                        }
                                    });
                                }
                            }
                        });
                        
                        if (expandAllBtn) {
                            expandAllBtn.addEventListener('click', (e) => {
                                e.preventDefault();
                                document.querySelectorAll('.metric-item').forEach(item => {
                                    item.classList.remove('collapsed');
                                    item.classList.add('expanded');
                                });
                            });
                        }
                        
                        if (collapseAllBtn) {
                            collapseAllBtn.addEventListener('click', (e) => {
                                e.preventDefault();
                                document.querySelectorAll('.metric-item').forEach(item => {
                                    item.classList.add('collapsed');
                                    item.classList.remove('expanded');
                                });
                            });
                        }
                    }, 100);
                } else {
                    // If no metrics, show a message
                    metricsHtml += `
                        <div class="metrics-container">
                            <h3>Items</h3>
                            <p>No items data available for this newsletter.</p>
                        </div>
                    `;
                }
                
                // Add HTML for the original and revised report sections
                const selectedOption = reportSelect.options[reportSelect.selectedIndex];
                const revisedFilename = selectedOption.dataset.revisedFilename;
                const originalFilename = selectedOption.value;
                // Email filename should be based on the revised filename (which is the input to the consolidated function)
                const emailFilename = revisedFilename ? revisedFilename.replace('.html', '_email.html') : 
                                     (originalFilename ? originalFilename.replace('.html', '_email.html') : null);

                // Remove the report-content-sections div completely

                // Update the metrics container
                metricsContainer.innerHTML = metricsHtml;
                
                // Also update the modal details container for consistency
                if (detailsContainer) {
                    detailsContainer.innerHTML = metricsHtml;
                }

                setTimeout(() => {
                    updateReportLinks();
                }, 100);
            }

            // Initialize event handlers for prompt editor
            function initPromptEditor() {
                // Add keyboard shortcuts
                promptContent.addEventListener('keydown', function(e) {
                    // Ctrl+S or Cmd+S to save
                    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                        e.preventDefault();
                        if (!savePromptBtn.disabled) {
                            savePromptChanges();
                        }
                    }
                    
                    // Escape to cancel
                    if (e.key === 'Escape') {
                        e.preventDefault();
                        promptEditModal.style.display = 'none';
                    }
                    
                    // Tab key handling for indentation
                    if (e.key === 'Tab') {
                        e.preventDefault();
                        const start = this.selectionStart;
                        const end = this.selectionEnd;
                        
                        // Insert a tab at the caret position
                        this.value = this.value.substring(0, start) + '    ' + this.value.substring(end);
                        
                        // Put caret at right position again
                        this.selectionStart = this.selectionEnd = start + 4;
                    }
                });
                
                // Make textarea auto-resize
                promptContent.addEventListener('input', function() {
                    // Reset height to avoid problems when deleting text
                    this.style.height = 'auto';
                    
                    // Set height based on scrollHeight, add some padding
                    this.style.height = (this.scrollHeight + 10) + 'px';
                });
            }

            // Add click handler for consolidated chart conversion and finalization
            const convertChartsFinalizeBtn = document.getElementById('convert-charts-finalize');
            if (convertChartsFinalizeBtn) {
                convertChartsFinalizeBtn.onclick = async (e) => {
                    e.preventDefault();
                    const selectedOption = reportSelect.options[reportSelect.selectedIndex];
                    if (!selectedOption || !selectedOption.value) {
                        alert('Please select a newsletter to convert charts and finalize.');
                        return;
                    }
                    
                    // Get the revised filename if available, otherwise use original
                    const revisedFilename = selectedOption.dataset.revisedFilename;
                    const originalFilename = selectedOption.value;
                    const filename = revisedFilename || originalFilename;
                    
                    // Use the output/reports directory path
                    const report_path = `output/reports/${filename}`;
                    convertChartsFinalizeBtn.disabled = true;
                    const originalText = convertChartsFinalizeBtn.textContent;
                    convertChartsFinalizeBtn.innerHTML = '<div style="display: flex; align-items: center; justify-content: center;"><span class="loading"></span> Converting Charts & Finalizing...</div>';
                    
                    try {
                        // Call backend endpoint to convert charts and create both outputs
                        const response = await fetch('/backend/convert_charts_and_finalize', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ report_path: report_path })
                        });
                        const data = await response.json();
                        if (data.status === 'success') {
                            const chartsProcessed = data.charts_processed || 0;
                            const chartsConverted = data.charts_converted || 0;
                            alert(`Charts converted and outputs finalized successfully!\n\nCharts processed: ${chartsProcessed}\nCharts converted to Datawrapper: ${chartsConverted}\n\nEmail version: ${data.email_path}\nWeb version: ${data.web_path}`);
                            loadReports(true);
                            // Update button states after completion
                            setTimeout(() => updateButtonStates(selectedReport), 1000);
                        } else {
                            throw new Error(data.message || 'Failed to convert charts and finalize');
                        }
                    } catch (error) {
                        alert('Error: ' + error.message);
                    } finally {
                        convertChartsFinalizeBtn.disabled = false;
                        convertChartsFinalizeBtn.textContent = originalText;
                    }
                };
            }
            
            // Add click handler for expand-charts button
            const expandChartsBtn = document.getElementById('expand-charts');
            if (expandChartsBtn) {
                expandChartsBtn.onclick = async (e) => {
                    e.preventDefault();
                    const selectedOption = reportSelect.options[reportSelect.selectedIndex];
                    if (!selectedOption || !selectedOption.value) {
                        alert('Please select a newsletter to expand charts.');
                        return;
                    }
                    
                    // Get the original or revised filename (prefer revised if available)
                    const revisedFilename = selectedOption.dataset.revisedFilename;
                    const originalFilename = selectedOption.value;
                    const filename = revisedFilename || originalFilename;
                    
                    // Set loading state
                    expandChartsBtn.disabled = true;
                    const originalText = expandChartsBtn.textContent;
                    expandChartsBtn.innerHTML = '<div style="display: flex; align-items: center; justify-content: center;"><span class="loading"></span> Expanding Charts...</div>';
                    
                    try {
                        // Call backend endpoint to expand chart placeholders
                        const response = await fetch('/backend/expand_chart_placeholders', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ filename })
                        });
                        
                        const data = await response.json();
                        
                        if (data.status === 'success') {
                            alert('Chart placeholders expanded successfully!');
                            // Reload the report to show the updated charts
                            loadReportDetails(filename);
                        } else {
                            throw new Error(data.message || 'Failed to expand chart placeholders');
                        }
                    } catch (error) {
                        alert('Error: ' + error.message);
                    } finally {
                        expandChartsBtn.disabled = false;
                        expandChartsBtn.textContent = originalText;
                    }
                };
            }
            
            // Function to generate narrated version of the newsletter
            async function generateNarration(filename) {
                try {
                    // Get the selected option to extract title
                    const selectedOption = reportSelect.options[reportSelect.selectedIndex];
                    const reportTitle = selectedOption.textContent;
                    
                    // Show loading state
                    const narrationBtn = document.getElementById('generate-narration');
                    narrationBtn.disabled = true;
                    narrationBtn.innerHTML = '<div style="display: flex; align-items: center; justify-content: center;"><span class="loading"></span> Generating Narration...</div>';
                    
                    // Confirm with the user 
                    if (!confirm(`Are you sure you want to generate narration for "${reportTitle}"?`)) {
                        narrationBtn.disabled = false;
                        narrationBtn.textContent = 'Generate Narration';
                        return;
                    }
                    
                    // Call the API to generate narration
                    const response = await fetch('/backend/generate_narrated_report', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            filename: filename
                        })
                    });
                    
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        // Create download link for the audio file
                        const audioFilename = data.audio_filename;
                        const downloadUrl = `/backend/narration/${audioFilename}`;
                        
                        // Create a temporary link to download the file
                        const link = document.createElement('a');
                        link.href = downloadUrl;
                        link.download = audioFilename;
                        link.style.display = 'none';
                        document.body.appendChild(link);
                        link.click();
                        document.body.removeChild(link);
                        
                        // Refresh the audio player to show the new narration
                        setTimeout(() => {
                            updateReportLinks();
                        }, 1000);
                        
                        alert(`Narration generated successfully!\nThe audio file "${audioFilename}" has been downloaded and is now available in the player.`);
                    } else {
                        throw new Error(data.message || 'Failed to generate narration');
                    }
                } catch (error) {
                    console.error('Error generating narration:', error);
                    alert(`Error generating narration: ${error.message}`);
                } finally {
                    // Reset button state
                    const narrationBtn = document.getElementById('generate-narration');
                    narrationBtn.disabled = false;
                    narrationBtn.textContent = 'Generate Narration';
                }
            }

            // Function to validate URL format
            function isValidUrl(string) {
                try {
                    const url = new URL(string);
                    return url.protocol === 'http:' || url.protocol === 'https:';
                } catch (_) {
                    return false;
                }
            }

            // Function to re-prioritize deltas for a newsletter
            async function reprioritizeDeltas(filename) {
                if (!filename) {
                    alert('No newsletter selected');
                    return;
                }

                if (!confirm('Are you sure you want to re-prioritize deltas for this newsletter? This will remove the current monthly_reporting data and regenerate it from the top.')) {
                    return;
                }

                try {
                    const reprioritizeBtn = document.getElementById('reprioritize-deltas-btn');
                    reprioritizeBtn.disabled = true;
                    reprioritizeBtn.innerHTML = '<div style="display: flex; align-items: center; justify-content: center;"><span class="loading"></span> Re-prioritizing...</div>';

                    // Get the reports list to find the report ID and other details
                    const reportsResponse = await fetch('/api/monthly-reports/list');
                    const reportsData = await reportsResponse.json();
                    
                    if (reportsData.status !== 'success' || !reportsData.reports) {
                        throw new Error('Failed to get reports list');
                    }

                    // Find the report with matching filename
                    const report = reportsData.reports.find(r => r.original_filename === filename);
                    if (!report) {
                        throw new Error('Report not found');
                    }

                    // Call the backend to re-prioritize deltas
                    const response = await fetch('/backend/reprioritize_deltas', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            filename: filename,
                            district: report.district || '0',
                            period_type: report.period_type || 'month',
                            max_report_items: report.max_items || 10
                        })
                    });

                    const data = await response.json();

                    if (data.status === 'success') {
                        alert('Deltas re-prioritized successfully! The monthly_reporting data has been cleared and regenerated.');
                        // Reload the reports list and details while preserving selection
                        loadReports(true);
                        // Update button states after completion
                        setTimeout(() => updateButtonStates(filename), 1000);
                        setTimeout(() => {
                            // Reselect the current report to refresh its details
                            reportSelect.value = filename;
                            loadReportDetails(filename);
                        }, 1000);
                    } else {
                        throw new Error(data.message || 'Failed to re-prioritize deltas');
                    }
                } catch (error) {
                    alert(`Error re-prioritizing deltas: ${error.message}`);
                } finally {
                    const reprioritizeBtn = document.getElementById('reprioritize-deltas-btn');
                    reprioritizeBtn.disabled = false;
                    reprioritizeBtn.textContent = 'Re-prioritize deltas';
                }
            }

            // Function to re-explain deltas for a newsletter
            async function reexplainDeltas(filename) {
                if (!filename) {
                    alert('No newsletter selected');
                    return;
                }

                if (!confirm('Are you sure you want to regenerate explanations, get perplexity context, and generate newsletter text for this newsletter? This will replace all existing explanations with new AI-generated ones and add additional context.')) {
                    return;
                }

                try {
                    const reexplainBtn = document.getElementById('reexplain-deltas-btn');
                    reexplainBtn.disabled = true;
                    reexplainBtn.innerHTML = '<div style="display: flex; align-items: center; justify-content: center;"><span class="loading"></span> Re-explaining & generating...</div>';

                    // Get the selected model from the dropdown
                    const modelSelect = document.getElementById('model-select');
                    const selectedModel = modelSelect.value;

                    const response = await fetch('/backend/regenerate_explanations', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            filename: filename,
                            model_key: selectedModel
                        })
                    });

                    const result = await response.json();

                    if (response.ok && result.status === 'success') {
                        let successMessage = `Success! ${result.message}`;
                        
                        // Add detailed status information if available
                        if (result.explanations_generated !== undefined) {
                            successMessage += `\n\nDetailed Status:`;
                            successMessage += `\nâ€¢ Explanations: ${result.explanations_generated ? 'âœ… Generated' : 'âŒ Failed'}`;
                            successMessage += `\nâ€¢ Perplexity Context: ${result.context_enriched ? 'âœ… Enriched' : 'âŒ Failed'}`;
                            successMessage += `\nâ€¢ Newsletter Text: ${result.newsletter_text_generated ? 'âœ… Generated' : 'âŒ Failed'}`;
                        }
                        
                        alert(successMessage);
                        // Reload the reports list while preserving selection
                        loadReports(true);
                        // Update button states after completion
                        setTimeout(() => updateButtonStates(filename), 1000);
                        // Optionally refresh the newsletter details
                        loadReportDetails(filename);
                    } else {
                        alert(`Error: ${result.message || 'Unknown error occurred'}`);
                    }

                } catch (error) {
                    console.error('Error re-explaining deltas:', error);
                    alert(`Error re-explaining deltas: ${error.message}`);
                } finally {
                    const reexplainBtn = document.getElementById('reexplain-deltas-btn');
                    reexplainBtn.disabled = false;
                    reexplainBtn.textContent = 'Re-explain deltas & generate newsletter text';
                }
            }


            // Wrapper function for consolidated chart conversion and finalization
            async function convertChartsAndFinalize(filename) {
                // For complete regeneration, we need to find the revised filename if it exists
                const baseName = filename.replace(/\.html$/, '');
                const revisedFilename = baseName + '_revised.html';
                
                // Check if revised file exists, otherwise use original
                let report_path = `output/reports/${revisedFilename}`;
                const revisedExists = await checkFileExists(revisedFilename);
                if (!revisedExists) {
                    report_path = `output/reports/${filename}`;
                }
                
                const response = await fetch('/backend/convert_charts_and_finalize', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ report_path })
                });
                const data = await response.json();
                if (data.status !== 'success') {
                    throw new Error(data.message || 'Failed to convert charts and finalize');
                }
                return data;
            }

            // Function to regenerate complete newsletter workflow
            async function regenerateCompleteNewsletter(filename) {
                if (!filename) {
                    alert('No newsletter selected');
                    return;
                }

                if (!confirm('Are you sure you want to regenerate the complete newsletter? This will run all steps: Re-explain deltas, Re-write newsletter, Re-run proofreading, and Convert charts and finalize. This may take several minutes.')) {
                    return;
                }

                const regenerateBtn = document.getElementById('regenerate-newsletter-btn');
                const originalText = regenerateBtn.textContent;
                regenerateBtn.disabled = true;

                const steps = [
                    { name: 'Re-explain deltas', func: () => reexplainDeltas(filename) },
                    { name: 'Re-write newsletter', func: () => rerunReportGeneration(filename) },
                    { name: 'Re-run proofreading', func: () => rerunProofreading(filename) },
                    { name: 'Convert charts and finalize', func: () => convertChartsAndFinalize(filename) }
                ];

                try {
                    for (let i = 0; i < steps.length; i++) {
                        const step = steps[i];
                        const progress = `(${i + 1}/${steps.length})`;
                        regenerateBtn.innerHTML = `<div style="display: flex; align-items: center; justify-content: center;"><span class="loading"></span> ${progress} ${step.name}...</div>`;
                        
                        console.log(`Starting step ${i + 1}: ${step.name}`);
                        await step.func();
                        console.log(`Completed step ${i + 1}: ${step.name}`);
                        
                        // Small delay between steps
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    }

                    // Final success message
                    regenerateBtn.innerHTML = '<div style="display: flex; align-items: center; justify-content: center;"><span style="color: #28a745;">âœ“</span> Complete!</div>';
                    alert('Newsletter regeneration completed successfully!');
                    
                    // Reload reports and update button states
                    loadReports(true);
                    setTimeout(() => updateButtonStates(selectedReport), 1000);
                    
                } catch (error) {
                    console.error('Error in newsletter regeneration:', error);
                    alert(`Error during newsletter regeneration: ${error.message}`);
                } finally {
                    // Reset button after a delay
                    setTimeout(() => {
                        regenerateBtn.disabled = false;
                        regenerateBtn.textContent = originalText;
                    }, 3000);
                }
            }
        });
    </script>

    <!-- Dark Mode JavaScript -->
    <script src="/static/js/darkmode.js"></script>
    <script src="/static/js/iframe-darkmode.js"></script>
</body>
</html> 