<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Series Chart | TransparentSF</title>

    <!-- Favicon -->
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon.png">
    <link rel="apple-touch-icon" sizes="180x180" href="/static/apple-touch-icon.png">
    <link rel="manifest" href="/static/site.webmanifest">
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Plotly.js for visualizations -->
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        :root {
            --spruce-green: #4A7463;
            --soft-sand: #F6F1EA;
            --warm-coral: #FF6B5A;
            --sky-blue: #71B2CA;
            --ink-black: #222222;
        }
        
        body {
            font-family: 'IBM Plex Sans', Arial, sans-serif;
            color: var(--ink-black);
            background-color: white;
            padding: 0; /* Remove default padding to allow full width */
            font-size: 14px;
        }
        
        [data-theme="dark"] body {
            background-color: #1a1a1a;
            color: #ffffff;
        }
        
        .chart-container {
            background-color: white;
            border-radius: 8px;
            padding: 10px;
            margin: 0; /* Remove auto centering */
            box-shadow: none;
            max-width: 600px; /* Cap width at 600px */
        }
        
        [data-theme="dark"] .chart-container {
            background-color: #1a1a1a;
            overflow: visible;
            position: relative;
            display: flex;
            justify-content: flex-start; /* Left justify instead of center */
            align-items: center;
            width: 100%;
            max-width: 600px; /* Cap width at 600px */
            border: none;
            box-sizing: border-box;
        }
        
        /* Add corner shading elements */
        .chart-container::before {
            content: '';
            position: absolute;
            top: 0;
            right: 0;
            width: 61.8%;
            height: 61.8%;
            border-top: 2px solid rgba(0, 0, 0, 0.2);
            border-right: 2px solid rgba(0, 0, 0, 0.2);
            border-top-right-radius: 8px;
            display: block;
            pointer-events: none;
            z-index: 1; /* Ensure framing appears above chart content */
            box-sizing: border-box;
            /* Use CSS custom properties for dynamic sizing with fallback */
            max-width: calc(var(--container-width, 61.8%) * 0.618);
            max-height: calc(var(--container-height, 61.8%) * 0.618);
        }
        
        .chart-container::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 61.8%;
            height: 61.8%;
            border-bottom: 2px solid rgba(0, 0, 0, 0.2);
            border-left: 2px solid rgba(0, 0, 0, 0.2);
            border-bottom-left-radius: 8px;
            display: block;
            pointer-events: none;
            z-index: 1; /* Ensure framing appears above chart content */
            box-sizing: border-box;
            /* Use CSS custom properties for dynamic sizing with fallback */
            max-width: calc(var(--container-width, 61.8%) * 0.618);
            max-height: calc(var(--container-height, 61.8%) * 0.618);
        }

        /* Dark mode corner frames */
        [data-theme="dark"] .chart-container::before {
            border-top: 2px solid rgba(255, 255, 255, 0.3);
            border-right: 2px solid rgba(255, 255, 255, 0.3);
        }

        [data-theme="dark"] .chart-container::after {
            border-bottom: 2px solid rgba(255, 255, 255, 0.3);
            border-left: 2px solid rgba(255, 255, 255, 0.3);
        }
        
        .header {
            color: var(--spruce-green);
            margin-bottom: 15px;
            font-size: 1.5rem;
        }
        
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 250px;
            color: var(--spruce-green);
        }
        
        .error-message {
            color: var(--warm-coral);
            padding: 12px;
            background-color: rgba(255, 107, 90, 0.1);
            border-radius: 5px;
            font-size: 0.9rem;
        }
        
        .metadata {
            background-color: rgba(246, 241, 234, 0.7);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 15px;
            font-size: 0.9rem;
        }
        
        /* Dark mode support for metadata */
        [data-theme="dark"] .metadata {
            background-color: rgba(30, 30, 30, 0.8);
            color: #ffffff;
        }
        
        .chart-caption {
            font-size: 11px;
            padding: 6px;
            background-color: rgba(246, 241, 234, 0.7);
            border-radius: 4px;
            margin-top: 8px;
        }
        
        .badge {
            background-color: var(--spruce-green);
            color: white;
            font-weight: normal;
            padding: 3px 8px;
            font-size: 0.75rem;
        }
        
        #time-series-chart {
            width: 100%;
            height: 0;
            padding-bottom: 75%; /* Changed from 100% to 75% for better fit in 437x437 window */
            position: relative;
            overflow: visible;
            display: flex;
            justify-content: center;
            align-items: center;
            box-sizing: border-box;
        }
        
        #time-series-plot {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* Ensure Plotly elements are responsive */
        .js-plotly-plot, .plot-container {
            width: 100% !important;
            height: 100% !important;
            max-width: 100% !important;
            max-height: 100% !important;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 6px;
        }
        
        .main-svg {
            width: 100% !important;
            height: 100% !important;
            max-width: 100% !important;
            max-height: 100% !important;
        }
        
        /* Responsive adjustments */
        @media (max-width: 576px) {
            body {
                padding: 10px;
            }
            
            .chart-container {
                padding: 8px;
            }
            
            .metadata {
                padding: 10px;
            }
            
            .mt-3.d-flex {
                flex-direction: column;
            }
            
            .mt-3.d-flex .btn {
                margin: 5px 0;
                width: 100%;
            }
            
            #time-series-chart {
                padding-bottom: 70%; /* Slightly shorter for mobile */
            }
        }
        
        /* Add media query for wider screens */
        @media (min-width: 768px) {
            #time-series-chart {
                padding-bottom: 75%; /* Maintain 4:3 aspect ratio on wider screens */
            }
        }
        
        @media (min-width: 1200px) {
            #time-series-chart {
                padding-bottom: 75%; /* Maintain 4:3 aspect ratio on very wide screens */
            }
        }
        
        /* Special handling for small embedded windows */
        @media (max-height: 500px) {
            #time-series-chart {
                padding-bottom: 60%; /* Even shorter for very small height windows */
            }
            
            .chart-container {
                padding: 5px;
            }
        }
        
        /* Special handling for very small embedded windows (like 437x437) */
        @media (max-width: 450px) and (max-height: 450px) {
            #time-series-chart {
                padding-bottom: 55%; /* Even more compact for very small windows */
            }
            
            .chart-container {
                padding: 3px;
                max-width: 100%;
            }
            
            body {
                padding: 5px;
            }
        }
        
        /* Ensure framing elements scale properly with container size */
        .chart-container {
            position: relative;
            overflow: visible;
        }
        
        /* Override framing size for very small containers */
        @media (max-width: 300px) {
            .chart-container::before,
            .chart-container::after {
                width: 50% !important;
                height: 50% !important;
            }
        }
        
        /* Improved group filter styling */
        .group-filter-container {
            background: linear-gradient(135deg, rgba(246, 241, 234, 0.8) 0%, rgba(255, 255, 255, 0.9) 100%);
            border: 1px solid rgba(74, 116, 99, 0.2);
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }
        
        /* Dark mode support for group filter */
        [data-theme="dark"] .group-filter-container {
            background: linear-gradient(135deg, rgba(30, 30, 30, 0.8) 0%, rgba(45, 45, 45, 0.9) 100%);
            border: 1px solid rgba(74, 116, 99, 0.4);
            color: #ffffff;
        }
        
        [data-theme="dark"] .group-filter-container .form-check-label {
            color: #ffffff;
        }
        
        [data-theme="dark"] .group-filter-container .badge {
            background-color: #4A7463 !important;
            color: #ffffff !important;
        }
        
        [data-theme="dark"] .group-filter-container .btn {
            color: #ffffff;
        }
        
        [data-theme="dark"] .group-filter-container .btn-outline-primary {
            border-color: #4A7463;
            color: #4A7463;
        }
        
        [data-theme="dark"] .group-filter-container .btn-outline-primary:hover {
            background-color: #4A7463;
            color: #ffffff;
        }
        
        [data-theme="dark"] .group-filter-container .btn-outline-secondary {
            border-color: #6c757d;
            color: #6c757d;
        }
        
        [data-theme="dark"] .group-filter-container .btn-outline-secondary:hover {
            background-color: #6c757d;
            color: #ffffff;
        }
        
        [data-theme="dark"] .group-filter-container .btn-primary {
            background-color: #4A7463;
            border-color: #4A7463;
        }
        
        [data-theme="dark"] .group-filter-container .btn-primary:hover {
            background-color: #3a5d4e;
            border-color: #3a5d4e;
        }
        
        [data-theme="dark"] .group-filter-container .text-muted {
            color: #adb5bd !important;
        }
        
        [data-theme="dark"] .group-checkbox-container:hover {
            background-color: rgba(74, 116, 99, 0.2);
        }
        
        /* Dark mode support for alerts */
        [data-theme="dark"] .alert-warning {
            background-color: rgba(255, 193, 7, 0.2);
            border-color: #ffc107;
            color: #ffffff;
        }
        
        [data-theme="dark"] .alert-warning .btn-close {
            filter: invert(1);
        }
        
        .group-checkbox-container {
            transition: all 0.2s ease-in-out;
        }
        
        .group-checkbox-container:hover {
            background-color: rgba(74, 116, 99, 0.05);
            border-radius: 4px;
            padding: 2px;
        }
        
        .form-check-input:checked {
            background-color: var(--spruce-green);
            border-color: var(--spruce-green);
        }
        
        .form-check-input:focus {
            box-shadow: 0 0 0 0.2rem rgba(74, 116, 99, 0.25);
        }
        
        .btn-group .btn {
            border-radius: 4px !important;
        }
        
        .btn-group .btn:first-child {
            border-top-right-radius: 0 !important;
            border-bottom-right-radius: 0 !important;
        }
        
        .btn-group .btn:last-child {
            border-top-left-radius: 0 !important;
            border-bottom-left-radius: 0 !important;
        }
        
        /* Responsive improvements for group filters */
        @media (max-width: 768px) {
            .group-filter-container .btn-group {
                flex-direction: column;
                width: 100%;
            }
            
            .group-filter-container .btn-group .btn {
                border-radius: 4px !important;
                margin-bottom: 2px;
            }
            
            .group-filter-container .d-flex {
                flex-direction: column;
            }
            
            .group-filter-container .d-flex .btn {
                margin-bottom: 5px;
            }
        }
        
        /* Ensure the container takes full height in chart section mode */
        body.chart-section-mode {
            margin: 0;
            padding: 0;
            height: auto;
            min-height: auto;
            background-color: transparent;
            overflow: hidden;
        }
        
        body.chart-section-mode .container {
            padding: 0;
            margin: 0;
            width: 100%;
            max-width: none;
            height: auto;
        }
        
        /* Remove Bootstrap container constraints for all modes to allow full width */
        .container {
            max-width: none !important;
            padding-left: 0 !important;
            padding-right: 0 !important;
        }
        
        body.chart-section-mode .row,
        body.chart-section-mode .col-12 {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        
        /* Ensure the modebar is hidden with CSS as well */
        .modebar {
            display: none !important;
        }
        
        /* Attribution line styling */
        .chart-attribution {
            transition: opacity 0.2s ease-in-out;
        }
        
        .chart-attribution:hover {
            opacity: 1;
        }
        
        /* Responsive attribution for small screens */
        @media (max-width: 450px) {
            .chart-attribution {
                font-size: 9px !important;
                padding: 2px 6px !important;
            }
            
            .chart-attribution a {
                font-size: 9px !important;
            }
            
            .chart-attribution i {
                font-size: 7px !important;
            }
        }
        
        /* Dark mode support for attribution */
        [data-theme="dark"] .chart-attribution {
            background-color: rgba(30, 30, 30, 0.9) !important;
            color: #cccccc !important;
        }
        
        [data-theme="dark"] .chart-attribution a {
            color: #cccccc !important;
        }
        
        /* YTD Chart legend styling */
        .ytd-legend {
            font-family: 'IBM Plex Sans', Arial, sans-serif !important;
        }
        
        /* Responsive legend for small screens */
        @media (max-width: 450px) {
            .ytd-legend {
                font-size: 8px !important;
            }
        }
    </style>

    <!-- Dark Mode CSS - embedded for reliability -->
    <style>
        /* Core dark mode variables and styles embedded for reliability */
        :root {
            --text-primary: #222222;
            --text-secondary: #666666;
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --border-primary: #e5e7eb;
            --bright-purple: #ad35fa;
        }
        
        [data-theme="dark"] {
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --border-primary: #404040;
        }
        
        /* Additional dark mode styles for charts */
        [data-theme="dark"] .metadata {
            background-color: rgba(45, 45, 45, 0.8) !important;
            color: #ffffff !important;
        }
        
        [data-theme="dark"] .group-filter-container {
            background: linear-gradient(135deg, rgba(45, 45, 45, 0.8) 0%, rgba(60, 60, 60, 0.9) 100%) !important;
            border: 1px solid rgba(74, 116, 99, 0.4) !important;
            color: #ffffff !important;
        }
        
        [data-theme="dark"] .alert-warning {
            background-color: rgba(255, 193, 7, 0.2) !important;
            border-color: #ffc107 !important;
            color: #ffffff !important;
        }
    </style>
    
    <!-- Fallback: load external CSS if available -->
    <link rel="stylesheet" href="/static/darkmode.css">
</head>
<body>
    <div class="container">
        <div class="row">
            <div class="col-12">
                <h1 class="header">Time Series Chart</h1>
                
                <!-- Metadata will be displayed here -->
                <div id="metadata" class="metadata"></div>
                
                <!-- Chart container -->
                <div id="chart-section" class="chart-container">
                    <div id="loading" class="loading">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Loading...</span>
                        </div>
                    </div>
                    <div id="error-message" class="error-message" style="display: none;"></div>
                    <div id="time-series-chart"></div>
                    <div id="datasf-link" class="mt-3" style="text-align: center;"></div>
                </div>
                
                <div class="mt-3 d-flex justify-content-between flex-column flex-sm-row">
                    <a href="javascript:history.back()" class="btn btn-outline-secondary mb-2 mb-sm-0">Back</a>
                    <div class="d-flex flex-column flex-sm-row">
                        <button id="share-btn" class="btn btn-outline-success mb-2 mb-sm-0 me-sm-2" onclick="copyShareLink()">
                            <i class="fas fa-share-alt me-1"></i> Share
                        </button>
                        <button id="embed-btn" class="btn btn-outline-primary" onclick="showEmbedCode()">
                            <i class="fas fa-code me-1"></i> Embed
                        </button>
                    </div>
                </div>
                
                <!-- Embed code modal -->
                <div class="modal fade" id="embedModal" tabindex="-1" aria-labelledby="embedModalLabel" inert>
                    <div class="modal-dialog">
                        <div class="modal-content">
                            <div class="modal-header">
                                <h5 class="modal-title" id="embedModalLabel">Embed Chart</h5>
                                <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                            </div>
                            <div class="modal-body">
                                <p>Copy and paste this code into your website or article:</p>
                                <div class="input-group mb-3">
                                    <textarea id="embedCode" class="form-control" rows="3" readonly></textarea>
                                    <button class="btn btn-outline-primary" type="button" onclick="copyEmbedCode()">
                                        <i class="fas fa-copy"></i>
                                    </button>
                                </div>
                                <div class="form-check mb-3">
                                    <input class="form-check-input" type="checkbox" id="responsiveCheck" checked>
                                    <label class="form-check-label" for="responsiveCheck">
                                        Make responsive
                                    </label>
                                </div>
                                <div class="form-group mb-3">
                                    <label for="widthInput">Width:</label>
                                    <input type="text" class="form-control" id="widthInput" value="100%">
                                </div>
                                <div class="form-group mb-3">
                                    <label for="heightInput">Height:</label>
                                    <input type="text" class="form-control" id="heightInput" value="600px">
                                </div>
                                <button class="btn btn-primary" onclick="updateEmbedCode()">Update Code</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Bootstrap JS Bundle with Popper -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <script>
        // Get parameters from URL
        const urlParams = new URLSearchParams(window.location.search);
        const chartId = urlParams.get('chart_id');
        const metricId = urlParams.get('metric_id');
        const district = urlParams.get('district') || '0';
        const periodType = urlParams.get('period_type') || 'month';
        const groups = urlParams.get('groups'); // Get groups parameter from URL
        const groupField = urlParams.get('group_field'); // Get group_field parameter from URL
        const fullView = urlParams.get('full_view') === 'true'; // Check if full view is requested
        
        // Apply chart-section-mode by default unless full_view=true is specified
        document.body.classList.toggle('chart-section-mode', !fullView);
        
        // Elements
        const loadingEl = document.getElementById('loading');
        const errorMessageEl = document.getElementById('error-message');
        const metadataEl = document.getElementById('metadata');
        
        // Hide non-chart elements by default unless full_view=true is specified
        if (!fullView) {
            const header = document.querySelector('.header');
            const metadata = document.getElementById('metadata');
            const buttons = document.querySelector('.mt-3');
            const embedModal = document.getElementById('embedModal');
            
            if (header) header.style.display = 'none';
            if (metadata) metadata.style.display = 'none';
            if (buttons) buttons.style.display = 'none';
            if (embedModal) embedModal.style.display = 'none';
            
            // Set chart container to maintain aspect ratio
            const chartContainer = document.getElementById('chart-section');
            if (chartContainer) {
                chartContainer.style.margin = '0 auto';
                chartContainer.style.maxWidth = '100%';
                chartContainer.style.width = '100%';
                chartContainer.style.display = 'flex';
                chartContainer.style.justifyContent = 'center';
                chartContainer.style.alignItems = 'center';
                

            }
        }
        
        // Function to show loading state
        function showLoading() {
            loadingEl.style.display = 'flex';
            errorMessageEl.style.display = 'none';
        }
        
        // Function to show error message
        function showError(message) {
            loadingEl.style.display = 'none';
            errorMessageEl.style.display = 'block';
            errorMessageEl.textContent = message;
        }
        
        // Function to hide loading state
        function hideLoading() {
            loadingEl.style.display = 'none';
        }
        
        // Function to format values for display
        function formatValue(value) {
            if (value === null || value === undefined || isNaN(value)) return '-';
            return parseFloat(value).toLocaleString(undefined, {
                minimumFractionDigits: 0,
                maximumFractionDigits: 2
            });
        }
        
        // Function to render the time series chart
        function renderTimeSeriesChart(data) {
            // Get metadata and data
            const metadata = data.metadata || {};
            const timeSeriesData = data.data || [];
            const itemNoun = metadata.item_noun || '';
            
            if (timeSeriesData.length === 0) {
                showError('No data available for the specified parameters.');
                return;
            }
            
            console.log("Rendering time series chart for data:", data);
            
            // Check if we have valid data
            if (!data || !data.data || !Array.isArray(data.data) || data.data.length === 0) {
                showError('Invalid or incomplete time series data received.');
                return;
            }
            
            // Determine period type early so it can be used throughout the function
            const isYearlyData = metadata.period_type === 'yearly' || metadata.period_type === 'year' || metadata.period_type === 'annual' || periodType === 'year';
            const isWeeklyData = metadata.period_type === 'weekly' || metadata.period_type === 'week' || periodType === 'week';
            
            // Check if we have grouped data
            const hasGroups = timeSeriesData.some(item => item.group_value);
            
            // Determine labels based on metadata - PRIORITIZE y_axis_label
            let yAxisLabel = metadata.y_axis_label || metadata.object_name || "Value";
            let xAxisLabel = "Date";
            
            // Hide loading indicator
            hideLoading();
            
            // Create a container for the chart
            const chartElement = document.getElementById('time-series-chart');
            chartElement.innerHTML = ''; // Clear existing content
            chartElement.style.display = 'flex';
            chartElement.style.justifyContent = 'center';
            chartElement.style.alignItems = 'center';
            chartElement.style.width = '100%';
            chartElement.style.height = '100%';
            
            // Create a new div for the actual chart
            const plotDiv = document.createElement('div');
            plotDiv.id = 'time-series-plot';
            plotDiv.style.width = '100%';
            plotDiv.style.height = '100%';
            plotDiv.style.maxWidth = '100%';
            plotDiv.style.maxHeight = '100%';
            chartElement.appendChild(plotDiv);
            
            // Create traces for the chart
            const traces = [];
            
            // Initialize common variables that will be used later
            let formattedDates = [];
            let values = [];
            let lastDate, lastValue;
            
            if (hasGroups) {
                // Check if this is a YTD trend chart (grouped by year)
                const isYtdTrendChart = metadata.group_field === 'year' && 
                                       timeSeriesData.some(item => item.group_value && 
                                       (item.group_value === '2024' || item.group_value === '2025' || 
                                        item.group_value === '2023' || item.group_value === '2026'));
                
                if (isYtdTrendChart) {
                    // Special handling for YTD trend charts
                    console.log("Rendering YTD trend chart with day-of-year axis");
                    
                    // Group data by year
                    const groupedData = {};
                    timeSeriesData.forEach(item => {
                        const year = item.group_value;
                        if (!groupedData[year]) {
                            groupedData[year] = [];
                        }
                        groupedData[year].push(item);
                    });
                    
                    // Create traces for each year
                    Object.entries(groupedData).forEach(([year, yearItems]) => {
                        // Convert dates to day-of-year (1-365)
                        const dayOfYearData = yearItems.map(item => {
                            // More robust date parsing
                            let date;
                            const dateStr = item.time_period;
                            
                            // Handle different date formats
                            if (dateStr.includes('T')) {
                                // ISO format with time
                                date = new Date(dateStr);
                            } else if (dateStr.includes('-')) {
                                // YYYY-MM-DD format
                                const [year, month, day] = dateStr.split('-').map(Number);
                                date = new Date(year, month - 1, day); // month is 0-indexed
                            } else {
                                // Fallback to default parsing
                                date = new Date(dateStr);
                            }
                            
                            const startOfYear = new Date(date.getFullYear(), 0, 1);
                            const dayOfYear = Math.floor((date - startOfYear) / (1000 * 60 * 60 * 24)) + 1;
                            
                            // Debug logging
                            console.log(`Date: ${item.time_period}, Parsed: ${date}, DayOfYear: ${dayOfYear}, Value: ${item.numeric_value}`);
                            
                            return {
                                dayOfYear: dayOfYear,
                                value: item.numeric_value,
                                originalDate: date
                            };
                        });
                        
                        // Sort by day of year
                        dayOfYearData.sort((a, b) => a.dayOfYear - b.dayOfYear);
                        
                        // Filter out any invalid day-of-year values
                        const validDayOfYearData = dayOfYearData.filter(d => d.dayOfYear >= 1 && d.dayOfYear <= 366 && !isNaN(d.dayOfYear));
                        
                        // Debug: Log the sorted data
                        console.log(`Valid dayOfYearData for ${year}:`, validDayOfYearData.map(d => ({ dayOfYear: d.dayOfYear, value: d.value, date: d.originalDate })));
                        
                        // Use the valid data
                        const dailyX = validDayOfYearData.map(d => d.dayOfYear);
                        const dailyY = validDayOfYearData.map(d => d.value);
                        
                        // Choose color based on year - use purple for current year, grey for previous
                        const isCurrentYear = year === new Date().getFullYear().toString();
                        const lineColor = isCurrentYear ? '#ad35fa' : '#888888'; // Primary purple for current year, grey for previous
                        
                        // -------------------------------------------------------------
                        // Add raw data line and optional 7-day trailing average
                        // -------------------------------------------------------------

                        // Check if data points are monthly vs daily based on metadata
                        // Also check if data is labeled as "day" but is actually monthly (sparse data points)
                        const isMonthlyData = metadata.period_type === 'month' || metadata.period_type === 'monthly';
                        
                        // Additional check: if data is labeled as "day" but has sparse data points (likely monthly)
                        // Count unique day-of-year values to determine if it's actually monthly data
                        // Monthly data typically has 12 or fewer data points per year
                        const uniqueDayValues = [...new Set(dailyX)];
                        const isSparseData = uniqueDayValues.length <= 12; // If 12 or fewer unique day values, likely monthly
                        
                        // Use monthly treatment if explicitly monthly OR if sparse data (likely monthly despite "day" label)
                        const shouldUseMonthlyTreatment = isMonthlyData || isSparseData;
                        
                        // Log the detection for debugging
                        if (shouldUseMonthlyTreatment) {
                            console.log(`YTD Chart: Using monthly treatment for ${year} - period_type: ${metadata.period_type}, unique days: ${uniqueDayValues.length}, isMonthlyData: ${isMonthlyData}, isSparseData: ${isSparseData}`);
                        }
                        
                        if (shouldUseMonthlyTreatment) {
                            // For monthly data, just show the raw data without 7-day averaging
                            traces.push({
                                x: dailyX,
                                y: dailyY,
                                type: 'scatter',
                                mode: 'lines+markers',
                                name: `${year}`,
                                line: { color: lineColor, width: 3 },
                                marker: { size: 6 },
                                showlegend: true,
                                hovertemplate: `${year}<br>%{customdata}<br>%{y}<extra></extra>`,
                                hoverlabel: {
                                    bgcolor: '#F6F1EA',
                                    bordercolor: '#4A7463',
                                    font: { 
                                        family: 'IBM Plex Sans, Arial, sans-serif',
                                        size: 10,
                                        color: '#222222'
                                    }
                                },
                                customdata: dailyX.map(dayOfYear => {
                                    const date = new Date(parseInt(year), 0, dayOfYear);
                                    // For sparse data (likely monthly), show month and year
                                    // For regular monthly data, also show month and year
                                    return date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                                }),
                            });
                        } else {
                            // For daily data (dense data points), compute 7-day trailing average
                            const avg7 = dailyY.map((_, idx) => {
                                const start = Math.max(0, idx - 6);
                                const window = dailyY.slice(start, idx + 1);
                                const sum = window.reduce((acc, v) => acc + v, 0);
                                return sum / window.length;
                            });

                            // Raw daily values – faint for context
                            traces.push({
                                x: dailyX,
                                y: dailyY,
                                type: 'scatter',
                                mode: 'lines',
                                name: `${year}`,
                                line: { color: lineColor, width: 1 },
                                opacity: 0.25,
                                showlegend: false, // Hide daily values from legend
                                hoverinfo: 'skip', // No hover labels for raw data
                                hoverlabel: {
                                    bgcolor: '#F6F1EA',
                                    bordercolor: '#4A7463',
                                    font: { 
                                        family: 'IBM Plex Sans, Arial, sans-serif',
                                        size: 10,
                                        color: '#222222'
                                    }
                                }
                            });

                            // 7-day trailing average – primary focus
                            traces.push({
                                x: dailyX,
                                y: avg7,
                                type: 'scatter',
                                mode: 'lines',
                                name: `${year} 7-Day Avg`,
                                line: { color: lineColor, width: 3 },
                                showlegend: true, // Always show legend for YTD charts
                                hovertemplate: `${year} 7-Day Avg<br>%{customdata}<br>%{y}<extra></extra>`,
                                hoverlabel: {
                                    bgcolor: '#F6F1EA',
                                    bordercolor: '#4A7463',
                                    font: { 
                                        family: 'IBM Plex Sans, Arial, sans-serif',
                                        size: 10,
                                        color: '#222222'
                                    }
                                },
                                customdata: dailyX.map(dayOfYear => {
                                    const date = new Date(parseInt(year), 0, dayOfYear);
                                    return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric' });
                                }),
                            });
                        }
                        
                        // Set common variables for YTD trend charts
                        formattedDates = Array.from({length: 365}, (_, i) => i + 1); // 1-365
                        values = []; // Not used for YTD trend charts
                        
                    });
                    
                } else {
                    // Regular grouped chart handling (existing code)
                    // Group data by group_value
                    const groupedData = {};
                    timeSeriesData.forEach(item => {
                        const groupValue = item.group_value || 'Unknown';
                        if (!groupedData[groupValue]) {
                            groupedData[groupValue] = [];
                        }
                        groupedData[groupValue].push(item);
                    });
                    
                    // Define a color palette for groups - expanded to avoid recycling
                    const colorPalette = [
                        '#ad35fa', // Primary Purple
                        '#FF6B5A', // Warm Coral
                        '#4A7463', // Spruce Green
                        '#71B2CA', // Sky Blue
                        '#FFC107', // Amber
                        '#9C27B0', // Purple
                        '#2196F3', // Light Blue
                        '#E91E63', // Pink
                        '#4CAF50', // Green
                        '#FF5722', // Deep Orange
                        '#1A365D', // Dark Blue
                        '#2D3748', // Dark Gray
                        '#4A5568', // Medium Gray
                        '#718096', // Light Gray
                        '#A0AEC0', // Very Light Gray
                        '#E2E8F0', // Almost White
                        '#F7FAFC', // Pure White
                        '#FF0080', // Magenta
                        '#00FF80', // Bright Green
                        '#8000FF', // Deep Purple
                        '#FF8000', // Orange
                        '#0080FF', // Blue
                        '#80FF00', // Lime
                        '#00FFFF', // Cyan
                        '#FF00FF', // Fuchsia
                        '#FFFF00', // Yellow
                        '#8B4513', // Saddle Brown
                        '#228B22', // Forest Green
                        '#FF1493', // Deep Pink
                        '#00CED1', // Dark Turquoise
                        '#FFD700', // Gold
                        '#FF69B4', // Hot Pink
                        '#32CD32', // Lime Green
                        '#FF4500', // Orange Red
                        '#9370DB', // Medium Purple
                        '#20B2AA', // Light Sea Green
                        '#FF6347', // Tomato
                        '#7B68EE', // Medium Slate Blue
                        '#3CB371', // Medium Sea Green
                        '#FF7F50', // Coral
                        '#6A5ACD', // Slate Blue
                        '#00FA9A', // Medium Spring Green
                        '#FFB6C1', // Light Pink
                        '#4169E1', // Royal Blue
                        '#DC143C', // Crimson
                        '#00BFFF', // Deep Sky Blue
                        '#FF8C00', // Dark Orange
                        '#9932CC', // Dark Orchid
                        '#8FBC8F', // Dark Sea Green
                        '#FF69B4', // Hot Pink
                        '#00CED1', // Dark Turquoise
                        '#FFD700', // Gold
                        '#FF1493', // Deep Pink
                        '#32CD32', // Lime Green
                        '#FF4500', // Orange Red
                        '#9370DB', // Medium Purple
                        '#20B2AA', // Light Sea Green
                        '#FF6347', // Tomato
                        '#7B68EE', // Medium Slate Blue
                        '#3CB371', // Medium Sea Green
                        '#FF7F50', // Coral
                        '#6A5ACD', // Slate Blue
                        '#00FA9A', // Medium Spring Green
                        '#FFB6C1', // Light Pink
                        '#4169E1', // Royal Blue
                        '#DC143C', // Crimson
                        '#00BFFF', // Deep Sky Blue
                        '#FF8C00', // Dark Orange
                        '#9932CC'  // Dark Orchid
                    ];
                    
                    // Create a trace for each group
                    let colorIndex = 0;
                    Object.entries(groupedData).forEach(([groupValue, groupItems]) => {
                        const formattedDates = groupItems.map(item => {
                            const dateStr = item.time_period;
                            
                            // Check if this is a weekly format (YYYY-WXX)
                            if (dateStr.includes('W') && dateStr.includes('-')) {
                                const [yearPart, weekPart] = dateStr.split('-');
                                const year = parseInt(yearPart);
                                const weekNum = parseInt(weekPart.replace('W', ''));
                                
                                // Create a date for the first day of the year
                                const jan1 = new Date(year, 0, 1);
                                
                                // Find the first Monday of the year (ISO week starts on Monday)
                                // If Jan 1 is Monday (weekday=0), we're good. Otherwise, find the next Monday
                                const daysUntilMonday = (7 - jan1.getDay()) % 7;
                                const firstMonday = new Date(jan1.getTime() + daysUntilMonday * 24 * 60 * 60 * 1000);
                                
                                // Calculate the target date by adding weeks
                                return new Date(firstMonday.getTime() + (weekNum - 1) * 7 * 24 * 60 * 60 * 1000);
                            } else {
                                // Handle regular date formats
                                const dateParts = dateStr.split('-');
                                const year = parseInt(dateParts[0]);
                                const month = parseInt(dateParts[1]) - 1; // JS months are 0-indexed
                                const day = dateParts.length > 2 ? parseInt(dateParts[2]) : 1; // Default to 1st if no day
                                return new Date(year, month, day);
                            }
                        });
                        
                        const values = groupItems.map(item => item.numeric_value);
                        
                        // Add time series data for this group
                        traces.push({
                            x: formattedDates,
                            y: values,
                            type: 'scatter',
                            mode: 'lines+markers',
                            name: groupValue,
                            line: { color: colorPalette[colorIndex % colorPalette.length], width: 2 },
                            marker: { color: colorPalette[colorIndex % colorPalette.length], size: 6 },
                            showlegend: fullView,
                            hovertemplate: isYearlyData ? 
                                `${groupValue}<br>%{x|%Y}<br>%{y}<extra></extra>` :
                                isWeeklyData ? 
                                `${groupValue}<br>%{x|%B %d, %Y}<br>%{y}<extra></extra>` : 
                                `${groupValue}<br>%{x|%B %Y}<br>%{y}<extra></extra>`,
                            hoverlabel: {
                                bgcolor: '#F6F1EA', // Soft Sand
                                bordercolor: '#4A7463', // Spruce Green
                                font: { 
                                    family: 'IBM Plex Sans, Arial, sans-serif',
                                    size: 10,
                                    color: '#222222' // Ink Black
                                }
                            }
                        });
                        
                        colorIndex++;
                    });
                    
                    // Calculate overall mean for all groups combined
                    const allValues = timeSeriesData.map(item => item.numeric_value);
                    const mean = calculateMean(allValues);
                    
                    // Set the common formattedDates and values with data from all groups
                    // We'll use the first group's dates for the overall timeline
                    if (Object.values(groupedData).length > 0) {
                        const firstGroupData = Object.values(groupedData)[0];
                        formattedDates = firstGroupData.map(item => {
                            const dateStr = item.time_period;
                            
                            // Check if this is a weekly format (YYYY-WXX)
                            if (dateStr.includes('W') && dateStr.includes('-')) {
                                const [yearPart, weekPart] = dateStr.split('-');
                                const year = parseInt(yearPart);
                                const weekNum = parseInt(weekPart.replace('W', ''));
                                
                                // Create a date for the first day of the year
                                const jan1 = new Date(year, 0, 1);
                                
                                // Find the first Monday of the year (ISO week starts on Monday)
                                // If Jan 1 is Monday (weekday=0), we're good. Otherwise, find the next Monday
                                const daysUntilMonday = (7 - jan1.getDay()) % 7;
                                const firstMonday = new Date(jan1.getTime() + daysUntilMonday * 24 * 60 * 60 * 1000);
                                
                                // Calculate the target date by adding weeks
                                return new Date(firstMonday.getTime() + (weekNum - 1) * 7 * 24 * 60 * 60 * 1000);
                            } else {
                                // Handle regular date formats
                                const dateParts = dateStr.split('-');
                                const year = parseInt(dateParts[0]);
                                const month = parseInt(dateParts[1]) - 1; // JS months are 0-indexed
                                const day = dateParts.length > 2 ? parseInt(dateParts[2]) : 1; // Default to 1st if no day
                                return new Date(year, month, day);
                            }
                        });
                        values = firstGroupData.map(item => item.numeric_value);
                    }
                    
                    // Add mean line
                    traces.push({
                        x: [new Date(Math.min(...timeSeriesData.map(item => {
                            const dateStr = item.time_period;
                            if (dateStr.includes('W') && dateStr.includes('-')) {
                                const [yearPart, weekPart] = dateStr.split('-');
                                const year = parseInt(yearPart);
                                const weekNum = parseInt(weekPart.replace('W', ''));
                                const jan1 = new Date(year, 0, 1);
                                const daysUntilMonday = (7 - jan1.getDay()) % 7;
                                const firstMonday = new Date(jan1.getTime() + daysUntilMonday * 24 * 60 * 60 * 1000);
                                return new Date(firstMonday.getTime() + (weekNum - 1) * 7 * 24 * 60 * 60 * 1000).getTime();
                            } else {
                                return new Date(dateStr).getTime();
                            }
                        }))), 
                             new Date(Math.max(...timeSeriesData.map(item => {
                                 const dateStr = item.time_period;
                                 if (dateStr.includes('W') && dateStr.includes('-')) {
                                     const [yearPart, weekPart] = dateStr.split('-');
                                     const year = parseInt(yearPart);
                                     const weekNum = parseInt(weekPart.replace('W', ''));
                                     const jan1 = new Date(year, 0, 1);
                                     const daysUntilMonday = (7 - jan1.getDay()) % 7;
                                     const firstMonday = new Date(jan1.getTime() + daysUntilMonday * 24 * 60 * 60 * 1000);
                                     return new Date(firstMonday.getTime() + (weekNum - 1) * 7 * 24 * 60 * 60 * 1000).getTime();
                                 } else {
                                     return new Date(dateStr).getTime();
                                 }
                             })))],
                        y: [mean, mean],
                        type: 'scatter',
                        mode: 'lines',
                        name: `Average: ${formatValue(mean)}`, // Label with mean value
                        line: { 
                            color: 'rgba(0, 0, 0, 0.3)', // Faint Black
                            width: 1,
                            dash: 'dash' // Dashed line
                        },
                        showlegend: fullView
                    });
                }
            } else {
                // Extract dates and values from the data array
                formattedDates = timeSeriesData.map(item => {
                    const dateStr = item.time_period;
                    
                    // Check if this is a weekly format (YYYY-WXX)
                    if (dateStr.includes('W') && dateStr.includes('-')) {
                        const [yearPart, weekPart] = dateStr.split('-');
                        const year = parseInt(yearPart);
                        const weekNum = parseInt(weekPart.replace('W', ''));
                        
                        // Create a date for the first day of the year
                        const jan1 = new Date(year, 0, 1);
                        
                        // Find the first Monday of the year (ISO week starts on Monday)
                        // If Jan 1 is Monday (weekday=0), we're good. Otherwise, find the next Monday
                        const daysUntilMonday = (7 - jan1.getDay()) % 7;
                        const firstMonday = new Date(jan1.getTime() + daysUntilMonday * 24 * 60 * 60 * 1000);
                        
                        // Calculate the target date by adding weeks
                        return new Date(firstMonday.getTime() + (weekNum - 1) * 7 * 24 * 60 * 60 * 1000);
                    } else {
                        // Handle regular date formats
                        const dateParts = dateStr.split('-');
                        const year = parseInt(dateParts[0]);
                        const month = parseInt(dateParts[1]) - 1; // JS months are 0-indexed
                        const day = dateParts.length > 2 ? parseInt(dateParts[2]) : 1; // Default to 1st if no day
                        return new Date(year, month, day);
                    }
                });
                
                values = timeSeriesData.map(item => item.numeric_value);
                
                // Calculate mean and standard deviation
                const mean = calculateMean(values);
                const stdDev = calculateStandardDeviation(values, mean);
                
                // Add mean line
                traces.push({
                    x: formattedDates,
                    y: formattedDates.map(() => mean),
                    type: 'scatter',
                    mode: 'lines',
                    name: `Average: ${formatValue(mean)}`, // Label with mean value
                    line: { 
                        color: 'rgba(0, 123, 255, 0.3)', // Faint Bright Blue
                        width: 1,
                        dash: 'solid' // Solid line
                    },
                    showlegend: fullView
                });
                
                // Add time series data
                traces.push({
                    x: formattedDates,
                    y: values,
                    type: 'scatter',
                    mode: 'lines+markers',
                    name: itemNoun || 'Time Series',
                                                line: { color: '#ad35fa', width: 2 }, // Primary Purple
                            marker: { color: '#ad35fa', size: 6 }, // Primary Purple
                    showlegend: fullView,
                    hovertemplate: isYearlyData ? '%{x|%Y}<br>%{y}<extra></extra>' : isWeeklyData ? '%{x|%B %d, %Y}<br>%{y}<extra></extra>' : '%{x|%B %Y}<br>%{y}<extra></extra>', // Format based on period type
                    hoverlabel: {
                        bgcolor: '#F6F1EA', // Soft Sand
                        bordercolor: '#4A7463', // Spruce Green
                        font: { 
                            family: 'IBM Plex Sans, Arial, sans-serif',
                            size: 10,
                            color: '#222222' // Ink Black
                        }
                    }
                });
            }
            
            // Get the metric name from metadata
            const objectName = metadata.object_name || metadata.field_name || 'Time Series';
            
            // Check if this is a YTD trend chart
            const isYtdTrendChart = metadata.group_field === 'year' && 
                                   timeSeriesData.some(item => item.group_value && 
                                   (item.group_value === '2024' || item.group_value === '2025' || 
                                    item.group_value === '2023' || item.group_value === '2026'));
            
            // --- START RE-ADD SUBTITLE LOGIC ---
            let subtitleText = '';
            let combinedTitleText = objectName; // Default to just objectName
            const district = metadata.district;

            if (district !== undefined && district !== null && district !== 0) {
                // Only add subtitle if district is specified and not citywide (0)
                const districtName = `District ${district}`;
                subtitleText = `${districtName} - ${metadata.period_type || periodType} Data${itemNoun ? ' · ' + itemNoun : ''}`;
                combinedTitleText = `${objectName}<br><span style="font-size: 0.7em;">${subtitleText}</span>`; // Combine with smaller subtitle
            } else {
                // Optional: If district is 0 (Citywide), you could add a generic subtitle if desired
                subtitleText = `Citywide - ${metadata.period_type || periodType} Data${itemNoun ? ' · ' + itemNoun : ''}`;
                combinedTitleText = `${objectName}<br><span style="font-size: 0.7em;">${subtitleText}</span>`; // Combine with smaller subtitle
            }
            // --- END RE-ADD SUBTITLE LOGIC ---
            
            // Create xAxisYearLabels for year display
            let years, yearDates, xAxisYearLabels;
            
            if (isYtdTrendChart) {
                // For YTD trend charts, formattedDates contains day-of-year numbers (1-365)
                // We need to get years from the actual data
                const dataYears = [...new Set(timeSeriesData.map(item => {
                    const date = new Date(item.time_period);
                    return date.getFullYear();
                }))];
                years = dataYears;
                yearDates = years.map(year => new Date(year, 0, 1));
                xAxisYearLabels = yearDates.map(d => d.getFullYear().toString());
            } else {
                // For regular charts, formattedDates contains Date objects
                years = [...new Set(formattedDates.map(d => d.getFullYear()))];
                yearDates = years.map(year => new Date(year, 0, 1));
                xAxisYearLabels = yearDates.map(d => d.getFullYear().toString());
            }

            // Configuration for the plot
            let layout;
            
            if (isYtdTrendChart) {
                // Calculate the actual range from the data for YTD charts
                const allDayOfYearValues = [];
                timeSeriesData.forEach(item => {
                    const date = new Date(item.time_period);
                    const startOfYear = new Date(date.getFullYear(), 0, 1);
                    const dayOfYear = Math.floor((date - startOfYear) / (1000 * 60 * 60 * 24)) + 1;
                    allDayOfYearValues.push(dayOfYear);
                });
                
                const minDay = Math.min(...allDayOfYearValues);
                const maxDay = Math.max(...allDayOfYearValues);
                
                // Special layout for YTD trend charts
                layout = {
                    title: {
                        text: combinedTitleText,
                        font: {
                            family: 'Inter, Arial, sans-serif',
                            size: 20, 
                            color: '#222222' 
                        },
                        y: 0.98, 
                        x: 0.02,
                        xanchor: 'left',
                        pad: { t:10, b: 10 }
                    },
                    xaxis: {
                        title: {
                            text: '', // Remove "Day of Year" label
                            font: { 
                                family: 'IBM Plex Sans, Arial, sans-serif',
                                size: 10,
                                color: '#222222' 
                            },
                            standoff: 30
                        },
                        showgrid: true,
                        gridcolor: 'rgba(232, 233, 235, 0.3)',
                        tickfont: { 
                            family: 'IBM Plex Sans, Arial, sans-serif',
                            size: 9,
                            color: '#222222' 
                        },
                        tickmode: 'array',
                        tickvals: [1, 32, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], // Approximate start of each month
                        ticktext: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
                        range: [minDay, maxDay + 10], // Use actual data range with small padding
                        showline: true,
                        linecolor: '#e5e7eb',
                        linewidth: 1,
                        ticklen: 3,
                        tickcolor: '#222222'
                    },
                    yaxis: {
                        title: {
                            text: '',
                            font: { 
                                family: 'IBM Plex Sans, Arial, sans-serif',
                                size: 10,
                                color: '#222222' 
                            },
                            standoff: 15
                        },
                        showgrid: true,
                        gridcolor: 'rgba(232, 233, 235, 0.5)',
                        zeroline: false,
                        rangemode: 'tozero',
                        tickfont: { 
                            family: 'IBM Plex Sans, Arial, sans-serif',
                            size: 9,
                            color: '#222222' 
                        }
                    },
                    showlegend: true,
                    legend: {
                        orientation: 'h',
                        x: 0.5,
                        y: -0.02,
                        xanchor: 'center',
                        yanchor: 'top',
                        font: { 
                            family: 'IBM Plex Sans, Arial, sans-serif',
                            size: 8,
                            color: '#222222' 
                        },
                        bgcolor: 'transparent',
                        bordercolor: 'transparent',
                        borderwidth: 0,
                        class: 'ytd-legend',
                        itemsizing: 'constant',
                        itemwidth: 20
                    },
                    margin: { t: 55, b: 80, l: 50, r: 30 },
                    height: null,
                    width: null,
                    autosize: true,
                    paper_bgcolor: 'transparent',
                    plot_bgcolor: 'transparent',
                    hovermode: 'closest',
                    dragmode: fullView ? 'zoom' : false, // Enable drag zoom only in full view mode
                    responsive: true,
                    hoverlabel: {
                        bgcolor: '#F6F1EA',
                        bordercolor: '#4A7463',
                        font: { 
                            family: 'IBM Plex Sans, Arial, sans-serif',
                            size: 9,
                            color: '#222222' 
                        }
                    }
                };
            } else {
                // Regular layout for other charts
                layout = {
                    title: {
                        text: combinedTitleText, // Use objectName or combined text
                        font: {
                            family: 'Inter, Arial, sans-serif',
                            size: 20, 
                            color: '#222222' 
                        },
                        y: 0.98, 
                        x: 0.02, // Changed from 0.5 to 0.02 for left justification
                        xanchor: 'left', // Changed from 'center' to 'left' for left justification
                        pad: { t:10, b: 10 } // Adjust padding as needed, t:10 was b:10 before
                    },
                    annotations: [
                        // Removed the last datapoint annotation - no more label on last datapoint
                    ],
                    xaxis: {
                        title: {
                            text: '', // Remove the "Date" label
                            font: { 
                                family: 'IBM Plex Sans, Arial, sans-serif',
                                size: 10, // Reduced from 12
                                color: '#222222' // Ink Black
                            },
                            standoff: 30 // Reduced from 40
                        },
                        showgrid: false,
                        tickformat: isYearlyData ? '%Y' : isWeeklyData ? '%b %d' : '%b %Y',
                        tickfont: { 
                            family: 'IBM Plex Sans, Arial, sans-serif',
                            size: 9, // Reduced from 11
                            color: '#222222' // Ink Black
                        },
                        // Custom tick labels - Use actual data points for ticks, not the padded range
                        tickmode: 'array',
                        tickvals: isYearlyData ? yearDates : formattedDates,
                        ticktext: isYearlyData ? xAxisYearLabels : formattedDates.map((d, index) => {
                            const month = d.getMonth();
                            const year = d.getFullYear();
                            const day = d.getDate();
                            
                            // Safety check: if this is somehow yearly data that got here, just show the year
                            if (metadata.period_type === 'yearly' || metadata.period_type === 'year' || metadata.period_type === 'annual' || periodType === 'year') {
                                return year.toString();
                            }
                            
                            if (isWeeklyData) {
                                // For weekly data, show month and day (e.g., "Jan 15")
                                const fullMonths = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                                let label = `${fullMonths[month].substring(0, 3)} ${day}`;
                                
                                // If this is the first week of a year in our dataset, add year below
                                if (index === 0 || formattedDates[index - 1].getFullYear() !== year) {
                                    label += `<br>${year}`;
                                } else {
                                    // Add empty line to maintain vertical spacing
                                    label += "<br> ";
                                }
                                
                                return label;
                            } else {
                                // For monthly data, show only the first letter of the month capitalized
                                const fullMonths = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                                let label = fullMonths[month].charAt(0);
                                
                                // If this is the first month of a year in our dataset, add year below
                                if (index === 0 || formattedDates[index - 1].getFullYear() !== year) {
                                    label += `<br>${year}`;
                                } else {
                                    // Add empty line to maintain vertical spacing
                                    label += "<br> ";
                                }
                                
                                return label;
                            }
                        }),
                        tickangle: 0, // Keep tick labels horizontal
                        // Add a secondary axis below for the years
                        dividercolor: 'transparent',
                        dividerwidth: 0,
                        ticklen: 3, // Reduced from 4
                        tickcolor: '#222222', // Match font color
                        // Ensure all months are displayed with padding on both sides
                        range: [
                            // Start with the first month in the data with 20 days padding before (reduced from 30)
                            new Date(formattedDates[0].getTime() - 20 * 24 * 60 * 60 * 1000),
                            // End with the last month in the data with 20 days padding after (reduced from 30)
                            new Date(formattedDates[formattedDates.length - 1].getTime() + 20 * 24 * 60 * 60 * 1000)
                        ],
                        showline: true,
                        linecolor: '#e5e7eb',
                        linewidth: 1,
                        // Create space between month and year labels
                        tickpadding: 10 // Reduced from 15
                    },
                    yaxis: {
                        title: {
                            text: '',
                            font: { 
                                family: 'IBM Plex Sans, Arial, sans-serif',
                                size: 10, // Reduced from 12
                                color: '#222222' // Ink Black
                            },
                            standoff: 15 // Added standoff to move label away from axis
                        },
                        showgrid: true,
                        gridcolor: 'rgba(232, 233, 235, 0.5)', // Cloud Gray with transparency
                        zeroline: false,
                        rangemode: 'tozero',
                        tickfont: { 
                            family: 'IBM Plex Sans, Arial, sans-serif',
                            size: 9, // Reduced from 10
                            color: '#222222' // Ink Black
                        }
                    },
                    showlegend: true,
                    legend: {
                        orientation: 'h',
                        x: 0.5,
                        y: -0.10, // Moved legend up
                        xanchor: 'center',
                        yanchor: 'top',
                        font: { 
                            family: 'IBM Plex Sans, Arial, sans-serif',
                            size: 9, // Reduced from 10
                            color: '#222222' // Ink Black
                        },
                        bgcolor: 'rgba(246, 241, 234, 0.7)' // Soft Sand with transparency
                    },
                    margin: { t: 55, b: 100, l: 50, r: 30 }, // Increased top margin for subtitle space
                    height: null, // Remove fixed height
                    width: null, // Remove fixed width
                    autosize: true, // Enable autosize
                    paper_bgcolor: 'transparent', // Will be set by theme
                    plot_bgcolor: 'transparent', // Will be set by theme
                    hovermode: 'closest',
                    dragmode: fullView ? 'zoom' : false, // Enable drag zoom only in full view mode
                    responsive: true, // Ensure the chart is responsive
                    hoverlabel: {
                        bgcolor: '#F6F1EA', // Soft Sand
                        bordercolor: '#4A7463', // Spruce Green
                        font: { 
                            family: 'IBM Plex Sans, Arial, sans-serif',
                            size: 9, // Reduced from 10
                            color: '#222222' // Ink Black
                        }
                    },
                    // Add a second x-axis for years
                    xaxis2: {
                        showgrid: false,
                        zeroline: false,
                        showticklabels: !isYearlyData, // Hide tick labels for yearly data
                        type: 'date',
                        tickmode: 'array',
                        tickvals: yearDates,
                        ticktext: xAxisYearLabels,
                        position: 0.95, // Position year labels much lower
                        anchor: 'free',
                        showline: false,
                        tickfont: {
                            size: 10, // Reduced from 12
                        },
                        side: 'bottom',
                        overlaying: 'x'
                    }
                };
            }
            
            // Add annotation for the most recent data point
            let formattedDate;
            
            if (isYtdTrendChart) {
                // For YTD trend charts, get the latest data point from the actual data
                const latestDataPoint = timeSeriesData[timeSeriesData.length - 1];
                lastDate = new Date(latestDataPoint.time_period);
                lastValue = latestDataPoint.numeric_value;
                
                // Format as day of year
                const startOfYear = new Date(lastDate.getFullYear(), 0, 1);
                const dayOfYear = Math.floor((lastDate - startOfYear) / (1000 * 60 * 60 * 24)) + 1;
                formattedDate = `Day ${dayOfYear}`;
            } else {
                // For regular charts, lastDate is a Date object
                lastDate = formattedDates[formattedDates.length - 1];
                lastValue = values[values.length - 1];
                
                const month = lastDate.getMonth();
                const year = lastDate.getFullYear();
                const day = lastDate.getDate();
                const fullMonths = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                
                if (isYearlyData) {
                    formattedDate = `${year}`;
                } else if (isWeeklyData) {
                    formattedDate = `${fullMonths[month]} ${day}, ${year}`;
                } else {
                    formattedDate = `${fullMonths[month]} ${year}`;
                }
            }
            
            // Removed the last datapoint annotation - no more label on last datapoint
            
            // Add filter conditions as an annotation if available
            if (metadata.filter_conditions) {
                // Format the filter conditions properly
                let filterText = '';
                
                // Check if filter_conditions is an array
                if (Array.isArray(metadata.filter_conditions)) {
                    // Format each filter condition in the array
                    filterText = metadata.filter_conditions.map(filter => {
                        // Format each filter condition
                        let conditionText = '';
                        
                        if (filter.field) {
                            conditionText += filter.field;
                        }
                        
                        if (filter.operator) {
                            conditionText += ` ${filter.operator} `;
                        }
                        
                        if (filter.value) {
                            // Format date values if needed
                            if (filter.is_date && typeof filter.value === 'string') {
                                // Try to format the date nicely
                                try {
                                    const dateParts = filter.value.split('-');
                                    if (dateParts.length >= 2) {
                                        const year = dateParts[0];
                                        const month = parseInt(dateParts[1]);
                                        const months = ['January', 'February', 'March', 'April', 'May', 'June', 
                                                      'July', 'August', 'September', 'October', 'November', 'December'];
                                        conditionText += `${months[month-1]} ${year}`;
                                    } else {
                                        conditionText += filter.value;
                                    }
                                } catch (e) {
                                    conditionText += filter.value;
                                }
                            } else {
                                conditionText += filter.value;
                            }
                        }
                        
                        return conditionText;
                    }).join(' AND ');
                } else if (typeof metadata.filter_conditions === 'string') {
                    filterText = metadata.filter_conditions;
                } else if (typeof metadata.filter_conditions === 'object') {
                    // If it's an object, convert it to a readable string
                    try {
                        // Try to parse if it's a JSON string
                        if (typeof metadata.filter_conditions === 'string') {
                            const parsedFilters = JSON.parse(metadata.filter_conditions);
                            filterText = Object.entries(parsedFilters)
                                .map(([key, value]) => `${key}: ${value}`)
                                .join(', ');
                        } else {
                            // If it's already an object
                            filterText = Object.entries(metadata.filter_conditions)
                                .map(([key, value]) => `${key}: ${value}`)
                                .join(', ');
                        }
                    } catch (e) {
                        // If parsing fails, use a fallback
                        filterText = JSON.stringify(metadata.filter_conditions);
                    }
                }
                
                // This will be pushed as annotations[1] (or later if more are added)
                layout.annotations.push({
                    text: `<b>Filters:</b> ${filterText}`,
                    font: { 
                        family: 'IBM Plex Sans, Arial, sans-serif',
                        size: 7, // Decreased font size from 8 to 7
                        color: '#999999' // Lighter grey color
                    },
                    showarrow: false,
                    x: 0.5,
                    y: -0.22, // Positioned at the bottom of the chart image
                    xref: 'paper',
                    yref: 'paper',
                    align: 'center',
                    yanchor: 'bottom', // Anchor to the bottom of the text
                    html: true // Enable HTML formatting
                });
            }
            
            // Attribution logic
            const chartContainer = document.getElementById('chart-section');
            // Remove any existing attribution elements
            const oldAttributions = chartContainer.querySelectorAll('.chart-attribution, a[href*="datasf"], span[data-source-note]');
            oldAttributions.forEach(el => el.remove());

            // Create consolidated attribution line at bottom of chart
            // Only show in embedded mode (not full view mode)
            if (!fullView) {
                const attributionContainer = document.createElement('div');
                attributionContainer.style.position = 'absolute';
                attributionContainer.style.bottom = '5px';
                attributionContainer.style.left = '10px';
                attributionContainer.style.right = '10px';
                attributionContainer.style.zIndex = '1000';
                attributionContainer.style.fontSize = '10px';
                attributionContainer.style.color = '#999999';
                // Set attribution background based on current theme
                const currentTheme = document.documentElement.getAttribute('data-theme') || 'light';
                attributionContainer.style.backgroundColor = currentTheme === 'dark' ? 'rgba(26, 26, 26, 0.9)' : 'rgba(255, 255, 255, 0.9)';
                attributionContainer.style.padding = '3px 8px';
                attributionContainer.style.borderRadius = '4px';
                attributionContainer.style.display = 'flex';
                attributionContainer.style.justifyContent = 'space-between';
                attributionContainer.style.alignItems = 'center';
                attributionContainer.style.fontFamily = 'Arial, sans-serif';
                attributionContainer.className = 'chart-attribution';
                
                // Left side: Chart attribution and source
                const leftSide = document.createElement('div');
                leftSide.style.display = 'flex';
                leftSide.style.alignItems = 'center';
                leftSide.style.gap = '8px';
                
                // Chart attribution
                const chartAttribution = document.createElement('span');
                chartAttribution.textContent = 'Chart: TransparentSF';
                leftSide.appendChild(chartAttribution);
                
                // Source attribution
                if (metadata['source-name'] && metadata['executed_query_url']) {
                    const sourceLink = document.createElement('a');
                    sourceLink.href = metadata['executed_query_url'];
                    sourceLink.target = '_blank';
                    sourceLink.style.color = '#999999';
                    sourceLink.style.textDecoration = 'none';
                    sourceLink.innerHTML = `Source: ${metadata['source-name']} <i class="fas fa-external-link-alt" style="font-size: 8px;"></i>`;
                    leftSide.appendChild(sourceLink);
                } else if (metadata['source-name']) {
                    const sourceText = document.createElement('span');
                    sourceText.textContent = `Source: ${metadata['source-name']}`;
                    leftSide.appendChild(sourceText);
                }
                
                // Right side: Share and Full View links
                const rightSide = document.createElement('div');
                rightSide.style.display = 'flex';
                rightSide.style.alignItems = 'center';
                rightSide.style.gap = '8px';
                
                // Share link
                const shareLink = document.createElement('a');
                shareLink.href = '#';
                shareLink.style.color = '#999999';
                shareLink.style.textDecoration = 'none';
                shareLink.style.cursor = 'pointer';
                shareLink.innerHTML = '<i class="fas fa-share-alt" style="font-size: 8px;"></i> Share';
                shareLink.onclick = function(e) {
                    e.preventDefault();
                    const fullUrl = window.location.href.split('#')[0];
                    const originalText = shareLink.innerHTML;
                    
                    if (navigator.share) {
                        navigator.share({
                            title: 'TransparentSF Chart',
                            text: 'Check out this chart from TransparentSF',
                            url: fullUrl
                        }).catch(err => {
                            console.error('Error sharing:', err);
                            // Show visual feedback for copy fallback
                            const tryClipboardCopy = () => {
                                if (navigator.clipboard && navigator.clipboard.writeText) {
                                    return navigator.clipboard.writeText(fullUrl);
                                } else {
                                    // Fallback for older browsers or insecure contexts
                                    return new Promise((resolve, reject) => {
                                        const textArea = document.createElement('textarea');
                                        textArea.value = fullUrl;
                                        textArea.style.position = 'fixed';
                                        textArea.style.left = '-999999px';
                                        textArea.style.top = '-999999px';
                                        document.body.appendChild(textArea);
                                        textArea.focus();
                                        textArea.select();
                                        try {
                                            const result = document.execCommand('copy');
                                            document.body.removeChild(textArea);
                                            if (result) {
                                                resolve();
                                            } else {
                                                reject(new Error('execCommand failed'));
                                            }
                                        } catch (err) {
                                            document.body.removeChild(textArea);
                                            reject(err);
                                        }
                                    });
                                }
                            };
                            
                            tryClipboardCopy().then(() => {
                                shareLink.innerHTML = '<i class="fas fa-check" style="font-size: 8px;"></i> Copied!';
                                const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                                shareLink.style.color = isDark ? '#81C784' : '#4CAF50'; // Light green for dark mode, regular green for light
                                setTimeout(() => {
                                    shareLink.innerHTML = originalText;
                                    shareLink.style.color = '#999999';
                                }, 2000);
                            }).catch(copyErr => {
                                console.error('Failed to copy:', copyErr);
                                // Show the URL in a prompt as final fallback
                                shareLink.innerHTML = '<i class="fas fa-link" style="font-size: 8px;"></i> Copy URL';
                                const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                                shareLink.style.color = isDark ? '#90CAF9' : '#2196F3'; // Blue color to indicate action needed
                                
                                // Add click handler to show URL in prompt
                                const showUrlHandler = function() {
                                    prompt('Copy this URL:', fullUrl);
                                    shareLink.innerHTML = originalText;
                                    shareLink.style.color = '#999999';
                                    shareLink.removeEventListener('click', showUrlHandler);
                                };
                                shareLink.addEventListener('click', showUrlHandler);
                                
                                setTimeout(() => {
                                    shareLink.innerHTML = originalText;
                                    shareLink.style.color = '#999999';
                                    shareLink.removeEventListener('click', showUrlHandler);
                                }, 10000); // Give more time for manual copy
                            });
                        });
                    } else {
                        // Show visual feedback for copy
                        const tryClipboardCopy = () => {
                            if (navigator.clipboard && navigator.clipboard.writeText) {
                                return navigator.clipboard.writeText(fullUrl);
                            } else {
                                // Fallback for older browsers or insecure contexts
                                return new Promise((resolve, reject) => {
                                    const textArea = document.createElement('textarea');
                                    textArea.value = fullUrl;
                                    textArea.style.position = 'fixed';
                                    textArea.style.left = '-999999px';
                                    textArea.style.top = '-999999px';
                                    document.body.appendChild(textArea);
                                    textArea.focus();
                                    textArea.select();
                                    try {
                                        const result = document.execCommand('copy');
                                        document.body.removeChild(textArea);
                                        if (result) {
                                            resolve();
                                        } else {
                                            reject(new Error('execCommand failed'));
                                        }
                                    } catch (err) {
                                        document.body.removeChild(textArea);
                                        reject(err);
                                    }
                                });
                            }
                        };
                        
                        tryClipboardCopy().then(() => {
                            shareLink.innerHTML = '<i class="fas fa-check" style="font-size: 8px;"></i> Copied!';
                            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                            shareLink.style.color = isDark ? '#81C784' : '#4CAF50'; // Light green for dark mode, regular green for light
                            setTimeout(() => {
                                shareLink.innerHTML = originalText;
                                shareLink.style.color = '#999999';
                            }, 2000);
                        }).catch(err => {
                            console.error('Failed to copy:', err);
                            // Show the URL in a prompt as final fallback
                            shareLink.innerHTML = '<i class="fas fa-link" style="font-size: 8px;"></i> Copy URL';
                            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
                            shareLink.style.color = isDark ? '#90CAF9' : '#2196F3'; // Blue color to indicate action needed
                            
                            // Add click handler to show URL in prompt
                            const showUrlHandler = function() {
                                prompt('Copy this URL:', fullUrl);
                                shareLink.innerHTML = originalText;
                                shareLink.style.color = '#999999';
                                shareLink.removeEventListener('click', showUrlHandler);
                            };
                            shareLink.addEventListener('click', showUrlHandler);
                            
                            setTimeout(() => {
                                shareLink.innerHTML = originalText;
                                shareLink.style.color = '#999999';
                                shareLink.removeEventListener('click', showUrlHandler);
                            }, 10000); // Give more time for manual copy
                        });
                    }
                };
                rightSide.appendChild(shareLink);
                
                // Full View link
                const fullViewLink = document.createElement('a');
                fullViewLink.href = '#';
                fullViewLink.style.color = '#999999';
                fullViewLink.style.textDecoration = 'none';
                fullViewLink.style.cursor = 'pointer';
                fullViewLink.innerHTML = '<i class="fas fa-expand" style="font-size: 8px;"></i> Full View';
                fullViewLink.onclick = function(e) {
                    e.preventDefault();
                    const baseUrl = window.location.href.split('#')[0];
                    const currentUrl = new URL(baseUrl);
                    currentUrl.searchParams.set('full_view', 'true');
                    window.open(currentUrl.toString(), '_blank');
                };
                rightSide.appendChild(fullViewLink);
                
                // Assemble the attribution container
                attributionContainer.appendChild(leftSide);
                attributionContainer.appendChild(rightSide);
                chartContainer.appendChild(attributionContainer);
            }
            

            
            const config = {
                responsive: true,
                displayModeBar: fullView, // Show modebar only in full view mode
                scrollZoom: fullView, // Enable scroll zoom only in full view mode
                doubleClick: fullView ? 'reset' : false, // Enable double-click reset only in full view mode
                modeBarButtonsToRemove: fullView ? [] : ['toImage', 'pan2d', 'zoom2d', 'zoomIn2d', 'zoomOut2d', 'autoScale2d', 'resetScale2d', 'hoverClosestCartesian', 'hoverCompareCartesian', 'lasso2d', 'select2d'], // Remove all buttons except in full view
                toImageButtonOptions: {
                    format: 'png',
                    filename: 'time_series_chart',
                    height: 480,
                    width: 600,
                    scale: 1
                }
            };
            
            // Add responsive resize handler to update layout on window resize
            function resizePlot() {
                const plotElement = document.getElementById('time-series-plot');
                if (!plotElement) return;
                
                // Get the current dimensions
                const chartWidth = plotElement.clientWidth;
                const chartHeight = plotElement.clientHeight;
                
                // Adjust title font size based on chart width (subtitle is part of title)
                let update = {
                    'title.font.size': Math.max(14, Math.min(20, chartWidth / 25)), // Adjusted for larger base size
                    'legend.font.size': Math.max(7, Math.min(9, chartWidth / 50))
                };
                
                // For very small screens, adjust vertical positioning and margins
                if (chartWidth < 400) {
                    update['title.y'] = 0.98;
                    update['legend.y'] = -0.12;        // Move legend up more for shorter charts
                    update['margin.b'] = 80;          // Increase bottom margin for x-axis labels
                    update['margin.t'] = 50;          // Maintain space for subtitle
                    update['margin.l'] = 45;          // Reduce left margin
                    update['margin.r'] = 25;          // Reduce right margin
                }
                
                // For extremely small windows (like 437x437)
                if (chartWidth < 300) {
                    update['title.font.size'] = Math.max(12, chartWidth / 30);
                    update['legend.font.size'] = Math.max(6, chartWidth / 60);
                    update['margin.b'] = 70;
                    update['margin.t'] = 45;
                    update['margin.l'] = 40;
                    update['margin.r'] = 20;
                }
                
                // Apply the updates
                Plotly.relayout(plotElement, update);
            }

            // Update plot dimensions when the window is resized
            window.addEventListener('resize', () => {
                const plotElement = document.getElementById('time-series-plot');
                if (plotElement) {
                    Plotly.Plots.resize(plotElement);
                    setTimeout(resizePlot, 100); // Apply font sizing after resize
                }
            });
            
            // Function to update the chart aspect ratio and maintain responsive shape
            function updateChartAspectRatio() {
                const chartContainer = document.getElementById('chart-section');
                const timeSeriesChart = document.getElementById('time-series-chart');
                const plotElement = document.getElementById('time-series-plot');
                
                if (!chartContainer || !timeSeriesChart || !plotElement) return;
                
                // For embedded mode (chart-section-mode)
                if (document.body.classList.contains('chart-section-mode')) {
                    // Style container for embedded view
                    chartContainer.style.margin = '0'; // Remove auto centering
                    
                    // Calculate available width based on the actual container's parent or document body
                    let availableWidth;
                    const parentElement = chartContainer.parentElement;
                    const bodyElement = document.body;
                    
                    if (parentElement && parentElement !== bodyElement) {
                        // Use parent container's available width, but always cap at 600px
                        const parentWidth = parentElement.clientWidth || parentElement.offsetWidth;
                        availableWidth = Math.min(parentWidth, 600);
                    } else {
                        // Fallback to viewport width, but always cap at 600px
                        availableWidth = Math.min(window.innerWidth, 600);
                    }
                    
                    // Ensure the chart container itself is also constrained
                    chartContainer.style.maxWidth = '600px';
                    chartContainer.style.width = availableWidth + 'px';
                    
                    // Adjust aspect ratio based on available space
                    let aspectRatio = 0.75; // Default 4:3
                    if (availableWidth < 450 && window.innerHeight < 450) {
                        aspectRatio = 0.65; // More compact for very small windows
                    } else if (window.innerHeight < 500) {
                        aspectRatio = 0.70; // Slightly more compact for small height
                    }
                    
                    const containerHeight = Math.min(window.innerHeight, availableWidth * aspectRatio);
                    
                    chartContainer.style.height = containerHeight + 'px';

                    // Adjust the parent Bootstrap container
                    const bootstrapContainer = chartContainer.closest('.container');
                    if (bootstrapContainer) {
                        bootstrapContainer.style.height = containerHeight + 'px';
                        bootstrapContainer.style.maxWidth = 'none'; // Remove Bootstrap container constraints
                        bootstrapContainer.style.padding = '0'; // Remove Bootstrap container padding
                    }
                } else {
                    // For full view mode - cap width at 600px
                    const availableWidth = Math.min(chartContainer.parentElement.clientWidth, 600); // Cap at 600px
                    const availableHeight = availableWidth * 0.75; // 4:3 aspect ratio
                    
                    chartContainer.style.width = availableWidth + 'px'; // Use calculated width
                    chartContainer.style.height = availableHeight + 'px';
                    chartContainer.style.maxWidth = '600px'; // Cap at 600px
                    chartContainer.style.maxHeight = 'none'; // Remove height constraint
                }
                
                // Make sure the plot fills its container
                if (plotElement) {
                    plotElement.style.width = '100%';
                    plotElement.style.height = '100%';
                    Plotly.Plots.resize(plotElement);
                }
                
                // Update CSS custom properties for framing elements to scale with actual container size
                // This ensures the corner framing scales with the actual container size, not the screen size
                const containerRect = chartContainer.getBoundingClientRect();
                chartContainer.style.setProperty('--container-width', containerRect.width + 'px');
                chartContainer.style.setProperty('--container-height', containerRect.height + 'px');
            }
            
            // Add window resize handler for responsiveness
            window.addEventListener('resize', updateChartAspectRatio);
            
            // Add ResizeObserver to monitor container size changes
            const resizeObserver = new ResizeObserver(() => {
                updateChartAspectRatio();
            });
            
            // Observe the chart container for size changes
            if (chartContainer) {
                resizeObserver.observe(chartContainer);
            }
            
            // Initial call to set aspect ratio
            updateChartAspectRatio();
            
            // Create the plot and maintain responsive sizing
            Plotly.newPlot('time-series-plot', traces, layout, config).then(() => {
                // Set initial dimensions and maintain responsive aspect ratio
                updateChartAspectRatio();
                
                // Apply initial font sizing
                setTimeout(resizePlot, 100);
                
                // Update container dimensions after a short delay to ensure proper calculation
                setTimeout(() => {
                    updateChartAspectRatio();
                }, 200);
                
                // Apply initial theme colors
                applyThemeToPlot(document.documentElement.getAttribute('data-theme') || 'light');
                
                // Add group filter to chart if needed
                if (window.hasGroups && fullView) {
                    addGroupFilterToChart();
                }
            });
            
            // Display metadata after rendering chart
            displayMetadata(data);
        }
        
        // Function to calculate mean
        function calculateMean(values) {
            const sum = values.reduce((acc, val) => acc + val, 0);
            return sum / values.length;
        }
        
        // Function to calculate standard deviation
        function calculateStandardDeviation(values, mean) {
            const squareDiffs = values.map(value => {
                const diff = value - mean;
                return diff * diff;
            });
            
            const avgSquareDiff = calculateMean(squareDiffs);
            return Math.sqrt(avgSquareDiff);
        }
        
        // Function to display metadata
        function displayMetadata(data) {
            // Get metadata fields
            const metadata = data.metadata || {};
            const metricName = metadata.object_name || metadata.field_name || 'Unknown Metric';
            const districtName = metadata.district === 0 ? 'Citywide' : `District ${metadata.district}`;
            
            // Format the date range
            const timeSeriesData = data.data || [];
            if (timeSeriesData.length === 0) {
                metadataEl.innerHTML = '<p>No data available</p>';
                return;
            }
            
            // Check if we have grouped data
            const hasGroups = timeSeriesData.some(item => item.group_value);
            let groupCounts = '';
            
            // Always initialize the groupCounter, even when there are no groups
            const groupCounter = {};
            
            if (hasGroups) {
                // Count items per group
                timeSeriesData.forEach(item => {
                    const groupValue = item.group_value || 'Unknown';
                    groupCounter[groupValue] = (groupCounter[groupValue] || 0) + 1;
                });
                
                // Format group counts
                groupCounts = '<div class="mt-2"><strong>Groups:</strong> ';
                for (const [group, count] of Object.entries(groupCounter)) {
                    groupCounts += `<span class="badge bg-secondary me-1 mb-1">${group} (${count})</span>`;
                }
                groupCounts += '</div>';
            }
            
            const startDate = (() => {
                const dateStr = timeSeriesData[0].time_period;
                if (dateStr.includes('W') && dateStr.includes('-')) {
                    const [yearPart, weekPart] = dateStr.split('-');
                    const year = parseInt(yearPart);
                    const weekNum = parseInt(weekPart.replace('W', ''));
                    const jan1 = new Date(year, 0, 1);
                    const daysUntilMonday = (7 - jan1.getDay()) % 7;
                    const firstMonday = new Date(jan1.getTime() + daysUntilMonday * 24 * 60 * 60 * 1000);
                    return new Date(firstMonday.getTime() + (weekNum - 1) * 7 * 24 * 60 * 60 * 1000);
                } else {
                    return new Date(dateStr);
                }
            })();
            
            const endDate = (() => {
                const dateStr = timeSeriesData[timeSeriesData.length - 1].time_period;
                if (dateStr.includes('W') && dateStr.includes('-')) {
                    const [yearPart, weekPart] = dateStr.split('-');
                    const year = parseInt(yearPart);
                    const weekNum = parseInt(weekPart.replace('W', ''));
                    const jan1 = new Date(year, 0, 1);
                    const daysUntilMonday = (7 - jan1.getDay()) % 7;
                    const firstMonday = new Date(jan1.getTime() + daysUntilMonday * 24 * 60 * 60 * 1000);
                    return new Date(firstMonday.getTime() + (weekNum - 1) * 7 * 24 * 60 * 60 * 1000);
                } else {
                    return new Date(dateStr);
                }
            })();
            
            const formatDate = (date) => {
                const month = date.getMonth();
                const year = date.getFullYear();
                const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                return `${months[month]} ${year}`;
            };
            
            const dateRange = `${formatDate(startDate)} - ${formatDate(endDate)}`;
            
            // Calculate statistics
            const values = timeSeriesData.map(item => item.numeric_value);
            const mean = calculateMean(values);
            const stdDev = calculateStandardDeviation(values, mean);
            const min = Math.min(...values);
            const max = Math.max(...values);
            
            // Create HTML for metadata
            let html = `
                <div class="row">
                    <div class="col-sm-6">
                        <h5 class="fs-6">${metricName}</h5>
                        <p class="mb-1"><strong>District:</strong> ${districtName}</p>
                        <p class="mb-1"><strong>Period:</strong> ${dateRange}</p>
                        ${hasGroups && metadata.group_field ? `<p class="mb-1"><strong>Group Field:</strong> ${metadata.group_field}</p>` : ''}
                    </div>
                    <div class="col-sm-6">
                        <p class="mb-1"><strong>Mean:</strong> ${formatValue(mean)}</p>
                        <p class="mb-1"><strong>Standard Deviation:</strong> ${formatValue(stdDev)}</p>
                        <p class="mb-1"><strong>Range:</strong> ${formatValue(min)} - ${formatValue(max)}</p>
                    </div>
                </div>
            `;
            
            // Set HTML
            metadataEl.innerHTML = html;
            
            // If groups are present and full view is enabled, add filter to chart
            if (hasGroups && fullView) {
                // We'll add the filter to the chart after it's rendered
                window.hasGroups = true;
                window.groupCounter = groupCounter;
                window.uniqueGroups = Object.keys(groupCounter);
            }
        }
        
        // Function to select all groups
        function selectAllGroups() {
            document.querySelectorAll('.group-checkbox').forEach(checkbox => {
                checkbox.checked = true;
            });
            updateSelectedCount();
            updateChartWithCurrentFilters();
        }
        
        // Function to uncheck all groups
        function uncheckAllGroups() {
            document.querySelectorAll('.group-checkbox').forEach(checkbox => {
                checkbox.checked = false;
            });
            updateSelectedCount();
            updateChartWithCurrentFilters();
        }
        
        // Function to update the selected count display
        function updateSelectedCount() {
            const checkboxes = document.querySelectorAll('.group-checkbox:checked');
            const selectedCount = checkboxes.length;
            const totalCount = document.querySelectorAll('.group-checkbox').length;
            const countElement = document.getElementById('selected-count');
            
            if (countElement) {
                if (selectedCount === totalCount) {
                    countElement.textContent = 'All';
                    countElement.className = 'badge bg-success ms-2';
                } else if (selectedCount === 0) {
                    countElement.textContent = 'None';
                    countElement.className = 'badge bg-warning ms-2';
                } else {
                    countElement.textContent = `${selectedCount}/${totalCount}`;
                    countElement.className = 'badge bg-primary ms-2';
                }
            }
        }
        
        // Function to update chart with current filter selections
        function updateChartWithCurrentFilters() {
            // Show loading state on the update button
            const updateBtn = document.getElementById('apply-group-filter');
            if (updateBtn) {
                const originalText = updateBtn.innerHTML;
                updateBtn.innerHTML = '<i class="fas fa-spinner fa-spin me-1"></i>Updating...';
                updateBtn.disabled = true;
                
                // Also show loading state on the chart container
                const chartContainer = document.getElementById('chart-section');
                if (chartContainer) {
                    chartContainer.style.opacity = '0.7';
                    chartContainer.style.transition = 'opacity 0.3s ease';
                }
                
                // Re-enable button and restore chart opacity after chart update
                setTimeout(() => {
                    updateBtn.innerHTML = originalText;
                    updateBtn.disabled = false;
                    if (chartContainer) {
                        chartContainer.style.opacity = '1';
                    }
                }, 1000);
            }
            
            const checkboxes = document.querySelectorAll('.group-checkbox:checked');
            const selectedGroups = Array.from(checkboxes).map(cb => cb.value);
            
            // Remove any existing warning
            const existingWarning = document.querySelector('.alert-warning');
            if (existingWarning) {
                existingWarning.remove();
            }
            
            // Only show warning if no groups are selected, but don't auto-select all
            if (selectedGroups.length === 0) {
                const warningDiv = document.createElement('div');
                warningDiv.className = 'alert alert-warning alert-dismissible fade show mt-2';
                warningDiv.innerHTML = `
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    No series selected. The chart will be empty. Use "Select All" to show all series.
                    <button type="button" class="btn-close" data-bs-dismiss="alert"></button>
                `;
                
                // Add new warning
                const groupFilterDiv = document.querySelector('#metadata .mt-3');
                if (groupFilterDiv) {
                    groupFilterDiv.appendChild(warningDiv);
                }
            }
            
            // Update URL without page reload
            const urlParams = new URLSearchParams(window.location.search);
            
            // Handle groups parameter - send empty string if no groups selected
            if (selectedGroups.length > 0) {
                urlParams.set('groups', selectedGroups.join(','));
                window.groups = selectedGroups.join(',');
            } else {
                // Send empty string to indicate no groups should be shown
                urlParams.set('groups', '');
                window.groups = '';
            }
            
            // Make sure group_field is also set if not already present
            if (groupField && !urlParams.has('group_field')) {
                urlParams.set('group_field', groupField);
            }
            
            // Update URL without reloading the page
            const newUrl = `${window.location.pathname}?${urlParams.toString()}`;
            window.history.replaceState({}, '', newUrl);
            
            // Re-fetch and render the chart with new filters
            fetchTimeSeriesData();
        }
        
        // Function to apply group filter (now uses automatic updates)
        function applyGroupFilter() {
            updateChartWithCurrentFilters();
        }
        
        // Function to clear group filter (now uses automatic updates)
        function clearGroupFilter() {
            // Check all checkboxes first
            document.querySelectorAll('.group-checkbox').forEach(checkbox => {
                checkbox.checked = true;
            });
            updateSelectedCount();
            updateChartWithCurrentFilters();
        }
        
        // Function to fetch time series data
        async function fetchTimeSeriesData() {
            try {
                // Show loading indicator
                showLoading();
                
                let apiUrl;
                
                // If chart_id is provided, use the direct chart endpoint
                if (chartId) {
                    apiUrl = `/api/chart/${chartId}`;
                    console.log(`Fetching time series data by chart_id with URL: ${apiUrl}`);
                } 
                // Otherwise use the metric-based endpoint (backward compatibility)
                else if (metricId) {
                    // Construct API URL with all parameters
                    apiUrl = `/api/chart-by-metric?metric_id=${metricId}&district=${district}&period_type=${periodType}`;
                    
                    // Add groups parameter if present
                    if (groups !== null && groups !== undefined) {
                        apiUrl += `&groups=${encodeURIComponent(groups)}`;
                    }
                    
                    // Add group_field parameter if present
                    if (groupField) {
                        apiUrl += `&group_field=${encodeURIComponent(groupField)}`;
                    }
                    
                    console.log(`Fetching time series data by metric_id with URL: ${apiUrl}`);
                } else {
                    showError('No chart_id or metric_id provided. Please specify either parameter in the URL.');
                    return;
                }
                
                // Fetch time series data
                const response = await fetch(apiUrl);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch time series data: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                console.log("Received data:", data);
                
                if (data.status === 'error') {
                    throw new Error(data.message || 'Failed to load time series data');
                }
                
                // Render the chart
                renderTimeSeriesChart(data);
                
            } catch (error) {
                console.error('Error fetching time series data:', error);
                hideLoading();
                showError(`Error loading time series data: ${error.message}`);
            }
        }
        
        // Load data when the page loads
        document.addEventListener('DOMContentLoaded', fetchTimeSeriesData);

        // Function to handle chart section visibility - MODIFIED TO USE fullView PARAMETER
        function handleChartSection() {
            const isChartSection = !fullView || window.location.hash === '#chart-section';
            const header = document.querySelector('.header');
            const metadata = document.getElementById('metadata');
            const buttons = document.querySelector('.mt-3');
            const embedModal = document.getElementById('embedModal');
            const datasfLink = document.getElementById('datasf-link');
            const shareBtn = document.getElementById('share-btn');
            const embedBtn = document.getElementById('embed-btn');
            const backButton = document.querySelector('a[href="javascript:history.back()"]');
            
            // Add or remove chart-section-mode class on body
            document.body.classList.toggle('chart-section-mode', isChartSection);
            
            if (isChartSection) {
                // Hide non-chart elements
                if (header) header.style.display = 'none';
                if (metadata) metadata.style.display = 'none';
                if (buttons) buttons.style.display = 'none';
                if (embedModal) embedModal.style.display = 'none';
                if (datasfLink) datasfLink.style.display = 'none';
                if (shareBtn) shareBtn.style.display = 'none';
                if (embedBtn) embedBtn.style.display = 'none';
                if (backButton) backButton.style.display = 'none';
                
                // Set chart container to maintain aspect ratio
                const chartContainer = document.getElementById('chart-section');
                if (chartContainer) {
                    chartContainer.style.margin = '0'; // Remove auto centering
                    chartContainer.style.maxWidth = '600px'; // Cap width at 600px
                    chartContainer.style.width = '100%';
                    chartContainer.style.display = 'flex';
                    chartContainer.style.justifyContent = 'flex-start'; // Left justify instead of center
                    chartContainer.style.alignItems = 'center';
                    

                }
                
                // Hide the chart caption
                const chartCaption = document.querySelector('.chart-caption');
                if (chartCaption) {
                    chartCaption.style.display = 'none';
                }
                
                // Update chart size to fit container
                const plotElement = document.getElementById('time-series-plot');
                if (plotElement) {
                    Plotly.Plots.resize(plotElement);
                }
                
                // Send chart height to parent window
                const sendHeight = () => {
                    const chartElement = document.getElementById('time-series-chart');
                    if (chartElement) {
                        // Calculate height based on the 5:4 aspect ratio
                        const width = chartElement.offsetWidth;
                        const height = width * 0.8; // 480/600 = 0.8
                        window.parent.postMessage({
                            type: 'chartHeight',
                            height: height
                        }, '*'); // Changed from window.location.origin to '*' to allow embedding on different origins
                    }
                };
                
                // Send height initially and after any changes
                sendHeight();
                const observer = new ResizeObserver(sendHeight);
                const chartElement = document.getElementById('time-series-chart');
                if (chartElement) {
                    observer.observe(chartElement);
                }
            } else {
                // Show all elements
                if (header) header.style.display = 'block';
                if (metadata) metadata.style.display = 'block';
                if (buttons) buttons.style.display = 'block';
                if (embedModal) embedModal.style.display = 'block';
                if (datasfLink) datasfLink.style.display = 'block';
                if (shareBtn) shareBtn.style.display = 'block';
                if (embedBtn) embedBtn.style.display = 'block';
                if (backButton) backButton.style.display = 'block';
                

                
                // Show the chart caption
                const chartCaption = document.querySelector('.chart-caption');
                if (chartCaption) {
                    chartCaption.style.display = 'block';
                }
                
                // Reset chart container styles
                const chartContainer = document.getElementById('chart-section');
                if (chartContainer) {
                    chartContainer.style.margin = '';
                    chartContainer.style.maxWidth = '';
                    chartContainer.style.width = '';
                    chartContainer.style.display = '';
                    chartContainer.style.justifyContent = '';
                    chartContainer.style.alignItems = '';
                }
            }
        }

        // Handle initial load and hash changes
        handleChartSection();
        window.addEventListener('hashchange', handleChartSection);

        // Function to copy the current URL to clipboard
        function copyShareLink() {
            const url = window.location.href;
            const shareBtn = document.getElementById('share-btn');
            const originalText = shareBtn.innerHTML;
            
            const tryClipboardCopy = () => {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    return navigator.clipboard.writeText(url);
                } else {
                    // Fallback for older browsers or insecure contexts
                    return new Promise((resolve, reject) => {
                        const textArea = document.createElement('textarea');
                        textArea.value = url;
                        textArea.style.position = 'fixed';
                        textArea.style.left = '-999999px';
                        textArea.style.top = '-999999px';
                        document.body.appendChild(textArea);
                        textArea.focus();
                        textArea.select();
                        try {
                            const result = document.execCommand('copy');
                            document.body.removeChild(textArea);
                            if (result) {
                                resolve();
                            } else {
                                reject(new Error('execCommand failed'));
                            }
                        } catch (err) {
                            document.body.removeChild(textArea);
                            reject(err);
                        }
                    });
                }
            };
            
            tryClipboardCopy().then(() => {
                // Change button text to indicate success
                shareBtn.innerHTML = '<i class="fas fa-check me-1"></i> Copied!';
                shareBtn.classList.remove('btn-outline-success');
                shareBtn.classList.add('btn-success');
                
                // Change back after 2 seconds
                setTimeout(() => {
                    shareBtn.innerHTML = originalText;
                    shareBtn.classList.remove('btn-success');
                    shareBtn.classList.add('btn-outline-success');
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy: ', err);
                // Show URL in prompt as fallback
                const userUrl = prompt('Copy this URL:', url);
                if (userUrl !== null) {
                    // User interacted with the prompt, show temporary feedback
                    shareBtn.innerHTML = '<i class="fas fa-link me-1"></i> URL Shown';
                    shareBtn.classList.remove('btn-outline-success');
                    shareBtn.classList.add('btn-info');
                    
                    setTimeout(() => {
                        shareBtn.innerHTML = originalText;
                        shareBtn.classList.remove('btn-info');
                        shareBtn.classList.add('btn-outline-success');
                    }, 2000);
                }
            });
        }
        
        // Function to show the embed code modal
        function showEmbedCode() {
            // Generate the initial embed code
            updateEmbedCode();
            
            // Show the modal
            const embedModal = document.getElementById('embedModal');
            embedModal.removeAttribute('inert');
            const modal = new bootstrap.Modal(embedModal);
            modal.show();
        }
        
        // Function to update the embed code based on current settings - Modified to preserve chart_id or metric_id
        function updateEmbedCode() {
            const width = document.getElementById('widthInput').value;
            const height = document.getElementById('heightInput').value;
            const isResponsive = document.getElementById('responsiveCheck').checked;
            
            // Construct the URL based on whether we have chart_id or metric_id
            let embedUrl = `${window.location.href.split('#')[0].split('?')[0]}?`;
            
            if (chartId) {
                embedUrl += `chart_id=${chartId}`;
            } else {
                embedUrl += `metric_id=${metricId}&district=${district}&period_type=${periodType}`;
                
                // Add groups parameter if present
                if (groups) {
                    embedUrl += `&groups=${encodeURIComponent(groups)}`;
                }
                
                // Add group_field parameter if present
                if (groupField) {
                    embedUrl += `&group_field=${encodeURIComponent(groupField)}`;
                }
            }
            
            let embedCode = `<iframe src="${embedUrl}"`;
            
            if (isResponsive) {
                embedCode += ` style="width: 100%; height: 100%; border: none;"`;
            } else {
                embedCode += ` width="${width}" height="${height}"`;
            }
            
            embedCode += ` frameborder="0" scrolling="no"></iframe>`;
            
            if (isResponsive) {
                // Use 4:3 aspect ratio (75%) for responsive charts
                embedCode = `<div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;">\n  <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;">\n    ${embedCode}\n  </div>\n</div>`;
            }
            
            document.getElementById('embedCode').value = embedCode;
        }
        
        // Function to copy the embed code to clipboard
        function copyEmbedCode() {
            const embedCodeElement = document.getElementById('embedCode');
            const embedCodeText = embedCodeElement.value;
            const copyBtn = document.querySelector('#embedModal .btn-outline-primary');
            const originalHtml = copyBtn.innerHTML;
            
            const tryClipboardCopy = () => {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    return navigator.clipboard.writeText(embedCodeText);
                } else {
                    // Fallback to execCommand for older browsers
                    return new Promise((resolve, reject) => {
                        try {
                            embedCodeElement.select();
                            const result = document.execCommand('copy');
                            if (result) {
                                resolve();
                            } else {
                                reject(new Error('execCommand failed'));
                            }
                        } catch (err) {
                            reject(err);
                        }
                    });
                }
            };
            
            tryClipboardCopy().then(() => {
                // Show a brief success message
                copyBtn.innerHTML = '<i class="fas fa-check"></i>';
                
                setTimeout(() => {
                    copyBtn.innerHTML = originalHtml;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy embed code:', err);
                // Show URL in prompt as fallback
                prompt('Copy this embed code:', embedCodeText);
                
                // Still show feedback even if copy failed
                copyBtn.innerHTML = '<i class="fas fa-link"></i>';
                setTimeout(() => {
                    copyBtn.innerHTML = originalHtml;
                }, 2000);
            });
        }
        
        // Add event listener to handle modal closing
        document.addEventListener('DOMContentLoaded', function() {
            const embedModal = document.getElementById('embedModal');
            embedModal.addEventListener('hidden.bs.modal', function() {
                embedModal.setAttribute('inert', '');
            });
        });

        // Function to copy text to clipboard
        function copyToClipboard(text) {
            const tryClipboardCopy = () => {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    return navigator.clipboard.writeText(text);
                } else {
                    // Fallback for older browsers or insecure contexts
                    return new Promise((resolve, reject) => {
                        const textArea = document.createElement('textarea');
                        textArea.value = text;
                        textArea.style.position = 'fixed';
                        textArea.style.left = '-999999px';
                        textArea.style.top = '-999999px';
                        document.body.appendChild(textArea);
                        textArea.focus();
                        textArea.select();
                        try {
                            const result = document.execCommand('copy');
                            document.body.removeChild(textArea);
                            if (result) {
                                resolve();
                            } else {
                                reject(new Error('execCommand failed'));
                            }
                        } catch (err) {
                            document.body.removeChild(textArea);
                            reject(err);
                        }
                    });
                }
            };
            
            tryClipboardCopy().then(() => {
                console.log('Copied to clipboard:', text);
            }).catch(err => {
                console.error('Failed to copy: ', err);
                // Show URL in prompt as fallback
                prompt('Copy this text:', text);
            });
        }

        // Function to apply theme colors to Plotly chart
        function applyThemeToPlot(theme) {
            const isDark = theme === 'dark';
            const styles = getComputedStyle(document.documentElement);
            const textColor = styles.getPropertyValue('--text-primary').trim() || (isDark ? '#ffffff' : '#222222');
            const gridColor = isDark ? 'rgba(60,60,60,0.5)' : 'rgba(232, 233, 235, 0.5)';
            const borderColor = styles.getPropertyValue('--border-primary').trim() || gridColor;
            
            // Use fully opaque backgrounds to prevent white bleeding through
            const paperBg = isDark ? '#1a1a1a' : '#ffffff';
            const plotBg = isDark ? '#1a1a1a' : '#ffffff';

            Plotly.relayout('time-series-plot', {
                'font.color': textColor,
                'xaxis.tickfont.color': textColor,
                'xaxis.linecolor': borderColor,
                'yaxis.title.font.color': textColor,
                'yaxis.tickfont.color': textColor,
                'yaxis.gridcolor': gridColor,
                'legend.font.color': textColor,
                'title.font.color': textColor,
                'paper_bgcolor': paperBg,
                'plot_bgcolor': plotBg
            });
        }

        // Listen for dark-mode changes dispatched by DarkModeManager
        window.addEventListener('themeChanged', (e) => {
            if (e && e.detail && e.detail.theme) {
                applyThemeToPlot(e.detail.theme);
                
                // Update attribution container background if it exists
                const attributionContainer = document.querySelector('.chart-attribution');
                if (attributionContainer) {
                    attributionContainer.style.backgroundColor = e.detail.theme === 'dark' ? 'rgba(26, 26, 26, 0.9)' : 'rgba(255, 255, 255, 0.9)';
                }
            }
        });
    </script>

    <!-- Dark Mode JavaScript -->
    <script>
        // Embedded chart dark mode handler - always include for charts
        (function() {
            'use strict';
            
            let currentTheme = null;
            let systemListener = null;
            
            // Function to apply theme
            function applyTheme(theme) {
                if (currentTheme === theme) return;
                
                currentTheme = theme;
                document.documentElement.setAttribute('data-theme', theme);
                
                // Update any toggle buttons if they exist
                const toggles = document.querySelectorAll('.dark-mode-toggle');
                toggles.forEach(toggle => {
                    const icon = toggle.querySelector('.icon');
                    if (icon) {
                        icon.textContent = theme === 'light' ? '🌙' : '☀️';
                    }
                });
                
                // Update logo based on theme
                const logoImages = document.querySelectorAll('#wordmark-logo, img[src*="wordmark.png"]');
                logoImages.forEach(img => {
                    if (theme === 'dark') {
                        img.src = '/static/darkwordmark.png';
                    } else {
                        img.src = '/static/wordmark.png';
                    }
                });
                
                // Dispatch theme change event for chart updates
                window.dispatchEvent(new CustomEvent('themeChanged', { detail: { theme } }));
                
                console.log('Chart dark mode: Applied theme:', theme);
            }
            
            // Get current theme preference
            function getCurrentTheme() {
                // Always check system preference first for charts
                const systemPrefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
                console.log('Chart dark mode: System prefers dark:', systemPrefersDark);
                
                // Check stored preference
                let stored = null;
                try {
                    stored = localStorage.getItem('theme');
                    console.log('Chart dark mode: Stored theme:', stored);
                } catch (e) {
                    console.log('Chart dark mode: localStorage not available');
                }
                
                // For embedded charts, always use system preference unless explicitly overridden
                const isEmbedded = window.location !== window.parent.location;
                if (isEmbedded || !stored) {
                    const theme = systemPrefersDark ? 'dark' : 'light';
                    console.log('Chart dark mode: Using system theme for embedded/new chart:', theme);
                    try {
                        localStorage.setItem('theme', theme);
                    } catch (e) {}
                    return theme;
                }
                
                console.log('Chart dark mode: Using stored theme:', stored);
                return stored;
            }
            
            // Add system theme change listener
            function addSystemListener() {
                if (systemListener || !window.matchMedia) return;
                
                const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
                
                systemListener = function(e) {
                    console.log('Chart dark mode: System theme changed to:', e.matches ? 'dark' : 'light');
                    const newTheme = e.matches ? 'dark' : 'light';
                    
                    if (currentTheme !== newTheme) {
                        applyTheme(newTheme);
                        try {
                            localStorage.setItem('theme', newTheme);
                        } catch (e) {}
                    }
                };
                
                // Add listener with both modern and legacy methods
                if (mediaQuery.addEventListener) {
                    mediaQuery.addEventListener('change', systemListener);
                } else {
                    mediaQuery.addListener(systemListener);
                }
                
                console.log('Chart dark mode: System theme listener added');
            }
            
            // Initialize dark mode
            function initDarkMode() {
                console.log('Chart dark mode: Initializing...');
                
                // Apply current theme
                const theme = getCurrentTheme();
                applyTheme(theme);
                
                // Add system listener
                addSystemListener();
                
                console.log('Chart dark mode: Initialization complete with theme:', theme);
            }
            
            // Initialize when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initDarkMode);
            } else {
                initDarkMode();
            }
            
        })();
    </script>
    
    <!-- Load main dark mode script only for non-embedded contexts -->
    <script>
        if (window.location === window.parent.location) {
            // Not in iframe, load main dark mode script
            const script = document.createElement('script');
            script.src = '/static/js/darkmode.js';
            document.head.appendChild(script);
        }
    </script>
</body>
</html> 