<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dashboard Metric Control</title>
    <!-- Dark Mode CSS -->
    <link rel="stylesheet" href="/static/css/darkmode.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-tertiary: #ffffff;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border-primary: #e9ecef;
            --border-secondary: #dee2e6;
            --accent-color: #ad35fa;
            --accent-hover: #9625e0;
        }

        [data-theme="dark"] {
            --bg-primary: #121212;
            --bg-secondary: #1e1e1e;
            --bg-tertiary: #2a2a2a;
            --text-primary: #ffffff;
            --text-secondary: #cccccc;
            --border-primary: #2a2a2a;
            --border-secondary: #404040;
            --accent-color: #c44dff;
            --accent-hover: #ad35fa;
        }

        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            color: var(--text-primary);
            background-color: var(--bg-primary);
            transition: background-color 0.3s ease, color 0.3s ease;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: flex-end;
        }
        .metric-management-row {
            margin-bottom: 20px;
            padding: 15px;
            background-color: var(--bg-secondary);
            border-radius: 4px;
            border: 1px solid var(--border-primary);
        }
        .metric-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .form-group {
            flex: 1;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--text-primary);
        }
        select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-secondary);
            border-radius: 4px;
            font-size: 16px;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }
        .output-windows {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .output-window {
            border: none;
            border-radius: 4px;
            padding: 15px 0;
            background-color: var(--bg-primary);
            margin-bottom: 30px;
        }
        .output-window h3 {
            margin-top: 0;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-primary);
            padding-bottom: 10px;
        }
        .output-content {
            white-space: pre-wrap;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 14px;
            max-height: 400px;
            overflow-y: auto;
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .tool-call {
            background-color: var(--bg-secondary);
            border: 1px solid var(--border-secondary);
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .tool-response {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-secondary);
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .output-content.markdown {
            padding: 15px;
        }
        .output-content.markdown h1 {
            font-size: 24px;
            margin-bottom: 20px;
            color: var(--text-primary);
        }
        .output-content.markdown h2 {
            font-size: 20px;
            margin: 15px 0;
            color: var(--text-primary);
        }
        .output-content.markdown h3 {
            font-size: 18px;
            margin: 12px 0;
            color: var(--text-primary);
        }
        .output-content.markdown p {
            margin: 10px 0;
            color: var(--text-primary);
        }
        .output-content.markdown code {
            background-color: var(--bg-secondary);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
            color: var(--text-primary);
        }
        .output-content.markdown pre {
            background-color: var(--bg-secondary);
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            color: var(--text-primary);
        }
        .output-content.markdown table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }
        .output-content.markdown th,
        .output-content.markdown td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .output-content.markdown th {
            background-color: #f8f9fa;
        }
        .output-content.markdown tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        .output-content.markdown blockquote {
            border-left: 4px solid #ddd;
            margin: 15px 0;
            padding-left: 15px;
            color: #666;
        }
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 16px;
        }
        .btn-primary {
            background-color: var(--accent-color);
            color: white;
        }
        .btn-primary:hover {
            background-color: var(--accent-hover);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(173, 53, 250, 0.3);
        }
        .btn-primary:active {
            transform: translateY(0);
        }
        .btn-secondary {
            background-color: transparent;
            color: var(--accent-color);
            border: 2px solid var(--accent-color);
        }
        .btn-secondary:hover {
            background-color: var(--accent-color);
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(173, 53, 250, 0.3);
        }
        .btn-secondary:active {
            transform: translateY(0);
        }
        .btn-subtle {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-secondary);
        }
        .btn-subtle:hover {
            background-color: var(--bg-secondary);
            border-color: var(--border-primary);
        }
        .btn-subtle:disabled {
            background-color: var(--bg-secondary);
            color: var(--text-secondary);
            border-color: var(--border-primary);
            cursor: not-allowed;
            opacity: 0.6;
        }
        .btn-subtle:hover:not(:disabled) {
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #ad35fa;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Add styles for column selection */
        .column-selection {
            margin: 20px 0;
            padding: 15px;
            background-color: var(--bg-secondary);
            border-radius: 4px;
            border: 1px solid var(--border-secondary);
        }
        .column-selection h3 {
            margin-top: 0;
            color: var(--text-primary);
            border-bottom: 1px solid var(--border-secondary);
            padding-bottom: 10px;
        }
        .column-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .column-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background-color: var(--bg-primary);
            border: 1px solid var(--border-secondary);
            border-radius: 4px;
        }
        .column-item input[type="checkbox"] {
            margin-right: 8px;
        }
        .column-item label {
            font-size: 14px;
            color: var(--text-primary);
            cursor: pointer;
        }
        .column-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background-color: #c82333;
        }
        .status-container {
            margin-top: 10px;
            display: none;
        }
        .progress-container {
            margin-top: 10px;
            background-color: var(--bg-secondary);
            border-radius: 4px;
            padding: 10px;
            border: 1px solid var(--border-secondary);
        }
        .progress-bar {
            height: 20px;
            background-color: var(--bg-tertiary);
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        .progress-bar-fill {
            height: 100%;
            background-color: var(--accent-color);
            width: 0%;
            transition: width 0.3s ease;
        }
        .progress-status {
            font-size: 14px;
            color: var(--text-primary);
            margin-bottom: 5px;
        }
        .progress-details {
            font-size: 12px;
            color: var(--text-secondary);
            max-height: 100px;
            overflow-y: auto;
            background-color: var(--bg-tertiary);
            padding: 8px;
            border-radius: 4px;
            margin-top: 5px;
        }
        .btn-with-spinner {
            position: relative;
        }
        .btn-spinner {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
            display: none;
        }
        .btn-with-spinner.loading .btn-spinner {
            display: block;
        }
        .btn-with-spinner.loading {
            padding-right: 40px;
        }
        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
            border-bottom: 1px solid #e9ecef;
        }
        .log-entry:last-child {
            border-bottom: none;
        }
        .log-time {
            color: #6c757d;
            font-size: 11px;
            margin-right: 5px;
        }
        .log-info {
            color: #0c5460;
        }
        .log-warning {
            color: #856404;
        }
        .log-error {
            color: #721c24;
        }
        .log-success {
            color: #155724;
        }
        /* Add styles for the metric definition modal */
        .metric-definition-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
        }
        .metric-definition-content {
            background-color: var(--bg-primary);
            margin: 5% auto;
            padding: 20px;
            border: 1px solid var(--border-primary);
            width: 80%;
            max-width: 800px;
            border-radius: 8px;
            position: relative;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .close-modal-btn {
            position: absolute;
            right: 20px;
            top: 20px;
            font-size: 24px;
            font-weight: bold;
            color: var(--text-secondary);
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            line-height: 1;
        }
        
        .close-modal-btn:hover {
            color: #000;
        }
        
        .metric-form-group {
            margin-bottom: 20px;
        }
        .metric-form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: var(--text-primary);
        }
        .metric-form-group input[type="text"],
        .metric-form-group textarea,
        .metric-form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-secondary);
            border-radius: 4px;
            font-size: 14px;
            background-color: var(--bg-secondary);
            color: var(--text-primary);
        }
        .metric-form-group textarea {
            min-height: 100px;
            resize: vertical;
        }
        .metric-form-group .field-list {
            margin-top: 10px;
        }
        .metric-form-group .field-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        .metric-form-group .field-item input {
            flex: 1;
        }
        .metric-form-group .field-item button {
            padding: 4px 8px;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .metric-form-group .add-field-btn {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        .metric-form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-secondary);
        }
        .metric-form-actions button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }
        .metric-form-actions .save-btn {
            background-color: var(--accent-color);
            color: white;
        }
        .metric-form-actions .cancel-btn {
            background-color: var(--text-secondary);
            color: white;
        }
        .charts-scrollable-container {
            overflow-x: auto;
            padding: 15px 0;
            margin: 20px 0;
        }
        .charts-row {
            display: flex;
            gap: 20px;
        }
        .loading-charts {
            text-align: center;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            flex: 1;
        }
        .chart-card {
            background-color: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            /* Let the card expand to fit the full height of its contents */
            height: auto;
            display: flex;
            flex-direction: column;
        }
        
        .chart-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }
        
        .chart-card-header {
            background-color: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .chart-card-header h4 {
            margin: 0;
            font-size: 14px;
            font-weight: 600;
            color: #495057;
        }
        
        .chart-card-body {
            flex: 1;
            position: relative;
            /* Ensure the full chart is visible */
            overflow: visible;
        }
        
        .chart-card-body iframe {
            width: 100%;
            /* Allow iframe to size itself naturally */
            height: auto;
            border: none;
        }
        .chart-card-footer {
            padding: 10px;
            border-top: 1px solid #eee;
            background-color: #f8f9fa;
            text-align: center;
        }
        .chart-dw-btn {
            background-color: #ad35fa;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background-color 0.3s ease;
            position: relative;
        }
        .chart-dw-btn:hover {
            background-color: #9625e0;
        }
        .chart-dw-btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .chart-dw-btn.loading {
            padding-right: 30px;
        }
        .chart-dw-btn .btn-spinner {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
            display: none;
        }
        .chart-dw-btn.loading .btn-spinner {
            display: block;
        }
        .no-charts-message {
            text-align: center;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 4px;
            width: 100%;
        }
        
        /* Anomaly card specific styles */
        .chart-card.anomaly-positive {
            border-left: 4px solid #28a745;
        }
        
        .chart-card.anomaly-negative {
            border-left: 4px solid #dc3545;
        }
        
        .chart-card.anomaly-positive .chart-card-header {
            background-color: #d4edda;
            border-bottom-color: #c3e6cb;
        }
        
        .chart-card.anomaly-negative .chart-card-header {
            background-color: #f8d7da;
            border-bottom-color: #f5c6cb;
        }
        
        .anomaly-info {
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
            line-height: 1.4;
        }
        
        .anomaly-percent-change {
            font-weight: bold;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 5px;
        }
        
        .anomaly-percent-change.positive {
            background-color: #d4edda;
            color: #155724;
        }
        
        .anomaly-percent-change.negative {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        /* Anomaly summary styles */
        .anomaly-summary {
            grid-column: 1 / -1;
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        
        .anomaly-summary h3 {
            margin: 0 0 10px 0;
            color: #495057;
            font-size: 18px;
            font-weight: 600;
        }
        
        .anomaly-summary-stats {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .anomaly-stat {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        .anomaly-stat-label {
            font-weight: bold;
            font-size: 14px;
        }
        
        .anomaly-stat-count {
            padding: 2px 8px;
            border-radius: 12px;
            font-weight: bold;
            font-size: 14px;
        }
        
        .anomaly-stat-count.positive {
            background-color: #d4edda;
            color: #155724;
        }
        
        .anomaly-stat-count.negative {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .anomaly-stat-count.total {
            background-color: #e9ecef;
            color: #495057;
        }
        
        .anomaly-stat-description {
            color: #6c757d;
            font-size: 14px;
        }
        
        /* Responsive design for anomaly summary */
        @media (max-width: 768px) {
            .anomaly-summary-stats {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }
            
            .anomaly-stat {
                width: 100%;
                justify-content: space-between;
            }
            
            .anomaly-summary h3 {
                font-size: 16px;
            }
        }
       
        .btn-subtle-primary {
            background-color: #6c757d;
            color: white;
            border: 1px solid #6c757d;
        }
        .btn-subtle-primary:hover {
            background-color: #5a6268;
            border-color: #545b62;
        }
        .btn-subtle-danger {
            background-color: #6c757d;
            color: white;
            border: 1px solid #6c757d;
        }
        .btn-subtle-danger:hover {
            background-color: #dc3545;
            border-color: #dc3545;
        }
        .btn-subtle-danger:disabled {
            background-color: #e9ecef;
            color: #6c757d;
            border-color: #dee2e6;
            cursor: not-allowed;
        }
        .btn-warning {
            background-color: #ffc107;
            color: #212529;
            border: 1px solid #ffc107;
        }
        .btn-warning:hover {
            background-color: #e0a800;
            border-color: #d39e00;
        }
        .btn-warning:disabled {
            background-color: #e9ecef;
            color: #6c757d;
            border-color: #dee2e6;
            cursor: not-allowed;
        }
        
        
        /* Chart tabs styles */
        .chart-tabs {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .chart-tab-buttons {
            display: flex;
            border-bottom: 1px solid #ddd;
            background-color: #f8f9fa;
        }
        
        .chart-tab-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            background-color: transparent;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.3s ease;
        }
        
        .chart-tab-btn:hover {
            background-color: #e9ecef;
            color: #495057;
        }
        
        .chart-tab-btn.active {
            background-color: #ad35fa;
            color: white;
            border-bottom: 2px solid #ad35fa;
        }
        
        .chart-tab-content {
            flex: 1;
            position: relative;
        }
        
        .chart-tab-pane {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }
        
        .chart-tab-pane.active {
            display: block;
        }
        
        .chart-tab-pane iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        /* Add styles for metric reordering modal */
        .metric-reorder-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
        }
        
        .metric-reorder-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
            position: relative;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .reorder-list {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }
        
        .reorder-item {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: grab;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .reorder-item:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
        }
        
        .reorder-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .reorder-item-info {
            flex: 1;
        }
        
        .reorder-item-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .reorder-item-details {
            font-size: 12px;
            color: #6c757d;
        }
        
        .reorder-item-controls {
            display: flex;
            gap: 5px;
        }
        
        .reorder-btn {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 5px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .reorder-btn:hover {
            background-color: #5a6268;
        }
        
        .reorder-btn:disabled {
            background-color: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
        }
        
        .reorder-category-header {
            background-color: var(--accent-color);
            color: white;
            padding: 10px 15px;
            margin: 15px 0 10px 0;
            border-radius: 4px;
            font-weight: bold;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .reorder-item.active {
            border-left: 4px solid #28a745;
        }
        
        .reorder-item.inactive {
            border-left: 4px solid #6c757d;
            opacity: 0.7;
        }
        
        .metric-status {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 3px;
            margin-left: 8px;
        }
        
        .metric-status.active {
            background-color: #d4edda;
            color: #155724;
        }
        
        .metric-status.inactive {
            background-color: #f8d7da;
            color: #721c24;
        }
        
        .reorder-item-details span {
            display: inline-block;
            margin-right: 15px;
            font-size: 11px;
        }
        
        .metric-order {
            font-weight: bold;
            color: var(--accent-color) !important;
        }
        
        .drag-handle {
            font-size: 18px;
            color: #6c757d;
            cursor: grab;
            margin-right: 10px;
        }
        
        .drag-handle:active {
            cursor: grabbing;
        }
        
        /* Accordion styles */
        .accordion-container {
            margin-top: 30px;
        }
        
        .accordion-module {
            margin-bottom: 15px;
            border: 1px solid var(--border-primary);
            border-radius: 8px;
            overflow: hidden;
            background-color: var(--bg-primary);
            box-shadow: none;
        }
        
        .accordion-header {
            background-color: var(--bg-secondary);
            padding: 15px 20px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-primary);
            transition: background-color 0.3s ease;
        }
        
        .accordion-header:hover {
            background-color: var(--bg-tertiary);
        }
        
        .accordion-header h3 {
            margin: 0;
            font-size: 18px;
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .accordion-header-content {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }
        
        .accordion-header-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-left: auto;
        }
        
        .header-chart-btn {
            background-color: transparent;
            color: var(--accent-color);
            border: 2px solid var(--accent-color);
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: none;
            align-items: center;
            gap: 4px;
        }
        
        .header-chart-btn:hover {
            background-color: var(--accent-color);
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(173, 53, 250, 0.3);
        }
        
        .header-chart-btn:active {
            transform: translateY(0);
        }
        
        .header-chart-btn.visible {
            display: flex;
        }
        
        .accordion-icon {
            font-size: 14px;
            color: #6c757d;
            transition: transform 0.3s ease;
            margin-left: 15px;
        }
        
        .accordion-content {
            background-color: var(--bg-primary);
            padding: 0;
        }
        
        .module-section {
            padding: 15px;
        }
        
        .module-section:last-child {
            border-bottom: none;
        }
        
        .module-section h4 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
            color: var(--text-primary);
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 8px;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                gap: 15px;
            }
            
            .metric-actions {
                flex-wrap: wrap;
                gap: 8px;
            }
            
            .accordion-header {
                padding: 12px 15px;
            }
            
            .accordion-header h3 {
                font-size: 16px;
            }
            
            .module-section {
                padding: 15px;
            }
        }
        
        /* Chart buttons styles */
        .chart-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        
        .chart-btn {
            background-color: transparent;
            color: var(--accent-color);
            border: 2px solid var(--accent-color);
            padding: 12px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .chart-btn:hover {
            background-color: var(--accent-color);
            color: white;
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(173, 53, 250, 0.3);
        }
        
        .chart-btn:active {
            transform: translateY(0);
        }
        
        /* Charts modal styles */
        .charts-modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
        }
        
        .charts-modal-content {
            background-color: white;
            margin: 2% auto;
            width: 95%;
            max-width: 1400px;
            height: 90vh;
            border-radius: 12px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        .charts-modal-header {
            background-color: #f8f9fa;
            padding: 20px 30px;
            border-bottom: 1px solid #e9ecef;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .charts-modal-header h2 {
            margin: 0;
            color: #495057;
            font-size: 24px;
            font-weight: 600;
        }
        
        .charts-modal-body {
            flex: 1;
            padding: 30px;
            overflow-y: auto;
        }
        
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 25px;
            max-width: 100%;
        }
        
        .chart-card {
            background-color: white;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            /* Let the card expand to fit the full height of its contents */
            height: auto;
            display: flex;
            flex-direction: column;
        }
        
        .chart-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }
        
        .chart-card-header {
            background-color: #f8f9fa;
            padding: 15px 20px;
            border-bottom: 1px solid #e9ecef;
        }
        
        .chart-card-header h4 {
            margin: 0;
            color: #495057;
            font-size: 16px;
            font-weight: 600;
        }
        
        .chart-card-body {
            flex: 1;
            position: relative;
            /* Ensure the full chart is visible */
            overflow: visible;
        }
        
        .chart-card-body iframe {
            width: 100%;
            /* Allow iframe to size itself naturally */
            height: auto;
            border: none;
        }
        
        .chart-card-footer {
            background-color: #f8f9fa;
            padding: 10px 15px;
            border-top: 1px solid #e9ecef;
            display: flex;
            justify-content: center;
        }
        
        .chart-dw-btn {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s ease;
        }
        
        .chart-dw-btn:hover:not(:disabled) {
            background-color: #218838;
        }
        
        .chart-dw-btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        
        .chart-dw-btn.loading {
            background-color: #6c757d;
            cursor: not-allowed;
            position: relative;
        }
        
        .chart-dw-btn.loading::after {
            content: '';
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
        }
        
        .loading-charts {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-size: 16px;
        }
        
        .no-charts-message {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-size: 16px;
            font-style: italic;
        }
        
        /* Responsive adjustments for charts modal */
        @media (max-width: 1200px) {
            .charts-grid {
                grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
                gap: 20px;
            }
        }
        
        @media (max-width: 768px) {
            .charts-modal-content {
                margin: 5% auto;
                width: 95%;
                height: 85vh;
            }
            
            .charts-modal-header {
                padding: 15px 20px;
            }
            
            .charts-modal-header h2 {
                font-size: 20px;
            }
            
            .charts-modal-body {
                padding: 20px;
            }
            
            .charts-grid {
                grid-template-columns: 1fr;
                gap: 15px;
            }
            
            .chart-buttons {
                flex-direction: column;
                gap: 10px;
            }
            
            .chart-btn {
                width: 100%;
                justify-content: center;
            }
        }
        
        /* Metric header display styles */
        .metric-header {
            margin-bottom: 20px;
            padding: 15px;
            background-color: var(--bg-secondary);
            border-radius: 4px;
            border: 1px solid var(--border-primary);
        }
        
        .metric-header-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 20px;
        }
        
        .metric-date-section {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }
        
        .metric-date-label {
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .metric-date {
            color: var(--accent-color);
            font-weight: 700;
            font-size: 18px;
        }
        
        .metric-date.unavailable {
            color: var(--text-secondary);
            font-style: italic;
            font-weight: normal;
        }
        
        .metric-details-section {
            display: flex;
            align-items: center;
            gap: 20px;
            color: var(--text-secondary);
            font-size: 13px;
        }
        
        .metric-id {
            font-weight: 600;
            color: var(--text-primary);
            background-color: var(--bg-primary);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-primary);
        }
        
        .metric-category {
            font-style: italic;
        }
        
        .metric-endpoint {
            font-family: monospace;
            background-color: var(--bg-primary);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid var(--border-primary);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <div class="form-group">
                <label for="district-select">Select District:</label>
                <select id="district-select">
                    <option value="0">Citywide (All Districts)</option>
                    <option value="1">District 1</option>
                    <option value="2">District 2</option>
                    <option value="3">District 3</option>
                    <option value="4">District 4</option>
                    <option value="5">District 5</option>
                    <option value="6">District 6</option>
                    <option value="7">District 7</option>
                    <option value="8">District 8</option>
                    <option value="9">District 9</option>
                    <option value="10">District 10</option>
                    <option value="11">District 11</option>
                </select>
            </div>
            <div class="form-group">
                <label for="metric-select">Select Metric:</label>
                <select id="metric-select">
                    <option value="all">All Metrics</option>
                    <option value="1">Loading metrics...</option>
                </select>
            </div>
            <div class="form-group">
                <label for="period-type-select">Period Type:</label>
                <select id="period-type-select">
                    <option value="ytd">YTD Metrics (Day)</option>
                    <option value="week">Weekly Analysis</option>
                    <option value="month">Monthly Analysis</option>
                    <option value="year">Annual Analysis</option>
                    <option value="both">Monthly & Annual Analysis</option>
                </select>
            </div>
            <div class="form-group">
                <button id="generate-metrics-btn" class="btn btn-primary btn-with-spinner">
                    Generate Metrics
                    <span class="btn-spinner"></span>
                </button>
            </div>
        </div>
        
        <!-- Metric Header Row -->
        <div id="metric-header" class="metric-header" style="display: none;">
            <div id="metric-header-content"></div>
        </div>
        
        <div class="metric-management-row">
            <div class="metric-actions">
                <button id="delete-metric-btn" class="btn btn-subtle btn-small" disabled>
                    Delete Metric
                </button>
                <button id="edit-metric-btn" class="btn btn-subtle btn-small" disabled>
                    Edit Metric
                </button>
                <button id="define-metric-btn" class="btn btn-subtle btn-small">
                    Create New Metric
                </button>
                <button id="reorder-metrics-btn" class="btn btn-subtle btn-small">
                    Reorder Metrics
                </button>
            </div>
        </div>
        <!-- All output/chart/map sections are hidden for now. -->
        
        <!-- Progress and status information -->
        <div id="generate-status" class="status-container"></div>
        <div id="generate-progress" class="progress-container" style="display: none;">
            <div class="progress-status">Initializing metric generation...</div>
            <div class="progress-bar">
                <div class="progress-bar-fill"></div>
            </div>
            <div class="progress-details" id="progress-log"></div>
        </div>
        
        <!-- Modular Accordion Structure -->
        <div class="accordion-container">
            <!-- Dataset Columns Module -->
            <div class="accordion-module">
                <div class="accordion-header" onclick="toggleModule('columns')">
                    <div class="accordion-header-content">
                        <h3>📋 Dataset Columns</h3>
                    </div>
                    <span class="accordion-icon">▼</span>
                </div>
                <div id="columns-content" class="accordion-content" style="display: none;">
                    <div class="module-section">
                        <h4>Select Columns for Enhanced Dashboard</h4>
                        <div id="column-grid" class="column-grid">
                            <!-- Columns will be populated here -->
                            <div class="no-charts-message">Select a metric to view available columns</div>
                        </div>
                        <div class="column-actions">
                            <button id="select-all-columns" class="btn btn-primary">Select All</button>
                            <button id="deselect-all-columns" class="btn btn-primary">Deselect All</button>
                            <button id="update-columns" class="btn btn-primary">Update Enhanced Queries</button>
                        </div>
                        <div id="column-update-status" style="margin-top: 10px; display: none;"></div>
                    </div>
                </div>
            </div>
            
            <!-- Dashboard Module -->
            <div class="accordion-module">
                <div class="accordion-header" onclick="toggleModule('dashboard')">
                    <div class="accordion-header-content">
                        <h3>📊 Dashboard</h3>
                        <div class="accordion-header-buttons">
                            <button class="header-chart-btn" onclick="event.stopPropagation(); openChartsModal('day', 'time-series')">
                                📊 Charts
                            </button>
                        </div>
                    </div>
                    <span class="accordion-icon">▼</span>
                </div>
                <div id="dashboard-content" class="accordion-content" style="display: none;">
                    <div class="module-section">
                        <h4>Dashboard Output</h4>
                        <div id="dashboard-output" class="output-content">Select a metric to view dashboard output</div>
                    </div>
                </div>
            </div>
            
            <!-- Annual Module -->
            <div class="accordion-module">
                <div class="accordion-header" onclick="toggleModule('annual')">
                    <div class="accordion-header-content">
                        <h3>📈 Annual Analysis</h3>
                        <div class="accordion-header-buttons">
                            <button class="header-chart-btn" onclick="event.stopPropagation(); openChartsModal('annual', 'time-series')">
                                📊 Charts
                            </button>
                            <button class="header-chart-btn" onclick="event.stopPropagation(); openChartsModal('annual', 'anomalies')">
                                🔍 Anomalies
                            </button>
                            <button class="header-chart-btn" onclick="event.stopPropagation(); openChartsModal('annual', 'maps')">
                                🗺️ Maps
                            </button>
                        </div>
                    </div>
                    <span class="accordion-icon">▼</span>
                </div>
                <div id="annual-content" class="accordion-content" style="display: none;">
                    <div class="module-section">
                        <h4>Annual Output</h4>
                        <div id="annual-output" class="output-content">Select a metric to view annual output</div>
                    </div>
                </div>
            </div>
            
            <!-- Monthly Module -->
            <div class="accordion-module">
                <div class="accordion-header" onclick="toggleModule('monthly')">
                    <div class="accordion-header-content">
                        <h3>📅 Monthly Analysis</h3>
                        <div class="accordion-header-buttons">
                            <button class="header-chart-btn" onclick="event.stopPropagation(); openChartsModal('monthly', 'time-series')">
                                📊 Charts
                            </button>
                            <button class="header-chart-btn" onclick="event.stopPropagation(); openChartsModal('monthly', 'anomalies')">
                                🔍 Anomalies
                            </button>
                            <button class="header-chart-btn" onclick="event.stopPropagation(); openChartsModal('monthly', 'maps')">
                                🗺️ Maps
                            </button>
                        </div>
                    </div>
                    <span class="accordion-icon">▼</span>
                </div>
                <div id="monthly-content" class="accordion-content" style="display: none;">
                    <div class="module-section">
                        <h4>Monthly Output</h4>
                        <div id="monthly-output" class="output-content">Select a metric to view monthly output</div>
                    </div>
                </div>
            </div>
            
            <!-- Weekly Module -->
            <div class="accordion-module">
                <div class="accordion-header" onclick="toggleModule('weekly')">
                    <div class="accordion-header-content">
                        <h3>📆 Weekly Analysis</h3>
                        <div class="accordion-header-buttons">
                            <button class="header-chart-btn" onclick="event.stopPropagation(); openChartsModal('weekly', 'time-series')">
                                📊 Charts
                            </button>
                            <button class="header-chart-btn" onclick="event.stopPropagation(); openChartsModal('weekly', 'anomalies')">
                                🔍 Anomalies
                            </button>
                            <button class="header-chart-btn" onclick="event.stopPropagation(); openChartsModal('weekly', 'maps')">
                                🗺️ Maps
                            </button>
                        </div>
                    </div>
                    <span class="accordion-icon">▼</span>
                </div>
                <div id="weekly-content" class="accordion-content" style="display: none;">
                    <div class="module-section">
                        <h4>Weekly Output</h4>
                        <div id="weekly-output" class="output-content">Select a metric to view weekly output</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Add the metric definition modal -->
    <div id="metricDefinitionModal" class="metric-definition-modal">
        <div class="metric-definition-content">
            <button type="button" class="close-modal-btn" onclick="closeMetricDefinitionModal()">&times;</button>
            <h2 id="metricModalTitle">Define New Metric</h2>
            <form id="metricDefinitionForm">
                <input type="hidden" id="isEditMode" value="false">
                <div class="metric-form-group">
                    <label for="metricName">Metric Name (with emoji)</label>
                    <input type="text" id="metricName" name="metricName" required>
                </div>
                
                <div class="metric-form-group">
                    <label for="metricId">ID</label>
                    <input type="text" id="metricId" name="metricId" required>
                </div>
                
                <div class="metric-form-group">
                    <label for="endpoint">Endpoint</label>
                    <input type="text" id="endpoint" name="endpoint" required>
                </div>
                
                <div class="metric-form-group">
                    <label for="category">Category</label>
                    <input type="text" id="category" name="category" required placeholder="e.g. crime, safety, economy">
                </div>
                
                <div class="metric-form-group">
                    <label for="subcategory">Subcategory</label>
                    <input type="text" id="subcategory" name="subcategory" placeholder="e.g. Crime, Fire, Housing">
                </div>
                
                <div class="metric-form-group">
                    <label for="summary">Summary</label>
                    <textarea id="summary" name="summary" required></textarea>
                </div>
                
                <div class="metric-form-group">
                    <label for="definition">Definition</label>
                    <textarea id="definition" name="definition" required></textarea>
                </div>
                
                <div class="metric-form-group">
                    <label for="dataSfUrl">Data SF URL</label>
                    <input type="text" id="dataSfUrl" name="dataSfUrl" required>
                </div>
                
                <div class="metric-form-group">
                    <label for="ytdQuery">YTD Query</label>
                    <textarea id="ytdQuery" name="ytdQuery" required></textarea>
                </div>
                
                <div class="metric-form-group">
                    <label for="metricQuery">Metric Query</label>
                    <textarea id="metricQuery" name="metricQuery" required></textarea>
                </div>
                
                <div class="metric-form-group">
                    <label for="datasetTitle">Dataset Title</label>
                    <input type="text" id="datasetTitle" name="datasetTitle" required>
                </div>
                
                <div class="metric-form-group">
                    <label for="datasetCategory">Dataset Category</label>
                    <input type="text" id="datasetCategory" name="datasetCategory" required>
                </div>
                
                <div class="metric-form-group">
                    <label for="itemNoun">Item Noun</label>
                    <input type="text" id="itemNoun" name="itemNoun" required placeholder="e.g. Items, Cases, Incidents">
                </div>
                
                <div class="metric-form-group">
                    <label for="greenDirection">Green Direction</label>
                    <select id="greenDirection" name="greenDirection" required>
                        <option value="up">Up (higher is better)</option>
                        <option value="down">Down (lower is better)</option>
                    </select>
                </div>
                
                <div class="metric-form-group">
                    <label for="isActive">Status</label>
                    <select id="isActive" name="isActive" required>
                        <option value="true">Active</option>
                        <option value="false">Inactive</option>
                    </select>
                </div>
                
                <div class="metric-form-group">
                    <label for="showOnDash">Show on Dashboard</label>
                    <select id="showOnDash" name="showOnDash" required>
                        <option value="true">Yes</option>
                        <option value="false">No</option>
                    </select>
                </div>
                
                <div class="metric-form-actions">
                    <button type="button" class="cancel-btn" onclick="closeMetricDefinitionModal()">Cancel</button>
                    <button type="submit" class="save-btn">Save Metric</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Add the metric reordering modal -->
    <div id="metricReorderModal" class="metric-reorder-modal">
        <div class="metric-reorder-content">
            <button type="button" class="close-modal-btn" onclick="closeMetricReorderModal()">&times;</button>
            <h2>Reorder Metrics</h2>
            <p>Drag and drop metrics to reorder them, or use the arrow buttons. The order will affect how they appear in the dashboard and metric selection.</p>
            
            <div id="reorderLoadingState" style="display: none; text-align: center; padding: 20px;">
                <div class="spinner"></div>
                <p>Loading metrics...</p>
            </div>
            
            <ul id="metricReorderList" class="reorder-list">
                <!-- Metrics will be populated here -->
            </ul>
            
            <div class="metric-form-actions">
                <button type="button" class="cancel-btn" onclick="closeMetricReorderModal()">Cancel</button>
                <button type="button" class="save-btn" onclick="saveMetricOrder()">Save Order</button>
            </div>
        </div>
    </div>
    
    <!-- Charts Modal -->
    <div id="chartsModal" class="charts-modal">
        <div class="charts-modal-content">
            <div class="charts-modal-header">
                <h2 id="chartsModalTitle">Charts & Visualizations</h2>
                <button type="button" class="close-modal-btn" onclick="closeChartsModal()">&times;</button>
            </div>
            <div class="charts-modal-body">
                <div id="chartsGrid" class="charts-grid">
                    <!-- Charts will be loaded here -->
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Global variables
        let metrics = [];
        let loadedModules = new Set();
        
        // Accordion functionality
        function toggleModule(moduleName) {
            const content = document.getElementById(`${moduleName}-content`);
            const icon = document.querySelector(`[onclick="toggleModule('${moduleName}')"] .accordion-icon`);
            
            if (content.style.display === 'none') {
                // Close all other modules
                document.querySelectorAll('.accordion-content').forEach(el => {
                    el.style.display = 'none';
                });
                document.querySelectorAll('.accordion-icon').forEach(el => {
                    el.textContent = '▼';
                });
                
                // Open this module
                content.style.display = 'block';
                icon.textContent = '▲';
                
                // Load content if not already loaded
                if (!loadedModules.has(moduleName)) {
                    loadModuleContent(moduleName);
                    loadedModules.add(moduleName);
                }
            } else {
                // Close this module
                content.style.display = 'none';
                icon.textContent = '▼';
            }
        }
        
        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            // Load metrics on page load
            loadMetrics();
            
            // Add event listeners
            document.getElementById('metric-select').addEventListener('change', function() {
                const metricId = this.value;
                const districtId = document.getElementById('district-select').value;
                const periodType = document.getElementById('period-type-select').value;
                
                // Enable/disable action buttons
                const deleteBtn = document.getElementById('delete-metric-btn');
                const editBtn = document.getElementById('edit-metric-btn');
                const shouldEnable = metricId && metricId !== 'all' && metricId !== '';
                deleteBtn.disabled = !shouldEnable;
                editBtn.disabled = !shouldEnable;
                
                // Show helpful message for all metrics + weekly/monthly analysis
                const generateStatus = document.getElementById('generate-status');
                if (metricId === 'all' && periodType === 'week') {
                    generateStatus.style.display = 'block';
                    generateStatus.innerHTML = `
                        <div style="color: #17a2b8; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; margin-bottom: 15px;">
                            <h4>📊 Weekly Analysis for All Metrics</h4>
                            <p>Click "Generate Metrics" to run weekly analysis for all available metrics. This will process all active metrics and generate a comprehensive weekly report.</p>
                        </div>
                    `;
                } else if (metricId === 'all' && periodType === 'month') {
                    generateStatus.style.display = 'block';
                    generateStatus.innerHTML = `
                        <div style="color: #17a2b8; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; margin-bottom: 15px;">
                            <h4>📊 Monthly Analysis for All Metrics</h4>
                            <p>Click "Generate Metrics" to run monthly analysis for all available metrics. This will process all active metrics and generate a comprehensive monthly report.</p>
                        </div>
                    `;
                } else if (metricId === 'all' && periodType === 'year') {
                    generateStatus.style.display = 'block';
                    generateStatus.innerHTML = `
                        <div style=\"color: #17a2b8; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; margin-bottom: 15px;\">
                            <h4>📊 Annual Analysis for All Metrics</h4>
                            <p>Click \"Generate Metrics\" to run annual analysis for all available metrics. This will process all active metrics and generate a comprehensive annual report.</p>
                        </div>
                    `;
                } else if (metricId === 'all' && periodType === 'ytd') {
                    generateStatus.style.display = 'block';
                    generateStatus.innerHTML = `
                        <div style="color: #17a2b8; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; margin-bottom: 15px;">
                            <h4>📊 YTD Metrics Generation for All Metrics</h4>
                            <p>Click "Generate Metrics" to run YTD metrics generation for all available metrics. This will process all active metrics and generate comprehensive dashboard metrics.</p>
                        </div>
                    `;
                } else {
                    generateStatus.style.display = 'none';
                }
                
                // Load columns if metric is selected
                if (metricId && metricId !== 'all') {
                    loadColumns(metricId);
                } else {
                    document.getElementById('column-selection').style.display = 'none';
                }
                
                // Clear loaded modules tracking to force reload
                loadedModules.clear();
                
                // Reload content for any open modules
                reloadOpenModules();
            });
            
            // Add district change listener
            document.getElementById('district-select').addEventListener('change', function() {
                // Clear loaded modules tracking to force reload
                loadedModules.clear();
                reloadOpenModules();
            });
            
            // Add period type change listener to update status message
            document.getElementById('period-type-select').addEventListener('change', function() {
                const metricId = document.getElementById('metric-select').value;
                const periodType = this.value;
                
                // Show helpful message for all metrics + weekly/monthly analysis
                const generateStatus = document.getElementById('generate-status');
                if (metricId === 'all' && periodType === 'week') {
                    generateStatus.style.display = 'block';
                    generateStatus.innerHTML = `
                        <div style="color: #17a2b8; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; margin-bottom: 15px;">
                            <h4>📊 Weekly Analysis for All Metrics</h4>
                            <p>Click "Generate Metrics" to run weekly analysis for all available metrics. This will process all active metrics and generate a comprehensive weekly report.</p>
                        </div>
                    `;
                } else if (metricId === 'all' && periodType === 'month') {
                    generateStatus.style.display = 'block';
                    generateStatus.innerHTML = `
                        <div style="color: #17a2b8; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; margin-bottom: 15px;">
                            <h4>📊 Monthly Analysis for All Metrics</h4>
                            <p>Click "Generate Metrics" to run monthly analysis for all available metrics. This will process all active metrics and generate a comprehensive monthly report.</p>
                        </div>
                    `;
                } else if (metricId === 'all' && periodType === 'year') {
                    generateStatus.style.display = 'block';
                    generateStatus.innerHTML = `
                        <div style=\"color: #17a2b8; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; margin-bottom: 15px;\">
                            <h4>📊 Annual Analysis for All Metrics</h4>
                            <p>Click \"Generate Metrics\" to run annual analysis for all available metrics. This will process all active metrics and generate a comprehensive annual report.</p>
                        </div>
                    `;
                } else if (metricId === 'all' && periodType === 'ytd') {
                    generateStatus.style.display = 'block';
                    generateStatus.innerHTML = `
                        <div style="color: #17a2b8; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; margin-bottom: 15px;">
                            <h4>📊 YTD Metrics Generation for All Metrics</h4>
                            <p>Click "Generate Metrics" to run YTD metrics generation for all available metrics. This will process all active metrics and generate comprehensive dashboard metrics.</p>
                        </div>
                    `;
                } else {
                    generateStatus.style.display = 'none';
                }
            });
            
            // Add other event listeners
            document.getElementById('define-metric-btn').addEventListener('click', openMetricDefinitionModal);
            document.getElementById('edit-metric-btn').addEventListener('click', openEditMetricModal);
            document.getElementById('delete-metric-btn').addEventListener('click', deleteMetric);
            document.getElementById('reorder-metrics-btn').addEventListener('click', openMetricReorderModal);
            document.getElementById('generate-metrics-btn').addEventListener('click', generateMetrics);
            
            // Add form submission handler
            document.getElementById('metricDefinitionForm').addEventListener('submit', handleMetricFormSubmission);
            
            // Close modals when clicking outside
            window.addEventListener('click', function(event) {
                const modal = document.getElementById('metricDefinitionModal');
                if (event.target === modal) {
                    closeMetricDefinitionModal();
                }
                
                const reorderModal = document.getElementById('metricReorderModal');
                if (event.target === reorderModal) {
                    closeMetricReorderModal();
                }
                
                const chartsModal = document.getElementById('chartsModal');
                if (event.target === chartsModal) {
                    closeChartsModal();
                }
            });
            
            // Check if a metric is already selected and show buttons accordingly
            setTimeout(() => {
                const selectedMetric = document.getElementById('metric-select').value;
                const periodType = document.getElementById('period-type-select').value;
                updateChartButtonsVisibility(selectedMetric);
                
                // Show helpful message for all metrics + weekly/monthly analysis
                const generateStatus = document.getElementById('generate-status');
                if (selectedMetric === 'all' && periodType === 'week') {
                    generateStatus.style.display = 'block';
                    generateStatus.innerHTML = `
                        <div style="color: #17a2b8; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; margin-bottom: 15px;">
                            <h4>📊 Weekly Analysis for All Metrics</h4>
                            <p>Click "Generate Metrics" to run weekly analysis for all available metrics. This will process all active metrics and generate a comprehensive weekly report.</p>
                        </div>
                    `;
                } else if (selectedMetric === 'all' && periodType === 'month') {
                    generateStatus.style.display = 'block';
                    generateStatus.innerHTML = `
                        <div style="color: #17a2b8; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; margin-bottom: 15px;">
                            <h4>📊 Monthly Analysis for All Metrics</h4>
                            <p>Click "Generate Metrics" to run monthly analysis for all available metrics. This will process all active metrics and generate a comprehensive monthly report.</p>
                        </div>
                    `;
                } else if (selectedMetric === 'all' && periodType === 'year') {
                    generateStatus.style.display = 'block';
                    generateStatus.innerHTML = `
                        <div style=\"color: #17a2b8; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; margin-bottom: 15px;\">
                            <h4>📊 Annual Analysis for All Metrics</h4>
                            <p>Click \"Generate Metrics\" to run annual analysis for all available metrics. This will process all active metrics and generate a comprehensive annual report.</p>
                        </div>
                    `;
                } else if (selectedMetric === 'all' && periodType === 'ytd') {
                    generateStatus.style.display = 'block';
                    generateStatus.innerHTML = `
                        <div style="color: #17a2b8; background-color: #d1ecf1; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; margin-bottom: 15px;">
                            <h4>📊 YTD Metrics Generation for All Metrics</h4>
                            <p>Click "Generate Metrics" to run YTD metrics generation for all available metrics. This will process all active metrics and generate comprehensive dashboard metrics.</p>
                        </div>
                    `;
                }
            }, 100);
        });
        
        // Function to reload content for any open modules
        function reloadOpenModules() {
            const metricId = document.getElementById('metric-select').value;
            const districtId = document.getElementById('district-select').value;
            
            if (!metricId || metricId === 'all') {
                return;
            }
            
            // Check which modules are currently open and reload their content
            const modules = ['dashboard', 'annual', 'monthly', 'weekly', 'ytd', 'maps'];
            modules.forEach(moduleName => {
                const content = document.getElementById(`${moduleName}-content`);
                if (content && content.style.display !== 'none') {
                    // Force reload by calling loadModuleContent directly
                    loadModuleContent(moduleName);
                }
            });
        }
        
        // Load content for a specific module
        function loadModuleContent(moduleName) {
            const metricId = document.getElementById('metric-select').value;
            const districtId = document.getElementById('district-select').value;
            
            if (!metricId || metricId === 'all') {
                return;
            }
            
            switch(moduleName) {
                case 'dashboard':
                    loadDashboardOutput(metricId, districtId);
                    break;
                case 'annual':
                    loadAnnualContent(metricId, districtId);
                    break;
                case 'monthly':
                    loadMonthlyContent(metricId, districtId);
                    break;
                case 'weekly':
                    loadWeeklyOutput(metricId, districtId);
                    break;
                case 'maps':
                    loadDistrictMaps(metricId);
                    break;
            }
        }
        
        // Load specific content functions
        async function loadDashboardOutput(metricId, districtId) {
            const output = document.getElementById('dashboard-output');
            output.innerHTML = '<div class="spinner"></div> Loading...';
            
            try {
                const response = await fetch(`/output/dashboard/${districtId}/${metricId}.json`);
                if (response.ok) {
                    const data = await response.json();
                    output.textContent = JSON.stringify(data, null, 2);
                } else {
                    output.textContent = 'No dashboard output available for this district/metric combination';
                }
            } catch (error) {
                console.error('Error loading dashboard output:', error);
                output.textContent = `Error loading output: ${error.message}`;
            }
        }
        
        async function loadAnnualContent(metricId, districtId) {
            // Load annual output
            const output = document.getElementById('annual-output');
            output.innerHTML = '<div class="spinner"></div> Loading...';
            
            try {
                const response = await fetch(`/output/annual/${districtId}/${metricId}.md`);
                if (response.ok) {
                    const text = await response.text();
                    output.innerHTML = marked.parse(text);
                    output.classList.add('markdown');
                } else {
                    output.textContent = 'No annual output available for this district/metric combination';
                }
            } catch (error) {
                console.error('Error loading annual output:', error);
                output.textContent = `Error loading output: ${error.message}`;
            }
            
            // Load annual charts
            loadTimeSeriesCharts(metricId, districtId, 'year', 'annual-time-series-charts');
            loadAnomalyCharts(metricId, districtId, 'year', 'annual-anomaly-charts');
        }
        
        async function loadMonthlyContent(metricId, districtId) {
            // Load monthly output
            const output = document.getElementById('monthly-output');
            output.innerHTML = '<div class="spinner"></div> Loading...';
            
            try {
                const response = await fetch(`/output/monthly/${districtId}/${metricId}.md`);
                if (response.ok) {
                    const text = await response.text();
                    output.innerHTML = marked.parse(text);
                    output.classList.add('markdown');
                } else {
                    output.textContent = 'No monthly output available for this district/metric combination';
                }
            } catch (error) {
                console.error('Error loading monthly output:', error);
                output.textContent = `Error loading output: ${error.message}`;
            }
            
            // Load monthly charts
            loadTimeSeriesCharts(metricId, districtId, 'month', 'time-series-charts');
            loadAnomalyCharts(metricId, districtId, 'month', 'anomaly-charts');
        }
        
        async function loadWeeklyOutput(metricId, districtId) {
            const output = document.getElementById('weekly-output');
            output.innerHTML = '<div class="spinner"></div> Loading...';
            
            try {
                const response = await fetch(`/output/weekly/${districtId}/${metricId}.md`);
                if (response.ok) {
                    const text = await response.text();
                    output.innerHTML = marked.parse(text);
                    output.classList.add('markdown');
                } else {
                    output.textContent = 'No weekly output available for this district/metric combination';
                }
            } catch (error) {
                console.error('Error loading weekly output:', error);
                output.textContent = `Error loading output: ${error.message}`;
            }
        }
        
        async function loadYTDOutput(metricId, districtId) {
            const output = document.getElementById('ytd-output');
            output.innerHTML = '<div class="spinner"></div> Loading...';
            
            try {
                const response = await fetch(`/output/ytd/${districtId}/${metricId}.md`);
                if (response.ok) {
                    const text = await response.text();
                    output.innerHTML = marked.parse(text);
                    output.classList.add('markdown');
                } else {
                    output.textContent = 'No YTD output available for this district/metric combination';
                }
            } catch (error) {
                console.error('Error loading YTD output:', error);
                output.textContent = `Error loading output: ${error.message}`;
            }
        }
        
        // Chart loading functions (simplified for now)
        async function loadTimeSeriesCharts(metricId, districtId, periodType, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '<div class="loading-charts">Loading charts...</div>';
            
            // Placeholder for chart loading logic
            setTimeout(() => {
                container.innerHTML = '<div class="no-charts-message">Charts will be loaded here</div>';
            }, 1000);
        }
        
        async function loadAnomalyCharts(metricId, districtId, periodType, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '<div class="loading-charts">Loading anomalies...</div>';
            
            // Placeholder for anomaly loading logic
            setTimeout(() => {
                container.innerHTML = '<div class="no-charts-message">Anomalies will be loaded here</div>';
            }, 1000);
        }
        
        async function loadDistrictMaps(metricId) {
            const container = document.getElementById('district-maps');
            container.innerHTML = '<div class="loading-charts">Loading maps...</div>';
            
            // Placeholder for map loading logic
            setTimeout(() => {
                container.innerHTML = '<div class="no-charts-message">Maps will be loaded here</div>';
            }, 1000);
        }
        
        // Modal functions
        function openMetricDefinitionModal() {
            const isEditMode = document.getElementById('isEditMode').value === 'true';
            if (!isEditMode) {
                document.getElementById('metricDefinitionForm').reset();
                document.getElementById('metricModalTitle').textContent = 'Define New Metric';
                document.getElementById('metricId').readOnly = false; // Allow editing ID for new metrics
            }
            document.getElementById('metricDefinitionModal').style.display = 'block';
        }

        function openEditMetricModal() {
            const metricId = document.getElementById('metric-select').value;
            if (!metricId || metricId === 'all') {
                alert('Please select a specific metric to edit');
                return;
            }
            
            // Set edit mode
            document.getElementById('isEditMode').value = 'true';
            document.getElementById('metricModalTitle').textContent = 'Edit Metric';
            
            // Load the metric data
            loadMetricForEditing(metricId);
            
            // Show the modal
            document.getElementById('metricDefinitionModal').style.display = 'block';
        }

        async function loadMetricForEditing(metricId) {
            try {
                console.log(`Loading metric for editing: ${metricId}`);
                const response = await fetch(`/api/metric/${metricId}`);
                console.log(`Response status: ${response.status}`);
                console.log(`Response ok: ${response.ok}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to load metric: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Response data:', data);
                
                // Handle both response formats
                let metric;
                if (data.status === 'success' && data.metric) {
                    // Wrapped response format
                    console.log('Using wrapped response format');
                    metric = data.metric;
                } else if (data.id) {
                    // Direct metric data format
                    console.log('Using direct metric data format');
                    metric = data;
                } else {
                    console.error('Invalid response format:', data);
                    throw new Error('Invalid response format from server');
                }
                
                console.log('Final metric data:', metric);
                
                // Populate the form fields
                document.getElementById('metricName').value = metric.metric_name || metric.name || '';
                document.getElementById('metricId').value = metric.id || '';
                document.getElementById('metricId').readOnly = true; // Make ID read-only in edit mode
                document.getElementById('endpoint').value = metric.endpoint || '';
                document.getElementById('category').value = metric.category || '';
                document.getElementById('subcategory').value = metric.subcategory || '';
                document.getElementById('summary').value = metric.summary || '';
                document.getElementById('definition').value = metric.definition || '';
                document.getElementById('dataSfUrl').value = metric.data_sf_url || '';
                document.getElementById('ytdQuery').value = metric.ytd_query || '';
                document.getElementById('metricQuery').value = metric.metric_query || '';
                document.getElementById('datasetTitle').value = metric.dataset_title || '';
                document.getElementById('datasetCategory').value = metric.dataset_category || '';
                document.getElementById('itemNoun').value = metric.item_noun || '';
                document.getElementById('greenDirection').value = metric.greendirection || 'up';
                document.getElementById('isActive').value = metric.is_active ? 'true' : 'false';
                document.getElementById('showOnDash').value = metric.show_on_dash ? 'true' : 'false';
                
                console.log('Form populated successfully');
                
            } catch (error) {
                console.error('Error loading metric for editing:', error);
                alert(`Error loading metric data: ${error.message}`);
                closeMetricDefinitionModal();
            }
        }

        async function handleMetricFormSubmission(event) {
            event.preventDefault();
            
            console.log('Metric form submission triggered - this should not happen when running metrics');
            
            const isEditMode = document.getElementById('isEditMode').value === 'true';
            const form = event.target;
            const formData = new FormData(form);
            
            // Convert FormData to object and map field names to API expectations
            const metricData = {};
            for (let [key, value] of formData.entries()) {
                switch(key) {
                    case 'metricName':
                        metricData.name = value;
                        break;
                    case 'metricId':
                        // Only include ID for new metrics, not for editing
                        if (!isEditMode) {
                            metricData.id = value;
                        }
                        break;
                    case 'category':
                        metricData.category = value;
                        break;
                    case 'subcategory':
                        metricData.subcategory = value;
                        break;
                    case 'dataSfUrl':
                        metricData.data_sf_url = value;
                        break;
                    case 'ytdQuery':
                        metricData.ytd_query = value;
                        break;
                    case 'metricQuery':
                        metricData.metric_query = value;
                        break;
                    case 'datasetTitle':
                        metricData.dataset_title = value;
                        break;
                    case 'datasetCategory':
                        metricData.dataset_category = value;
                        break;
                    case 'itemNoun':
                        metricData.item_noun = value;
                        break;
                    case 'greenDirection':
                        metricData.greendirection = value;
                        break;
                    case 'isActive':
                        metricData.is_active = value === 'true';
                        break;
                    case 'showOnDash':
                        metricData.show_on_dash = value === 'true';
                        break;
                    default:
                        metricData[key] = value;
                        break;
                }
            }
            
            try {
                let response;
                let endpoint;
                
                if (isEditMode) {
                    // Edit existing metric
                    const metricId = document.getElementById('metricId').value;
                    endpoint = `/api/metrics/${metricId}`;
                    response = await fetch(endpoint, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(metricData)
                    });
                } else {
                    // Create new metric
                    endpoint = '/api/metrics';
                    response = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(metricData)
                    });
                }
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || `HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    alert(`Metric ${isEditMode ? 'updated' : 'created'} successfully!`);
                    closeMetricDefinitionModal();
                    
                    // Reload metrics list to reflect changes
                    await loadMetrics();
                    
                    // If editing, select the edited metric
                    if (isEditMode) {
                        document.getElementById('metric-select').value = result.metric_id;
                        // Trigger change event to update UI
                        document.getElementById('metric-select').dispatchEvent(new Event('change'));
                    }
                } else {
                    throw new Error(result.message || 'Unknown error occurred');
                }
                
            } catch (error) {
                console.error('Error saving metric:', error);
                alert(`Error ${isEditMode ? 'updating' : 'creating'} metric: ${error.message}`);
            }
        }

        function closeMetricDefinitionModal() {
            const modal = document.getElementById('metricDefinitionModal');
            const form = document.getElementById('metricDefinitionForm');
            
            if (modal) {
                modal.style.display = 'none';
            }
            
            if (form) {
                form.reset();
            }
            
            const editModeInput = document.getElementById('isEditMode');
            if (editModeInput) {
                editModeInput.value = 'false';
            }
            
            const modalTitle = document.getElementById('metricModalTitle');
            if (modalTitle) {
                modalTitle.textContent = 'Define New Metric';
            }
            
            // Reset the read-only state of the ID field
            const metricIdField = document.getElementById('metricId');
            if (metricIdField) {
                metricIdField.readOnly = false;
            }
        }

        async function deleteMetric() {
            const metricId = document.getElementById('metric-select').value;
            if (!metricId || metricId === 'all') {
                alert('Please select a specific metric to delete');
                return;
            }
            
            // Find the metric name for confirmation
            const metric = metrics.find(m => m.id == metricId);
            if (!metric) {
                alert('Selected metric not found');
                return;
            }
            
            // Show confirmation dialog
            const confirmMessage = `Are you sure you want to delete metric "${metric.name}" (ID: ${metricId})?\n\nThis will deactivate the metric but preserve its data. To permanently delete, use the hard delete option.`;
            const confirmed = confirm(confirmMessage);
            
            if (!confirmed) {
                return;
            }
            
            try {
                // Show loading state
                const deleteBtn = document.getElementById('delete-metric-btn');
                const originalText = deleteBtn.textContent;
                deleteBtn.textContent = 'Deleting...';
                deleteBtn.disabled = true;
                
                // Call the delete API
                const response = await fetch(`/api/metrics/${metricId}`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || `HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    alert(`Metric "${metric.name}" has been successfully deleted!`);
                    
                    // Reload metrics list to reflect changes
                    await loadMetrics();
                    
                    // Reset metric selection
                    document.getElementById('metric-select').value = 'all';
                    document.getElementById('metric-select').dispatchEvent(new Event('change'));
                    
                    // Clear loaded modules tracking to force reload
                    loadedModules.clear();
                    
                    console.log('Metric deleted successfully:', result.message);
                } else {
                    throw new Error(result.message || 'Unknown error occurred');
                }
                
            } catch (error) {
                console.error('Error deleting metric:', error);
                alert(`Error deleting metric: ${error.message}`);
            } finally {
                // Reset button state
                const deleteBtn = document.getElementById('delete-metric-btn');
                deleteBtn.textContent = 'Delete Metric';
                deleteBtn.disabled = false;
            }
        }

        function openMetricReorderModal() {
            document.getElementById('metricReorderModal').style.display = 'block';
            loadMetricsForReordering();
        }

        function closeMetricReorderModal() {
            document.getElementById('metricReorderModal').style.display = 'none';
        }
        
        // Load metrics data
        async function loadMetrics() {
            try {
                const response = await fetch('/api/enhanced-queries');
                if (!response.ok) {
                    throw new Error('Failed to load metrics data');
                }
                
                const data = await response.json();
                metrics = [];
                
                // Extract all metrics from the data structure
                Object.entries(data).forEach(([category, categoryData]) => {
                    Object.entries(categoryData).forEach(([subcategory, subcategoryData]) => {
                        if (subcategoryData.queries) {
                            Object.entries(subcategoryData.queries).forEach(([metricName, metricData]) => {
                                metrics.push({
                                    id: metricData.id,
                                    name: metricName,
                                    category: category,
                                    subcategory: subcategory,
                                    endpoint: metricData.endpoint,
                                    is_active: metricData.is_active,
                                    display_order: metricData.display_order || 999,
                                    most_recent_data_date: metricData.most_recent_data_date
                                });
                            });
                        }
                    });
                });
                
                // Sort metrics by display_order, then by ID
                metrics.sort((a, b) => {
                    const orderA = a.display_order || 999;
                    const orderB = b.display_order || 999;
                    if (orderA !== orderB) {
                        return orderA - orderB;
                    }
                    return a.id - b.id;
                });
                
                // Group metrics by category and active status
                const groupedMetrics = metrics.reduce((acc, metric) => {
                    if (!acc[metric.category]) {
                        acc[metric.category] = {
                            active: [],
                            inactive: []
                        };
                    }
                    if (metric.is_active) {
                        acc[metric.category].active.push(metric);
                    } else {
                        acc[metric.category].inactive.push(metric);
                    }
                    return acc;
                }, {});
                
                // Build the select options HTML
                let optionsHtml = '<option value="all">All Metrics</option>';
                
                // Add active metrics first
                Object.entries(groupedMetrics).forEach(([category, {active, inactive}]) => {
                    if (active.length > 0) {
                        optionsHtml += `<optgroup label="${category}">`;
                        active.forEach(metric => {
                            optionsHtml += `<option value="${metric.id}">${metric.id} - ${metric.name}</option>`;
                        });
                        optionsHtml += '</optgroup>';
                    }
                });
                
                // Add inactive metrics in grey
                Object.entries(groupedMetrics).forEach(([category, {active, inactive}]) => {
                    if (inactive.length > 0) {
                        optionsHtml += `<optgroup label="${category} (Inactive)" style="color: #6c757d; font-style: italic;">`;
                        inactive.forEach(metric => {
                            optionsHtml += `<option value="${metric.id}" style="color: #6c757d; font-style: italic;">${metric.id} - ${metric.name}</option>`;
                        });
                        optionsHtml += '</optgroup>';
                    }
                });
                
                // Update the select element
                document.getElementById('metric-select').innerHTML = optionsHtml;
                
                // Add event listener for metric selection
                document.getElementById('metric-select').addEventListener('change', function() {
                    const selectedMetric = this.value;
                    updateChartButtonsVisibility(selectedMetric);
                    displayMetricInfo(selectedMetric);
                });
                
            } catch (error) {
                console.error('Error loading metrics:', error);
                document.getElementById('metric-select').innerHTML = '<option value="">Error loading metrics</option>';
            }
        }
        
        // Function to show/hide chart buttons based on metric selection
        function updateChartButtonsVisibility(selectedMetric) {
            const chartButtons = document.querySelectorAll('.header-chart-btn');
            
            if (selectedMetric && selectedMetric !== 'all') {
                // Show all chart buttons when a specific metric is selected
                chartButtons.forEach(btn => {
                    btn.classList.add('visible');
                });
            } else {
                // Hide all chart buttons when no metric or "all" is selected
                chartButtons.forEach(btn => {
                    btn.classList.remove('visible');
                });
            }
        }
        
        // Function to display metric information including most recent data date
        function displayMetricInfo(selectedMetricId) {
            const metricHeaderDiv = document.getElementById('metric-header');
            const metricHeaderContentDiv = document.getElementById('metric-header-content');
            
            if (selectedMetricId === 'all' || !selectedMetricId) {
                metricHeaderDiv.style.display = 'none';
                return;
            }
            
            // Find the selected metric in the metrics array
            const selectedMetric = metrics.find(m => m.id == selectedMetricId);
            if (!selectedMetric) {
                metricHeaderDiv.style.display = 'none';
                return;
            }
            
            // Format the most recent data date
            let dateInfo = '';
            if (selectedMetric.most_recent_data_date) {
                // Parse the date string and treat it as local time to avoid timezone issues
                const [year, month, day] = selectedMetric.most_recent_data_date.split('-').map(Number);
                const date = new Date(year, month - 1, day); // month is 0-indexed in JavaScript
                const formattedDate = date.toLocaleDateString('en-US', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                dateInfo = `<span class="metric-date">${formattedDate}</span>`;
            } else {
                dateInfo = '<span class="metric-date unavailable">Not available</span>';
            }
            
            // Build the metric header HTML
            const headerHtml = `
                <div class="metric-header-row">
                    <div class="metric-date-section">
                        <span class="metric-date-label">Data as of:</span>
                        ${dateInfo}
                    </div>
                    <div class="metric-details-section">
                        <span class="metric-id">ID: ${selectedMetric.id}</span>
                        <span class="metric-category">${selectedMetric.category} > ${selectedMetric.subcategory}</span>
                        <span class="metric-endpoint">${selectedMetric.endpoint}</span>
                    </div>
                </div>
            `;
            
            metricHeaderContentDiv.innerHTML = headerHtml;
            metricHeaderDiv.style.display = 'block';
        }
        
        // Metric reordering functionality
        async function loadMetricsForReordering() {
            try {
                const loadingState = document.getElementById('reorderLoadingState');
                const reorderList = document.getElementById('metricReorderList');
                
                // Show loading state
                loadingState.style.display = 'block';
                reorderList.innerHTML = '';
                
                // Fetch metrics with their current display order
                const response = await fetch('/api/metrics-with-order');
                if (!response.ok) {
                    throw new Error(`Failed to fetch metrics: ${response.status}`);
                }
                
                const data = await response.json();
                if (data.status !== 'success') {
                    throw new Error(`API error: ${data.message}`);
                }
                
                const metrics = data.metrics || [];
                
                // Group metrics by category
                const groupedMetrics = metrics.reduce((acc, metric) => {
                    if (!acc[metric.category]) {
                        acc[metric.category] = [];
                    }
                    acc[metric.category].push(metric);
                    return acc;
                }, {});
                
                // Build the reorder list HTML
                let reorderHtml = '';
                Object.entries(groupedMetrics).forEach(([category, categoryMetrics]) => {
                    // Sort metrics within category by display_order, then by ID
                    categoryMetrics.sort((a, b) => {
                        const orderA = a.display_order || 999;
                        const orderB = b.display_order || 999;
                        if (orderA !== orderB) {
                            return orderA - orderB;
                        }
                        return a.id - b.id;
                    });
                    
                    reorderHtml += `<li class="reorder-category-header">${category}</li>`;
                    
                    categoryMetrics.forEach((metric, index) => {
                        const isActive = metric.is_active ? 'active' : 'inactive';
                        const statusText = metric.is_active ? 'Active' : 'Inactive';
                        const displayOrder = metric.display_order || 999;
                        
                        reorderHtml += `
                            <li class="reorder-item ${isActive}" data-metric-id="${metric.id}" data-display-order="${displayOrder}">
                                <div class="reorder-item-info">
                                    <div class="reorder-item-title">
                                        <strong>${metric.name}</strong>
                                        <span class="metric-status ${isActive}">${statusText}</span>
                                    </div>
                                    <div class="reorder-item-details">
                                        <span class="metric-id">ID: ${metric.id}</span>
                                        <span class="metric-subcategory">${metric.subcategory}</span>
                                        <span class="metric-endpoint">${metric.endpoint}</span>
                                        <span class="metric-order">Order: ${displayOrder}</span>
                                    </div>
                                </div>
                                <div class="reorder-item-controls">
                                    <button type="button" class="reorder-btn" onclick="moveMetricUp(${metric.id})" ${index === 0 ? 'disabled' : ''}>
                                        ↑
                                    </button>
                                    <button type="button" class="reorder-btn" onclick="moveMetricDown(${metric.id})" ${index === categoryMetrics.length - 1 ? 'disabled' : ''}>
                                        ↓
                                    </button>
                                </div>
                            </li>
                        `;
                    });
                });
                
                reorderList.innerHTML = reorderHtml;
                
                // Hide loading state
                loadingState.style.display = 'none';
                
            } catch (error) {
                console.error('Error loading metrics for reordering:', error);
                const reorderList = document.getElementById('metricReorderList');
                reorderList.innerHTML = `
                    <li style="color: #dc3545; padding: 20px; text-align: center;">
                        Error loading metrics: ${error.message}
                    </li>
                `;
                document.getElementById('reorderLoadingState').style.display = 'none';
            }
        }
        
        async function saveMetricOrder() {
            try {
                const saveBtn = document.querySelector('#metricReorderModal .save-btn');
                const originalText = saveBtn.textContent;
                
                // Show loading state
                saveBtn.disabled = true;
                saveBtn.textContent = 'Saving...';
                
                // Collect all metrics with their current display_order
                const metricItems = document.querySelectorAll('#metricReorderList .reorder-item');
                const metrics = [];
                
                metricItems.forEach((item, index) => {
                    const metricId = parseInt(item.dataset.metricId);
                    const displayOrder = parseInt(item.dataset.displayOrder);
                    metrics.push({
                        id: metricId,
                        display_order: displayOrder
                    });
                });
                
                // Send update request to backend
                const response = await fetch('/api/update-metric-order', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        metrics: metrics
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || `HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    // Show success message
                    alert(`✅ Successfully updated display order for ${metrics.length} metrics!`);
                    
                    // Reload the main metrics list to reflect changes
                    await loadMetrics();
                    
                    // Close the modal
                    closeMetricReorderModal();
                } else {
                    throw new Error(result.message || 'Unknown error occurred');
                }
                
            } catch (error) {
                console.error('Error saving metric order:', error);
                alert(`❌ Error saving metric order: ${error.message}`);
            } finally {
                // Reset button state
                const saveBtn = document.querySelector('#metricReorderModal .save-btn');
                saveBtn.disabled = false;
                saveBtn.textContent = originalText;
            }
        }
        
        function moveMetricUp(metricId) {
            const currentItem = document.querySelector(`[data-metric-id="${metricId}"]`);
            const prevItem = currentItem.previousElementSibling;
            
            // Skip category headers
            if (prevItem && !prevItem.classList.contains('reorder-category-header')) {
                // Swap display_order values
                const currentOrder = parseInt(currentItem.dataset.displayOrder);
                const prevOrder = parseInt(prevItem.dataset.displayOrder);
                
                currentItem.dataset.displayOrder = prevOrder;
                prevItem.dataset.displayOrder = currentOrder;
                
                // Update the order display
                currentItem.querySelector('.metric-order').textContent = `Order: ${prevOrder}`;
                prevItem.querySelector('.metric-order').textContent = `Order: ${currentOrder}`;
                
                // Move the DOM elements
                currentItem.parentNode.insertBefore(currentItem, prevItem);
                
                // Update button states
                updateReorderButtonStates();
            }
        }
        
        function moveMetricDown(metricId) {
            const currentItem = document.querySelector(`[data-metric-id="${metricId}"]`);
            const nextItem = currentItem.nextElementSibling;
            
            // Skip category headers
            if (nextItem && !nextItem.classList.contains('reorder-category-header')) {
                // Swap display_order values
                const currentOrder = parseInt(currentItem.dataset.displayOrder);
                const nextOrder = parseInt(nextItem.dataset.displayOrder);
                
                currentItem.dataset.displayOrder = nextOrder;
                nextItem.dataset.displayOrder = currentOrder;
                
                // Update the order display
                currentItem.querySelector('.metric-order').textContent = `Order: ${nextOrder}`;
                nextItem.querySelector('.metric-order').textContent = `Order: ${currentOrder}`;
                
                // Move the DOM elements
                currentItem.parentNode.insertBefore(nextItem, currentItem);
                
                // Update button states
                updateReorderButtonStates();
            }
        }
        
        function updateReorderButtonStates() {
            const metricItems = document.querySelectorAll('#metricReorderList .reorder-item');
            
            metricItems.forEach((item, index) => {
                const upBtn = item.querySelector('.reorder-btn:first-child');
                const downBtn = item.querySelector('.reorder-btn:last-child');
                
                // Find the previous and next items (skipping category headers)
                let prevItem = item.previousElementSibling;
                while (prevItem && prevItem.classList.contains('reorder-category-header')) {
                    prevItem = prevItem.previousElementSibling;
                }
                
                let nextItem = item.nextElementSibling;
                while (nextItem && nextItem.classList.contains('reorder-category-header')) {
                    nextItem = nextItem.nextElementSibling;
                }
                
                // Update button states
                upBtn.disabled = !prevItem;
                downBtn.disabled = !nextItem;
            });
        }
        
        async function loadColumns(metricId) {
            try {
                // Find the metric to get its endpoint
                const metric = metrics.find(m => m.id == metricId);
                if (!metric) {
                    console.error('Metric not found:', metricId);
                    return;
                }
                
                const endpoint = metric.endpoint;
                console.log('Loading columns for metric:', metricId, 'endpoint:', endpoint);
                
                // Show loading state
                const columnGrid = document.getElementById('column-grid');
                columnGrid.innerHTML = '<div class="spinner"></div> Loading columns...';
                
                // Fetch available columns from the dataset
                const columnsResponse = await fetch(`/backend/get-endpoint-columns/${endpoint}`);
                if (!columnsResponse.ok) {
                    throw new Error(`Failed to fetch columns: ${columnsResponse.status}`);
                }
                
                const columnsData = await columnsResponse.json();
                if (columnsData.status !== 'success') {
                    throw new Error(`API error: ${columnsData.message}`);
                }
                
                const availableColumns = columnsData.columns || [];
                
                // Fetch currently selected columns for this metric
                const selectedResponse = await fetch(`/backend/get-selected-columns/${endpoint}?metric_id=${metricId}`);
                if (!selectedResponse.ok) {
                    throw new Error(`Failed to fetch selected columns: ${selectedResponse.status}`);
                }
                
                const selectedData = await selectedResponse.json();
                if (selectedData.status !== 'success') {
                    throw new Error(`API error: ${selectedData.message}`);
                }
                
                const selectedColumns = selectedData.columns || [];
                
                // Create checkboxes for each column
                let columnsHtml = '';
                availableColumns.forEach(column => {
                    const isChecked = selectedColumns.includes(column);
                    columnsHtml += `
                        <div class="column-item">
                            <input type="checkbox" id="col-${column}" value="${column}" ${isChecked ? 'checked' : ''}>
                            <label for="col-${column}">${column}</label>
                        </div>
                    `;
                });
                
                columnGrid.innerHTML = columnsHtml;
                
                // Remove existing event listeners to prevent duplicates
                const selectAllBtn = document.getElementById('select-all-columns');
                const deselectAllBtn = document.getElementById('deselect-all-columns');
                const updateBtn = document.getElementById('update-columns');
                
                // Clone and replace elements to remove old event listeners
                const newSelectAllBtn = selectAllBtn.cloneNode(true);
                const newDeselectAllBtn = deselectAllBtn.cloneNode(true);
                const newUpdateBtn = updateBtn.cloneNode(true);
                
                selectAllBtn.parentNode.replaceChild(newSelectAllBtn, selectAllBtn);
                deselectAllBtn.parentNode.replaceChild(newDeselectAllBtn, deselectAllBtn);
                updateBtn.parentNode.replaceChild(newUpdateBtn, updateBtn);
                
                // Add event listeners for select all/deselect all buttons
                newSelectAllBtn.addEventListener('click', selectAllColumns);
                newDeselectAllBtn.addEventListener('click', deselectAllColumns);
                newUpdateBtn.addEventListener('click', () => updateColumns(metricId, endpoint));
                
                console.log('Columns loaded successfully');
                
            } catch (error) {
                console.error('Error loading columns:', error);
                const columnGrid = document.getElementById('column-grid');
                columnGrid.innerHTML = `<div style="color: #dc3545;">Error loading columns: ${error.message}</div>`;
            }
        }
        
        function selectAllColumns() {
            const checkboxes = document.querySelectorAll('#column-grid input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = true;
            });
        }
        
        function deselectAllColumns() {
            const checkboxes = document.querySelectorAll('#column-grid input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
                checkbox.checked = false;
            });
        }
        
        async function updateColumns(metricId, endpoint) {
            try {
                const updateBtn = document.getElementById('update-columns');
                const statusDiv = document.getElementById('column-update-status');
                
                // Show loading state
                updateBtn.disabled = true;
                updateBtn.textContent = 'Updating...';
                statusDiv.style.display = 'block';
                statusDiv.innerHTML = '<div class="spinner"></div> Updating columns...';
                
                // Get selected columns
                const checkboxes = document.querySelectorAll('#column-grid input[type="checkbox"]:checked');
                const selectedColumns = Array.from(checkboxes).map(checkbox => checkbox.value);
                
                console.log('Updating columns for metric:', metricId, 'selected columns:', selectedColumns);
                
                // Send update request to backend
                const response = await fetch('/backend/update-selected-columns', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        endpoint: endpoint,
                        metric_id: metricId,
                        columns: selectedColumns
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || `HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    statusDiv.innerHTML = `
                        <div style="color: #28a745;">
                            ✅ Successfully updated ${selectedColumns.length} columns for metric ${metricId}
                        </div>
                    `;
                    console.log('Columns updated successfully:', result.message);
                } else {
                    throw new Error(result.message || 'Unknown error occurred');
                }
                
            } catch (error) {
                console.error('Error updating columns:', error);
                const statusDiv = document.getElementById('column-update-status');
                statusDiv.innerHTML = `
                    <div style="color: #dc3545;">
                        ❌ Error updating columns: ${error.message}
                    </div>
                `;
            } finally {
                // Reset button state
                const updateBtn = document.getElementById('update-columns');
                updateBtn.disabled = false;
                updateBtn.textContent = 'Update Enhanced Queries';
            }
        }
        
        // Generate metrics functionality
        async function generateMetrics() {
            const periodType = document.getElementById('period-type-select').value;
            const metricId = document.getElementById('metric-select').value;
            const districtId = document.getElementById('district-select').value;
            const generateMetricsBtn = document.getElementById('generate-metrics-btn');
            const progressContainer = document.getElementById('generate-progress');
            const progressBar = progressContainer?.querySelector('.progress-bar-fill');
            const progressStatus = progressContainer?.querySelector('.progress-status');
            const progressLog = document.getElementById('progress-log');
            const generateStatus = document.getElementById('generate-status');
            
            // Check if required elements exist
            if (!progressContainer || !progressBar || !progressStatus) {
                console.error('Required progress elements not found:', {
                    progressContainer: !!progressContainer,
                    progressBar: !!progressBar,
                    progressStatus: !!progressStatus
                });
                alert('Error: Progress UI elements not found. Please refresh the page and try again.');
                return;
            }
            
            // Check if we're running all metrics for weekly analysis
            if (metricId === 'all' && periodType === 'week') {
                try {
                    // Reset and show progress UI
                    generateMetricsBtn.classList.add('loading');
                    generateMetricsBtn.disabled = true;
                    progressContainer.style.display = 'block';
                    progressBar.style.width = '0%';
                    progressStatus.textContent = 'Initializing weekly analysis for all metrics...';
                    progressLog.innerHTML = '';
                    
                    // Add initial log entry
                    addLogEntry('Starting weekly analysis for all metrics...', 'info');
                    
                    // Get all active metrics
                    const metricsResponse = await fetch('/api/enhanced-queries');
                    if (!metricsResponse.ok) {
                        throw new Error('Failed to load metrics data');
                    }
                    
                    const metricsData = await metricsResponse.json();
                    const allMetrics = [];
                    
                    // Extract all active metrics from the data structure
                    Object.entries(metricsData).forEach(([category, categoryData]) => {
                        Object.entries(categoryData).forEach(([subcategory, subcategoryData]) => {
                            if (subcategoryData.queries) {
                                Object.entries(subcategoryData.queries).forEach(([metricName, metricData]) => {
                                    if (metricData.is_active) {
                                        allMetrics.push({
                                            id: metricData.id,
                                            name: metricName
                                        });
                                    }
                                });
                            }
                        });
                    });
                    
                    // Sort metrics by display_order, then by ID
                    allMetrics.sort((a, b) => {
                        const orderA = a.display_order || 999;
                        const orderB = b.display_order || 999;
                        if (orderA !== orderB) {
                            return orderA - orderB;
                        }
                        return a.id - b.id;
                    });
                    
                    addLogEntry(`Found ${allMetrics.length} active metrics to process`, 'info');
                    
                    // Process each metric individually
                    let successful = 0;
                    let failed = 0;
                    
                    for (let i = 0; i < allMetrics.length; i++) {
                        const metric = allMetrics[i];
                        const progressPercent = ((i + 1) / allMetrics.length) * 100;
                        
                        progressStatus.textContent = `Processing metric ${i + 1}/${allMetrics.length}: ${metric.name}`;
                        updateProgressBar(progressBar, `${progressPercent}%`);
                        addLogEntry(`Starting weekly analysis for metric ${metric.id} (${metric.name})...`, 'info');
                        
                        try {
                            const response = await fetch(`/backend/run_specific_metric?metric_id=${metric.id}&district_id=${districtId}&period_type=week`);
                            const data = await response.json();
                            
                            if (data.status === 'success') {
                                successful++;
                                addLogEntry(`✅ Completed weekly analysis for metric ${metric.id} (${metric.name})`, 'success');
                            } else {
                                failed++;
                                addLogEntry(`❌ Failed weekly analysis for metric ${metric.id} (${metric.name}): ${data.message}`, 'error');
                            }
                        } catch (error) {
                            failed++;
                            addLogEntry(`❌ Error processing metric ${metric.id} (${metric.name}): ${error.message}`, 'error');
                        }
                    }
                    
                    updateProgressBar(progressBar, '100%');
                    progressStatus.textContent = 'Weekly analysis completed for all metrics';
                    addLogEntry(`Weekly analysis completed. Successful: ${successful}, Failed: ${failed}`, 'success');
                    
                                    updateGenerateStatus(generateStatus, `
                    <div style="color: #28a745;">
                        <h4>✅ Weekly Analysis Complete</h4>
                        <p>Weekly analysis completed for all metrics</p>
                        <p>Successful: ${successful}, Failed: ${failed}</p>
                        <p><a href="/weekly-report" target="_blank">View Weekly Report</a></p>
                    </div>
                `);
                    
                } catch (error) {
                    console.error('Error generating weekly analysis for all metrics:', error);
                    updateProgressBar(progressBar, '100%', '#dc3545');
                    progressStatus.textContent = `Error: ${error.message}`;
                    addLogEntry(`Error: ${error.message}`, 'error');
                    
                    updateGenerateStatus(generateStatus, `
                        <div style="color: #dc3545;">
                            <h4>❌ Error</h4>
                            <p>An error occurred while generating weekly analysis: ${error.message}</p>
                        </div>
                    `);
                } finally {
                    generateMetricsBtn.classList.remove('loading');
                    generateMetricsBtn.disabled = false;
                }
                return;
            }
            
            // Check if we're running all metrics for monthly analysis
            if (metricId === 'all' && periodType === 'month') {
                try {
                    // Reset and show progress UI
                    generateMetricsBtn.classList.add('loading');
                    generateMetricsBtn.disabled = true;
                    progressContainer.style.display = 'block';
                    updateProgressBar(progressBar, '0%');
                    progressStatus.textContent = 'Initializing monthly analysis for all metrics...';
                    progressLog.innerHTML = '';
                    
                    // Add initial log entry
                    addLogEntry('Starting monthly analysis for all metrics...', 'info');
                    
                    // Get all active metrics
                    const metricsResponse = await fetch('/api/enhanced-queries');
                    if (!metricsResponse.ok) {
                        throw new Error('Failed to load metrics data');
                    }
                    
                    const metricsData = await metricsResponse.json();
                    const allMetrics = [];
                    
                    // Extract all active metrics from the data structure
                    Object.entries(metricsData).forEach(([category, categoryData]) => {
                        Object.entries(categoryData).forEach(([subcategory, subcategoryData]) => {
                            if (subcategoryData.queries) {
                                Object.entries(subcategoryData.queries).forEach(([metricName, metricData]) => {
                                    if (metricData.is_active) {
                                        allMetrics.push({
                                            id: metricData.id,
                                            name: metricName
                                        });
                                    }
                                });
                            }
                        });
                    });
                    
                    // Sort metrics by display_order, then by ID
                    allMetrics.sort((a, b) => {
                        const orderA = a.display_order || 999;
                        const orderB = b.display_order || 999;
                        if (orderA !== orderB) {
                            return orderA - orderB;
                        }
                        return a.id - b.id;
                    });
                    
                    addLogEntry(`Found ${allMetrics.length} active metrics to process`, 'info');
                    
                    // Process each metric individually
                    let successful = 0;
                    let failed = 0;
                    
                    for (let i = 0; i < allMetrics.length; i++) {
                        const metric = allMetrics[i];
                        const progressPercent = ((i + 1) / allMetrics.length) * 100;
                        
                        progressStatus.textContent = `Processing metric ${i + 1}/${allMetrics.length}: ${metric.name}`;
                        updateProgressBar(progressBar, `${progressPercent}%`);
                        addLogEntry(`Starting monthly analysis for metric ${metric.id} (${metric.name})...`, 'info');
                        
                        try {
                            const response = await fetch(`/backend/run_specific_metric?metric_id=${metric.id}&district_id=${districtId}&period_type=month`);
                            const data = await response.json();
                            
                            if (data.status === 'success') {
                                successful++;
                                addLogEntry(`✅ Completed monthly analysis for metric ${metric.id} (${metric.name})`, 'success');
                            } else {
                                failed++;
                                addLogEntry(`❌ Failed monthly analysis for metric ${metric.id} (${metric.name}): ${data.message}`, 'error');
                            }
                        } catch (error) {
                            failed++;
                            addLogEntry(`❌ Error processing metric ${metric.id} (${metric.name}): ${error.message}`, 'error');
                        }
                    }
                    
                    updateProgressBar(progressBar, '100%');
                    progressStatus.textContent = 'Monthly analysis completed for all metrics';
                    addLogEntry(`Monthly analysis completed. Successful: ${successful}, Failed: ${failed}`, 'success');
                    
                    generateStatus.innerHTML = `
                        <div style="color: #28a745;">
                            <h4>✅ Monthly Analysis Complete</h4>
                            <p>Monthly analysis completed for all metrics</p>
                            <p>Successful: ${successful}, Failed: ${failed}</p>
                            <p><a href="/monthly-report" target="_blank">View Monthly Report</a></p>
                        </div>
                    `;
                    
                } catch (error) {
                    console.error('Error generating monthly analysis for all metrics:', error);
                    updateProgressBar(progressBar, '100%', '#dc3545');
                    progressStatus.textContent = `Error: ${error.message}`;
                    addLogEntry(`Error: ${error.message}`, 'error');
                    
                    generateStatus.innerHTML = `
                        <div style="color: #dc3545;">
                            <h4>❌ Error</h4>
                            <p>An error occurred while generating monthly analysis: ${error.message}</p>
                        </div>
                    `;
                } finally {
                    generateMetricsBtn.classList.remove('loading');
                    generateMetricsBtn.disabled = false;
                }
                return;
            }
            
            // Check if we're running all metrics for annual analysis
            if (metricId === 'all' && periodType === 'year') {
                try {
                    // Reset and show progress UI
                    generateMetricsBtn.classList.add('loading');
                    generateMetricsBtn.disabled = true;
                    progressContainer.style.display = 'block';
                    progressBar.style.width = '0%';
                    progressStatus.textContent = 'Initializing annual analysis for all metrics...';
                    progressLog.innerHTML = '';
                    
                    // Add initial log entry
                    addLogEntry('Starting annual analysis for all metrics...', 'info');
                    
                    // Get all active metrics
                    const metricsResponse = await fetch('/api/enhanced-queries');
                    if (!metricsResponse.ok) {
                        throw new Error('Failed to load metrics data');
                    }
                    
                    const metricsData = await metricsResponse.json();
                    const allMetrics = [];
                    
                    // Extract all active metrics from the data structure
                    Object.entries(metricsData).forEach(([category, categoryData]) => {
                        Object.entries(categoryData).forEach(([subcategory, subcategoryData]) => {
                            if (subcategoryData.queries) {
                                Object.entries(subcategoryData.queries).forEach(([metricName, metricData]) => {
                                    if (metricData.is_active) {
                                        allMetrics.push({
                                            id: metricData.id,
                                            name: metricName
                                        });
                                    }
                                });
                            }
                        });
                    });
                    
                    // Sort metrics by display_order, then by ID
                    allMetrics.sort((a, b) => {
                        const orderA = a.display_order || 999;
                        const orderB = b.display_order || 999;
                        if (orderA !== orderB) {
                            return orderA - orderB;
                        }
                        return a.id - b.id;
                    });
                    
                    addLogEntry(`Found ${allMetrics.length} active metrics to process`, 'info');
                    
                    // Process each metric individually
                    let successful = 0;
                    let failed = 0;
                    
                    for (let i = 0; i < allMetrics.length; i++) {
                        const metric = allMetrics[i];
                        const progressPercent = ((i + 1) / allMetrics.length) * 100;
                        
                        progressStatus.textContent = `Processing metric ${i + 1}/${allMetrics.length}: ${metric.name}`;
                        updateProgressBar(progressBar, `${progressPercent}%`);
                        addLogEntry(`Starting annual analysis for metric ${metric.id} (${metric.name})...`, 'info');
                        
                        try {
                            const response = await fetch(`/backend/run_specific_metric?metric_id=${metric.id}&district_id=${districtId}&period_type=year`);
                            const data = await response.json();
                            
                            if (data.status === 'success') {
                                successful++;
                                addLogEntry(`✅ Completed annual analysis for metric ${metric.id} (${metric.name})`, 'success');
                            } else {
                                failed++;
                                addLogEntry(`❌ Failed annual analysis for metric ${metric.id} (${metric.name}): ${data.message}`, 'error');
                            }
                        } catch (error) {
                            failed++;
                            addLogEntry(`❌ Error processing metric ${metric.id} (${metric.name}): ${error.message}`, 'error');
                        }
                    }
                    
                    updateProgressBar(progressBar, '100%');
                    progressStatus.textContent = 'Annual analysis completed for all metrics';
                    addLogEntry(`Annual analysis completed. Successful: ${successful}, Failed: ${failed}`, 'success');
                    
                    generateStatus.innerHTML = `
                        <div style="color: #28a745;">
                            <h4>✅ Annual Analysis Complete</h4>
                            <p>Annual analysis completed for all metrics</p>
                            <p>Successful: ${successful}, Failed: ${failed}</p>
                            <p><a href="/monthly-report" target="_blank">View Monthly Report</a></p>
                        </div>
                    `;
                    
                } catch (error) {
                    console.error('Error generating annual analysis for all metrics:', error);
                    updateProgressBar(progressBar, '100%', '#dc3545');
                    progressStatus.textContent = `Error: ${error.message}`;
                    addLogEntry(`Error: ${error.message}`, 'error');
                    
                    generateStatus.innerHTML = `
                        <div style="color: #dc3545;">
                            <h4>❌ Error</h4>
                            <p>An error occurred while generating annual analysis: ${error.message}</p>
                        </div>
                    `;
                } finally {
                    generateMetricsBtn.classList.remove('loading');
                    generateMetricsBtn.disabled = false;
                }
                return;
            }
            
            // Check if we're running all metrics for YTD analysis
            if (metricId === 'all' && periodType === 'ytd') {
                try {
                    // Reset and show progress UI
                    generateMetricsBtn.classList.add('loading');
                    generateMetricsBtn.disabled = true;
                    progressContainer.style.display = 'block';
                    progressBar.style.width = '0%';
                    progressStatus.textContent = 'Initializing YTD metrics generation for all metrics...';
                    progressLog.innerHTML = '';
                    
                    // Add initial log entry
                    addLogEntry('Starting YTD metrics generation for all metrics...', 'info');
                    
                    // Get all active metrics
                    const metricsResponse = await fetch('/api/enhanced-queries');
                    if (!metricsResponse.ok) {
                        throw new Error('Failed to load metrics data');
                    }
                    
                    const metricsData = await metricsResponse.json();
                    const allMetrics = [];
                    
                    // Extract all active metrics from the data structure
                    Object.entries(metricsData).forEach(([category, categoryData]) => {
                        Object.entries(categoryData).forEach(([subcategory, subcategoryData]) => {
                            if (subcategoryData.queries) {
                                Object.entries(subcategoryData.queries).forEach(([metricName, metricData]) => {
                                    if (metricData.is_active) {
                                        allMetrics.push({
                                            id: metricData.id,
                                            name: metricName
                                        });
                                    }
                                });
                            }
                        });
                    });
                    
                    // Sort metrics by display_order, then by ID
                    allMetrics.sort((a, b) => {
                        const orderA = a.display_order || 999;
                        const orderB = b.display_order || 999;
                        if (orderA !== orderB) {
                            return orderA - orderB;
                        }
                        return a.id - b.id;
                    });
                    
                    addLogEntry(`Found ${allMetrics.length} active metrics to process`, 'info');
                    
                    // Process each metric individually
                    let successful = 0;
                    let failed = 0;
                    
                    for (let i = 0; i < allMetrics.length; i++) {
                        const metric = allMetrics[i];
                        const progressPercent = ((i + 1) / allMetrics.length) * 100;
                        
                        progressStatus.textContent = `Processing metric ${i + 1}/${allMetrics.length}: ${metric.name}`;
                        updateProgressBar(progressBar, `${progressPercent}%`);
                        addLogEntry(`Starting YTD metrics generation for metric ${metric.id} (${metric.name})...`, 'info');
                        
                        try {
                            const response = await fetch(`/backend/run_specific_metric?metric_id=${metric.id}&district_id=${districtId}&period_type=ytd`);
                            const data = await response.json();
                            
                            if (data.status === 'success') {
                                successful++;
                                addLogEntry(`✅ Completed YTD metrics generation for metric ${metric.id} (${metric.name})`, 'success');
                            } else {
                                failed++;
                                addLogEntry(`❌ Failed YTD metrics generation for metric ${metric.id} (${metric.name}): ${data.message}`, 'error');
                            }
                        } catch (error) {
                            failed++;
                            addLogEntry(`❌ Error processing metric ${metric.id} (${metric.name}): ${error.message}`, 'error');
                        }
                    }
                    
                    updateProgressBar(progressBar, '100%');
                    progressStatus.textContent = 'YTD metrics generation completed for all metrics';
                    addLogEntry(`YTD metrics generation completed. Successful: ${successful}, Failed: ${failed}`, 'success');
                    
                    generateStatus.innerHTML = `
                        <div style="color: #28a745;">
                            <h4>✅ YTD Metrics Generation Complete</h4>
                            <p>YTD metrics generation completed for all metrics</p>
                            <p>Successful: ${successful}, Failed: ${failed}</p>
                            <p><a href="/dashboard" target="_blank">View Dashboard</a></p>
                        </div>
                    `;
                    
                } catch (error) {
                    console.error('Error generating YTD metrics for all metrics:', error);
                    updateProgressBar(progressBar, '100%', '#dc3545');
                    progressStatus.textContent = `Error: ${error.message}`;
                    addLogEntry(`Error: ${error.message}`, 'error');
                    
                    generateStatus.innerHTML = `
                        <div style="color: #dc3545;">
                            <h4>❌ Error</h4>
                            <p>An error occurred while generating YTD metrics: ${error.message}</p>
                        </div>
                    `;
                } finally {
                    generateMetricsBtn.classList.remove('loading');
                    generateMetricsBtn.disabled = false;
                }
                return;
            }
            
            // Original logic for specific metrics
            if (!metricId || metricId === 'all') {
                if (generateStatus) {
                    generateStatus.style.display = 'block';
                                    updateGenerateStatus(generateStatus, `
                    <div style="color: #dc3545;">
                        <h4>❌ Error</h4>
                        <p>Please select a specific metric first</p>
                    </div>
                `);
                }
                return;
            }
            
            try {
                // Reset and show progress UI
                generateMetricsBtn.classList.add('loading');
                generateMetricsBtn.disabled = true;
                progressContainer.style.display = 'block';
                updateProgressBar(progressBar, '0%');
                progressStatus.textContent = 'Initializing metric generation...';
                progressLog.innerHTML = '';
                
                // Add initial log entry
                addLogEntry('Starting metric generation process...', 'info');
                
                // Handle different period types
                if (periodType === 'both') {
                    // First run monthly analysis
                    progressStatus.textContent = 'Starting monthly analysis...';
                    updateProgressBar(progressBar, '25%');
                    addLogEntry(`Starting monthly analysis for metric ${metricId} in district ${districtId}...`, 'info');
                    
                    const monthlyResponse = await fetch('/run_specific_metric_async', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            metric_id: metricId,
                            district_id: districtId,
                            period_type: 'month'
                        })
                    });
                    const monthlyData = await monthlyResponse.json();
                    if (monthlyData.status !== 'success') {
                        throw new Error(`Monthly analysis failed: ${monthlyData.message}`);
                    }
                    
                    // Poll for monthly job completion
                    const monthlyJobId = monthlyData.job_id;
                    await pollJobCompletion(monthlyJobId, 'monthly analysis', 25, 50);
                    
                    // Then run annual analysis
                    progressStatus.textContent = 'Starting annual analysis...';
                    addLogEntry(`Starting annual analysis for metric ${metricId} in district ${districtId}...`, 'info');
                    
                    const annualResponse = await fetch('/run_specific_metric_async', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            metric_id: metricId,
                            district_id: districtId,
                            period_type: 'year'
                        })
                    });
                    const annualData = await annualResponse.json();
                    if (annualData.status !== 'success') {
                        throw new Error(`Annual analysis failed: ${annualData.message}`);
                    }
                    
                    // Poll for annual job completion
                    const annualJobId = annualData.job_id;
                    await pollJobCompletion(annualJobId, 'annual analysis', 50, 100);
                    
                    progressStatus.textContent = 'Monthly and annual analysis completed successfully';
                    generateStatus.innerHTML = `
                        <div style="color: #28a745;">
                            <h4>✅ Generation Complete</h4>
                            <p>Monthly and annual analysis completed successfully</p>
                        </div>
                    `;
                } else if (periodType === 'week') {
                    // Weekly analysis for individual metric
                    progressStatus.textContent = 'Starting weekly analysis...';
                    updateProgressBar(progressBar, '50%');
                    addLogEntry(`Starting weekly analysis for metric ${metricId} in district ${districtId}...`, 'info');
                    
                    const response = await fetch('/run_specific_metric_async', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            metric_id: metricId,
                            district_id: districtId,
                            period_type: 'week'
                        })
                    });
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        // Poll for job completion
                        const jobId = data.job_id;
                        await pollJobCompletion(jobId, 'weekly analysis', 50, 100);
                        
                        progressStatus.textContent = 'Weekly analysis completed successfully';
                        generateStatus.innerHTML = `
                            <div style="color: #28a745;">
                                <h4>✅ Weekly Analysis Complete</h4>
                                <p>Weekly analysis completed successfully</p>
                                <p><a href="/weekly-report" target="_blank">View Weekly Report</a></p>
                            </div>
                        `;
                    } else {
                        throw new Error(data.message || 'Unknown error');
                    }
                } else if (periodType === 'ytd') {
                    // YTD metrics generation for individual metric
                    progressStatus.textContent = 'Starting YTD metrics generation...';
                    updateProgressBar(progressBar, '50%');
                    addLogEntry(`Starting YTD metrics generation for metric ${metricId} in district ${districtId}...`, 'info');
                    
                    const response = await fetch('/run_specific_metric_async', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            metric_id: metricId,
                            district_id: districtId,
                            period_type: 'ytd'
                        })
                    });
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        // Poll for job completion
                        const jobId = data.job_id;
                        await pollJobCompletion(jobId, 'YTD metrics generation', 50, 100);
                        
                        progressStatus.textContent = 'YTD metrics generation completed successfully';
                        generateStatus.innerHTML = `
                            <div style="color: #28a745;">
                                <h4>✅ YTD Metrics Generation Complete</h4>
                                <p>YTD metrics generation completed successfully</p>
                                <p><a href="/dashboard" target="_blank">View Dashboard</a></p>
                            </div>
                        `;
                    } else {
                        throw new Error(data.message || 'Unknown error');
                    }
                } else {
                    // Single period type analysis
                    progressStatus.textContent = `Starting ${periodType} analysis...`;
                    updateProgressBar(progressBar, '50%');
                    addLogEntry(`Starting ${periodType} analysis for metric ${metricId} in district ${districtId}...`, 'info');
                    
                    const response = await fetch('/run_specific_metric_async', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            metric_id: metricId,
                            district_id: districtId,
                            period_type: periodType
                        })
                    });
                    const data = await response.json();
                    
                    if (data.status === 'success') {
                        // Poll for job completion
                        const jobId = data.job_id;
                        await pollJobCompletion(jobId, `${periodType} analysis`, 50, 100);
                        
                        progressStatus.textContent = `${periodType} analysis completed successfully`;
                        generateStatus.innerHTML = `
                            <div style="color: #28a745;">
                                <h4>✅ Generation Complete</h4>
                                <p>${data.message}</p>
                            </div>
                        `;
                    } else {
                        throw new Error(data.message);
                    }
                }
                
                // Reload content for any open modules
                reloadOpenModules();
                
            } catch (error) {
                console.error('Error generating metrics:', error);
                updateProgressBar(progressBar, '100%', '#dc3545');
                progressStatus.textContent = `Error: ${error.message}`;
                addLogEntry(`Error: ${error.message}`, 'error');
                
                updateGenerateStatus(generateStatus, `
                    <div style="color: #dc3545;">
                        <h4>❌ Error</h4>
                        <p>An error occurred while generating metrics: ${error.message}</p>
                    </div>
                `);
            } finally {
                generateMetricsBtn.classList.remove('loading');
                generateMetricsBtn.disabled = false;
            }
        }
        
        // Helper function to safely update progress bar
        function updateProgressBar(progressBar, width, backgroundColor = null) {
            if (progressBar && progressBar.style) {
                progressBar.style.width = width;
                if (backgroundColor) {
                    progressBar.style.backgroundColor = backgroundColor;
                }
            }
        }
        
        // Helper function to safely update generate status
        function updateGenerateStatus(generateStatus, html) {
            if (generateStatus) {
                generateStatus.style.display = 'block';
                generateStatus.innerHTML = html;
            }
        }
        
        // Function to add a log entry with timestamp
        function addLogEntry(message, type = 'info') {
            const progressLog = document.getElementById('progress-log');
            if (!progressLog) {
                console.warn('Progress log element not found, cannot add log entry');
                return;
            }
            
            const now = new Date();
            const timeString = now.toLocaleTimeString();
            
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.innerHTML = `<span class="log-time">[${timeString}]</span> ${message}`;
            
            progressLog.appendChild(logEntry);
            progressLog.scrollTop = progressLog.scrollHeight;
        }
        
        // Function to poll for job completion
        async function pollJobCompletion(jobId, jobName, startProgress, endProgress) {
            const progressContainer = document.getElementById('generate-progress');
            const progressStatus = progressContainer?.querySelector('.progress-status');
            const progressBar = progressContainer?.querySelector('.progress-bar-fill');
            
            // Check if required elements exist
            if (!progressContainer || !progressStatus || !progressBar) {
                console.error('Required progress elements not found for job polling');
                throw new Error('Progress UI elements not found');
            }
            
            return new Promise((resolve, reject) => {
                const pollInterval = setInterval(async () => {
                    try {
                        const response = await fetch(`/backend/jobs/${jobId}`);
                        const data = await response.json();
                        
                        if (data.status === 'success') {
                            const job = data.job;
                            
                            if (job.status === 'running') {
                                const progress = startProgress + (endProgress - startProgress) * (job.progress / 100);
                                updateProgressBar(progressBar, `${progress}%`);
                                progressStatus.textContent = `Running ${jobName}... (${job.progress}%)`;
                            } else if (job.status === 'completed') {
                                clearInterval(pollInterval);
                                updateProgressBar(progressBar, `${endProgress}%`);
                                progressStatus.textContent = `${jobName} completed successfully`;
                                addLogEntry(`${jobName} completed successfully`, 'success');
                                resolve(job.result);
                            } else if (job.status === 'failed') {
                                clearInterval(pollInterval);
                                throw new Error(job.error || `${jobName} failed`);
                            }
                        } else {
                            clearInterval(pollInterval);
                            throw new Error('Failed to get job status');
                        }
                    } catch (error) {
                        clearInterval(pollInterval);
                        reject(error);
                    }
                }, 2000); // Poll every 2 seconds
                
                // Set a timeout to stop polling after 10 minutes
                setTimeout(() => {
                    clearInterval(pollInterval);
                    reject(new Error(`${jobName} timed out`));
                }, 600000);
            });
        }
        
        // Charts modal functions
        function openChartsModal(periodType, chartType) {
            const metricId = document.getElementById('metric-select').value;
            const districtId = document.getElementById('district-select').value;
            
            if (!metricId || metricId === 'all') {
                alert('Please select a specific metric first');
                return;
            }
            
            // Set modal title
            const titles = {
                'time-series': 'Time Series Charts',
                'anomalies': 'Anomalies',
                'maps': 'District Maps'
            };
            
            const periodNames = {
                'annual': 'Annual',
                'monthly': 'Monthly',
                'weekly': 'Weekly',
                'day': 'Year-to-Date' // daily period used for YTD comparison
            };
            
            document.getElementById('chartsModalTitle').textContent = 
                `${periodNames[periodType]} ${titles[chartType]}`;
            
            // Show modal
            document.getElementById('chartsModal').style.display = 'block';
            
            // Load charts
            loadChartsInModal(periodType, chartType, metricId, districtId);
        }
        
        function closeChartsModal() {
            document.getElementById('chartsModal').style.display = 'none';
            document.getElementById('chartsGrid').innerHTML = '';
        }
        
        async function loadChartsInModal(periodType, chartType, metricId, districtId) {
            const chartsGrid = document.getElementById('chartsGrid');
            chartsGrid.innerHTML = '<div class="loading-charts">Loading charts...</div>';
            
            try {
                let charts = [];
                
                console.log(`Loading charts for periodType: ${periodType}, chartType: ${chartType}, metricId: ${metricId}, districtId: ${districtId}`);
                
                if (chartType === 'time-series') {
                    charts = await loadTimeSeriesChartsForModal(metricId, districtId, periodType);
                } else if (chartType === 'anomalies') {
                    charts = await loadAnomalyChartsForModal(metricId, districtId, periodType);
                } else if (chartType === 'maps') {
                    charts = await loadMapsForModal(metricId);
                }
                
                console.log(`Charts loaded: ${charts.length}`, charts);
                
                if (charts.length > 0) {
                    let chartsHtml = '';
                    
                    // Add summary section for anomalies
                    if (chartType === 'anomalies') {
                        const positiveCount = charts.filter(chart => chart.anomaly_type === 'positive').length;
                        const negativeCount = charts.filter(chart => chart.anomaly_type === 'negative').length;
                        
                        chartsHtml += `
                            <div class="anomaly-summary">
                                <h3>Anomaly Summary</h3>
                                <div class="anomaly-summary-stats">
                                    <div class="anomaly-stat">
                                        <span class="anomaly-stat-label" style="color: #28a745;">📉 Positive Anomalies:</span>
                                        <span class="anomaly-stat-count positive">${positiveCount}</span>
                                        <span class="anomaly-stat-description">(Improving trends)</span>
                                    </div>
                                    <div class="anomaly-stat">
                                        <span class="anomaly-stat-label" style="color: #dc3545;">📈 Negative Anomalies:</span>
                                        <span class="anomaly-stat-count negative">${negativeCount}</span>
                                        <span class="anomaly-stat-description">(Concerning trends)</span>
                                    </div>
                                    <div class="anomaly-stat">
                                        <span class="anomaly-stat-label" style="color: #495057;">📊 Total Anomalies:</span>
                                        <span class="anomaly-stat-count total">${charts.length}</span>
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    
                    charts.forEach(chart => {
                        chartsHtml += createChartCard(chart, chartType);
                    });
                    chartsGrid.innerHTML = chartsHtml;
                } else {
                    chartsGrid.innerHTML = '<div class="no-charts-message">No charts available for this selection</div>';
                }
                
            } catch (error) {
                console.error('Error loading charts:', error);
                chartsGrid.innerHTML = `<div class="no-charts-message">Error loading charts: ${error.message}</div>`;
            }
        }
        
        function createChartCard(chart, chartType) {
            const { id, title, url, dwUrl, anomaly_type, percent_change, period_date } = chart;
            
            // Determine CSS class for anomaly cards
            let cardClass = 'chart-card';
            if (chartType === 'anomalies' && anomaly_type) {
                cardClass += ` anomaly-${anomaly_type}`;
            }
            
            // Create additional info for anomalies
            let additionalInfo = '';
            if (chartType === 'anomalies' && (anomaly_type || percent_change || period_date)) {
                let infoParts = [];
                if (period_date) {
                    infoParts.push(`Period: ${period_date}`);
                }
                if (percent_change !== undefined && percent_change !== null) {
                    const changeText = percent_change > 0 ? `+${percent_change.toFixed(1)}%` : `${percent_change.toFixed(1)}%`;
                    const changeClass = anomaly_type === 'positive' ? 'positive' : 'negative';
                    infoParts.push(`<span class="anomaly-percent-change ${changeClass}">${changeText}</span>`);
                }
                if (infoParts.length > 0) {
                    additionalInfo = `<div class="anomaly-info">${infoParts.join(' | ')}</div>`;
                }
            }
            
            // Use onload event to adjust iframe height dynamically
            return `
                <div class="${cardClass}">
                    <div class="chart-card-header">
                        <h4>${title || `Chart ${id}`}</h4>
                        ${additionalInfo}
                    </div>
                    <div class="chart-card-body">
                        ${chartType === 'maps' ? 
                            `<iframe src="${url}" frameborder="0" style="width:100%; min-height:600px; height:600px;"></iframe>` :
                            `<iframe src="${url}" frameborder="0" onload="adjustIframeHeight(this)"></iframe>`}
                    </div>
                    <div class="chart-card-footer">
                        ${dwUrl ? `
                            <button class="chart-dw-btn" onclick="window.open('${dwUrl}', '_blank')">
                                View in Datawrapper
                            </button>
                        ` : `
                            <button class="chart-dw-btn" onclick="generateDWChart('${chartType}', ${id})">
                                Generate DW Version
                            </button>
                        `}
                    </div>
                </div>
            `;
        }
        
        // Dynamically adjust iframe height to fit its content so the full chart is visible
        function adjustIframeHeight(iframe) {
            try {
                const doc = iframe.contentDocument || iframe.contentWindow.document;
                if (doc && doc.body && doc.body.scrollHeight) {
                    // For chart-section mode, use a fixed aspect ratio
                    if (doc.body.classList.contains('chart-section-mode')) {
                        // Use 4:3 aspect ratio for chart-section mode
                        const width = iframe.offsetWidth;
                        const height = width * 0.75; // 3/4 aspect ratio
                        iframe.style.height = height + 'px';
                    } else {
                        // For full view mode, use the actual content height
                        iframe.style.height = doc.body.scrollHeight + 'px';
                    }
                }
            } catch (err) {
                console.warn('Unable to access iframe content for height adjustment:', err);
                // Fallback to fixed height for chart-section mode
                if (iframe.src && iframe.src.includes('#chart-section')) {
                    const width = iframe.offsetWidth;
                    const height = width * 0.75; // 3/4 aspect ratio
                    iframe.style.height = height + 'px';
                }
            }
        }
        
        // Chart loading functions for modal
        async function loadTimeSeriesChartsForModal(metricId, districtId, periodType) {
            try {
                // Convert period type to match API expectations
                let apiPeriodType = periodType;
                if (periodType === 'annual') apiPeriodType = 'year';
                if (periodType === 'monthly') apiPeriodType = 'month';
                if (periodType === 'weekly') apiPeriodType = 'week';
                if (periodType === 'day') apiPeriodType = 'day'; // YTD charts use 'day' period type
                
                const response = await fetch(`/backend/api/active-charts?metric_id=${metricId}&district=${districtId}&period_type=${apiPeriodType}`);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch charts: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.status === "error") {
                    throw new Error(`API error: ${data.message}`);
                }
                
                const charts = data.charts || [];
                
                // Transform charts to modal format and fetch DW URLs
                const chartsWithDW = await Promise.all(charts.map(async (chart) => {
                    let dwUrl = null;
                    
                    // Try to get DW URL from metadata
                    try {
                        const metadataResponse = await fetch(`/backend/api/chart-metadata/${chart.chart_id}`);
                        if (metadataResponse.ok) {
                            const metadataData = await metadataResponse.json();
                            if (metadataData.status === 'success' && metadataData.metadata) {
                                dwUrl = metadataData.metadata.dw_url || null;
                            }
                        }
                    } catch (error) {
                        console.warn(`Failed to fetch metadata for chart ${chart.chart_id}:`, error);
                    }
                    
                    return {
                        id: chart.chart_id,
                        title: `Time Series Chart ${chart.chart_id}`,
                        url: `/backend/time-series-chart?chart_id=${chart.chart_id}#chart-section`,
                        dwUrl: dwUrl
                    };
                }));
                
                return chartsWithDW;
                
            } catch (error) {
                console.error('Error loading time series charts:', error);
                return [];
            }
        }
        
        async function loadAnomalyChartsForModal(metricId, districtId, periodType) {
            try {
                // Convert period type to match API expectations
                let apiPeriodType = periodType;
                if (periodType === 'annual') apiPeriodType = 'year';
                if (periodType === 'monthly') apiPeriodType = 'month';
                if (periodType === 'weekly') apiPeriodType = 'week';
                if (periodType === 'day') apiPeriodType = 'day'; // YTD charts use 'day' period type
                
                console.log(`Loading anomalies for metricId: ${metricId}, districtId: ${districtId}, periodType: ${periodType}, apiPeriodType: ${apiPeriodType}`);
                
                const response = await fetch(`/anomaly-analyzer/api/query-anomalies?object_id=${metricId}&district=${districtId}&period_type=${apiPeriodType}&only_anomalies=true&only_active=true&limit=10`);
                
                if (!response.ok) {
                    throw new Error(`Failed to fetch anomalies: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('API response data:', data);
                
                if (data.status === "error") {
                    throw new Error(`API error: ${data.message}`);
                }
                
                // Handle new API format with positive_anomalies and negative_anomalies arrays
                let allAnomalies = [];
                
                // Add positive anomalies (good news - crime going down)
                if (data.positive_anomalies && Array.isArray(data.positive_anomalies)) {
                    console.log(`Found ${data.positive_anomalies.length} positive anomalies`);
                    allAnomalies = allAnomalies.concat(data.positive_anomalies.map(anomaly => ({
                        ...anomaly,
                        anomaly_type: 'positive'
                    })));
                }
                
                // Add negative anomalies (bad news - crime going up)
                if (data.negative_anomalies && Array.isArray(data.negative_anomalies)) {
                    console.log(`Found ${data.negative_anomalies.length} negative anomalies`);
                    allAnomalies = allAnomalies.concat(data.negative_anomalies.map(anomaly => ({
                        ...anomaly,
                        anomaly_type: 'negative'
                    })));
                }
                
                // Fallback to old format if new format is not present
                if (allAnomalies.length === 0 && data.anomalies && Array.isArray(data.anomalies)) {
                    console.log(`Found ${data.anomalies.length} anomalies in old format`);
                    allAnomalies = data.anomalies.map(anomaly => ({
                        ...anomaly,
                        anomaly_type: 'unknown'
                    }));
                }
                
                console.log(`Total anomalies found: ${allAnomalies.length}`);
                
                // Transform anomalies to modal format
                const transformedAnomalies = allAnomalies.map(anomaly => {
                    // Check if DW URL exists in metadata
                    let dwUrl = null;
                    if (anomaly.metadata && typeof anomaly.metadata === 'object') {
                        dwUrl = anomaly.metadata.dw_url || null;
                    }
                    
                    // Create a descriptive title based on the anomaly data
                    let title = `Anomaly ${anomaly.id}`;
                    if (anomaly.group_value) {
                        title += ` - ${anomaly.group_value}`;
                    }
                    if (anomaly.group_field_name) {
                        title += ` (${anomaly.group_field_name})`;
                    }
                    if (anomaly.anomaly_type === 'positive') {
                        title += ' 📉'; // Down arrow for positive (good) anomalies
                    } else if (anomaly.anomaly_type === 'negative') {
                        title += ' 📈'; // Up arrow for negative (bad) anomalies
                    }
                    
                    return {
                        id: anomaly.id,
                        title: title,
                        url: `/anomaly-analyzer/anomaly-chart?id=${anomaly.id}#chart-section`,
                        dwUrl: dwUrl,
                        anomaly_type: anomaly.anomaly_type,
                        percent_change: anomaly.percent_change,
                        period_date: anomaly.period_date
                    };
                });
                
                console.log('Transformed anomalies:', transformedAnomalies);
                return transformedAnomalies;
                
            } catch (error) {
                console.error('Error loading anomaly charts:', error);
                return [];
            }
        }
        
        async function loadMapsForModal(metricId) {
            try {
                let response;
                try {
                    response = await fetch(`/api/district-maps?metric_id=${metricId}`);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch from main API: ${response.status}`);
                    }
                } catch (apiError) {
                    console.warn('Error using main API endpoint, falling back to backend:', apiError);
                    response = await fetch(`/backend/api/district-maps?metric_id=${metricId}`);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch maps: ${response.status}`);
                    }
                }
                
                const data = await response.json();
                
                if (data.status === "error") {
                    throw new Error(`API error: ${data.message}`);
                }
                
                const maps = data.maps || [];
                
                // Transform maps to modal format
                return maps.filter(map => map.published_url).map(map => ({
                    id: map.id,
                    title: map.title || `Map ${map.id}`,
                    url: map.published_url,
                    dwUrl: null
                }));
                
            } catch (error) {
                console.error('Error loading maps:', error);
                return [];
            }
        }
        
        // Function to generate DW charts
        async function generateDWChart(chartType, chartId) {
            const button = event.target;
            const originalText = button.textContent;
            
            // Show loading state
            button.textContent = 'Generating...';
            button.disabled = true;
            button.classList.add('loading');
            
            try {
                let response;
                let endpoint;
                
                if (chartType === 'time-series') {
                    endpoint = `/backend/generate-dw-time-series?chart_id=${chartId}`;
                    response = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });
                } else if (chartType === 'anomalies') {
                    endpoint = `/backend/generate-dw-anomaly?anomaly_id=${chartId}`;
                    response = await fetch(endpoint, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        }
                    });
                } else {
                    throw new Error(`Unsupported chart type: ${chartType}`);
                }
                
                if (!response.ok) {
                    throw new Error(`Failed to generate DW chart: ${response.status}`);
                }
                
                const data = await response.json();
                
                if (data.status === 'success' && data.chart_url) {
                    // Store the DW URL in the database
                    await storeDWUrlInDatabase(chartType, chartId, data.chart_url);
                    
                    // Update the button to show "View in Datawrapper" with the new URL
                    button.textContent = 'View in Datawrapper';
                    button.disabled = false;
                    button.classList.remove('loading');
                    button.onclick = () => window.open(data.chart_url, '_blank');
                    
                    // Add the generated chart as a new card in the modal
                    addGeneratedChartToInterface(chartType, chartId, data.chart_url);
                    
                    console.log(`Successfully generated DW chart: ${data.chart_url}`);
                } else {
                    throw new Error(data.message || 'Failed to generate DW chart');
                }
                
            } catch (error) {
                console.error('Error generating DW chart:', error);
                
                // Reset button to original state
                button.textContent = originalText;
                button.disabled = false;
                button.classList.remove('loading');
                
                // Show error message
                alert(`Failed to generate DW chart: ${error.message}`);
            }
        }
        
        // Function to store DW URL in database
        async function storeDWUrlInDatabase(chartType, chartId, dwUrl) {
            try {
                let endpoint;
                let payload;
                
                if (chartType === 'time-series') {
                    endpoint = '/backend/update-chart-metadata';
                    payload = {
                        chart_id: chartId,
                        chart_type: 'time-series',
                        dw_url: dwUrl
                    };
                } else if (chartType === 'anomalies') {
                    endpoint = '/backend/update-anomaly-metadata';
                    payload = {
                        anomaly_id: chartId,
                        dw_url: dwUrl
                    };
                } else {
                    console.warn(`Unknown chart type for database storage: ${chartType}`);
                    return;
                }
                
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    console.warn(`Failed to store DW URL in database: ${response.status}`);
                } else {
                    console.log(`Successfully stored DW URL in database for ${chartType} ${chartId}`);
                }
                
            } catch (error) {
                console.error('Error storing DW URL in database:', error);
            }
        }
        
        // Function to add generated chart to the interface
        function addGeneratedChartToInterface(chartType, chartId, dwUrl) {
            const chartsGrid = document.getElementById('chartsGrid');
            if (!chartsGrid) return;
            
            // Create a new chart card for the generated DW chart
            const newChart = {
                id: `${chartType}-dw-${chartId}`,
                title: `Datawrapper ${chartType === 'time-series' ? 'Time Series' : 'Anomaly'} Chart ${chartId}`,
                url: dwUrl,
                dwUrl: dwUrl
            };
            
            const newChartCard = createChartCard(newChart, chartType);
            
            // Add the new chart card to the grid
            chartsGrid.insertAdjacentHTML('beforeend', newChartCard);
        }

        async function hardDeleteMetric() {
            const metricId = document.getElementById('metric-select').value;
            if (!metricId || metricId === 'all') {
                alert('Please select a specific metric to delete');
                return;
            }
            
            // Find the metric name for confirmation
            const metric = metrics.find(m => m.id == metricId);
            if (!metric) {
                alert('Selected metric not found');
                return;
            }
            
            // Show strong warning for hard delete
            const confirmMessage = `⚠️ WARNING: You are about to PERMANENTLY DELETE metric "${metric.name}" (ID: ${metricId})!\n\nThis action will:\n• Permanently remove the metric from the database\n• Delete all associated time series data\n• Delete all associated anomalies\n• This action CANNOT be undone!\n\nAre you absolutely sure you want to proceed?`;
            const confirmed = confirm(confirmMessage);
            
            if (!confirmed) {
                return;
            }
            
            // Double confirmation for hard delete
            const doubleConfirm = confirm(`FINAL WARNING: This will permanently delete "${metric.name}" and all its data. This action is irreversible. Proceed?`);
            
            if (!doubleConfirm) {
                return;
            }
            
            try {
                // Show loading state
                const hardDeleteBtn = document.getElementById('hard-delete-metric-btn');
                const originalText = hardDeleteBtn.textContent;
                hardDeleteBtn.textContent = 'Deleting...';
                hardDeleteBtn.disabled = true;
                
                // Call the hard delete API
                const response = await fetch(`/api/metrics/${metricId}/hard`, {
                    method: 'DELETE',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.detail || `HTTP ${response.status}: ${response.statusText}`);
                }
                
                const result = await response.json();
                
                if (result.status === 'success') {
                    alert(`Metric "${metric.name}" has been permanently deleted!`);
                    
                    // Reload metrics list to reflect changes
                    await loadMetrics();
                    
                    // Reset metric selection
                    document.getElementById('metric-select').value = 'all';
                    document.getElementById('metric-select').dispatchEvent(new Event('change'));
                    
                    // Clear loaded modules tracking to force reload
                    loadedModules.clear();
                    
                    console.log('Metric hard deleted successfully:', result.message);
                } else {
                    throw new Error(result.message || 'Unknown error occurred');
                }
                
            } catch (error) {
                console.error('Error hard deleting metric:', error);
                alert(`Error permanently deleting metric: ${error.message}`);
            } finally {
                // Reset button state
                const hardDeleteBtn = document.getElementById('hard-delete-metric-btn');
                hardDeleteBtn.textContent = 'Hard Delete';
                hardDeleteBtn.disabled = false;
            }
        }
    </script>

    <!-- Dark Mode JavaScript -->
    <script src="/static/js/darkmode.js"></script>
    <script src="/static/js/iframe-darkmode.js"></script>
</body>
</html>