<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dashboard Metric Control</title>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: flex-end;
        }
        .metric-management-row {
            margin-bottom: 20px;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }
        .metric-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .form-group {
            flex: 1;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 16px;
        }
        .output-windows {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .output-window {
            border: none;
            border-radius: 4px;
            padding: 15px 0;
            background-color: white;
            margin-bottom: 30px;
        }
        .output-window h3 {
            margin-top: 0;
            color: #444;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .output-content {
            white-space: pre-wrap;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 14px;
            max-height: 400px;
            overflow-y: auto;
            line-height: 1.6;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .tool-call {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .tool-response {
            background-color: #e9ecef;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
            word-break: break-word;
        }
        .output-content.markdown {
            padding: 15px;
        }
        .output-content.markdown h1 {
            font-size: 24px;
            margin-bottom: 20px;
            color: #2c3e50;
        }
        .output-content.markdown h2 {
            font-size: 20px;
            margin: 15px 0;
            color: #34495e;
        }
        .output-content.markdown h3 {
            font-size: 18px;
            margin: 12px 0;
            color: #2c3e50;
        }
        .output-content.markdown p {
            margin: 10px 0;
        }
        .output-content.markdown code {
            background-color: #f8f9fa;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: monospace;
        }
        .output-content.markdown pre {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        .output-content.markdown table {
            border-collapse: collapse;
            width: 100%;
            margin: 15px 0;
        }
        .output-content.markdown th,
        .output-content.markdown td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .output-content.markdown th {
            background-color: #f8f9fa;
        }
        .output-content.markdown tr:nth-child(even) {
            background-color: #f8f9fa;
        }
        .output-content.markdown blockquote {
            border-left: 4px solid #ddd;
            margin: 15px 0;
            padding-left: 15px;
            color: #666;
        }
        .btn {
            padding: 10px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            font-size: 16px;
        }
        .btn-secondary {
            background-color: #6c757d;
            color: white;
        }
        .btn-secondary:hover {
            background-color: #5a6268;
        }
        .btn-subtle {
            background-color: #ffffff;
            color: #495057;
            border: 1px solid #dee2e6;
        }
        .btn-subtle:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
        }
        .btn-subtle:disabled {
            background-color: #f8f9fa;
            color: #adb5bd;
            border-color: #e9ecef;
            cursor: not-allowed;
            opacity: 0.6;
        }
        .btn-subtle:hover:not(:disabled) {
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #ad35fa;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 10px;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Add styles for column selection */
        .column-selection {
            margin: 20px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .column-selection h3 {
            margin-top: 0;
            color: #444;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        .column-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }
        .column-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .column-item input[type="checkbox"] {
            margin-right: 8px;
        }
        .column-item label {
            font-size: 14px;
            color: #333;
            cursor: pointer;
        }
        .column-actions {
            margin-top: 15px;
            display: flex;
            gap: 10px;
        }
        .btn-primary {
            background-color: #ad35fa;
            color: white;
        }
        .btn-primary:hover {
            background-color: #0056b3;
        }
        .btn-danger {
            background-color: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background-color: #c82333;
        }
        .status-container {
            margin-top: 10px;
            display: none;
        }
        .progress-container {
            margin-top: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            padding: 10px;
            border: 1px solid #ddd;
        }
        .progress-bar {
            height: 20px;
            background-color: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 10px;
        }
        .progress-bar-fill {
            height: 100%;
            background-color: #ad35fa;
            width: 0%;
            transition: width 0.3s ease;
        }
        .progress-status {
            font-size: 14px;
            color: #495057;
            margin-bottom: 5px;
        }
        .progress-details {
            font-size: 12px;
            color: #6c757d;
            max-height: 100px;
            overflow-y: auto;
            background-color: #f1f3f5;
            padding: 8px;
            border-radius: 4px;
            margin-top: 5px;
        }
        .btn-with-spinner {
            position: relative;
        }
        .btn-spinner {
            position: absolute;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 16px;
            height: 16px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
            display: none;
        }
        .btn-with-spinner.loading .btn-spinner {
            display: block;
        }
        .btn-with-spinner.loading {
            padding-right: 40px;
        }
        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
            border-bottom: 1px solid #e9ecef;
        }
        .log-entry:last-child {
            border-bottom: none;
        }
        .log-time {
            color: #6c757d;
            font-size: 11px;
            margin-right: 5px;
        }
        .log-info {
            color: #0c5460;
        }
        .log-warning {
            color: #856404;
        }
        .log-error {
            color: #721c24;
        }
        .log-success {
            color: #155724;
        }
        /* Add styles for the metric definition modal */
        .metric-definition-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
        }
        .metric-definition-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 800px;
            border-radius: 8px;
            position: relative;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .close-modal-btn {
            position: absolute;
            right: 20px;
            top: 20px;
            font-size: 24px;
            font-weight: bold;
            color: #666;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            line-height: 1;
        }
        
        .close-modal-btn:hover {
            color: #000;
        }
        
        .metric-form-group {
            margin-bottom: 20px;
        }
        .metric-form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #333;
        }
        .metric-form-group input[type="text"],
        .metric-form-group textarea,
        .metric-form-group select {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .metric-form-group textarea {
            min-height: 100px;
            resize: vertical;
        }
        .metric-form-group .field-list {
            margin-top: 10px;
        }
        .metric-form-group .field-item {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: center;
        }
        .metric-form-group .field-item input {
            flex: 1;
        }
        .metric-form-group .field-item button {
            padding: 4px 8px;
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .metric-form-group .add-field-btn {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 10px;
        }
        .metric-form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #ddd;
        }
        .metric-form-actions button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
        }
        .metric-form-actions .save-btn {
            background-color: #ad35fa;
            color: white;
        }
        .metric-form-actions .cancel-btn {
            background-color: #6c757d;
            color: white;
        }
        .charts-scrollable-container {
            overflow-x: auto;
            padding: 15px 0;
            margin: 20px 0;
        }
        .charts-row {
            display: flex;
            gap: 20px;
        }
        .loading-charts {
            text-align: center;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 4px;
            flex: 1;
        }
        .chart-card {
            min-width: 400px;
            max-width: 550px;
            height: 525px; /* Reduced from 700px by 25% */
            border: 1px solid #eee;
            border-radius: 4px;
            overflow: hidden;
            box-shadow: none;
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            background-color: white;
        }
        .chart-card-header {
            display: none;
        }
        .chart-card-body {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            padding: 0;
        }
        .chart-card-body iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        .chart-card-footer {
            padding: 10px;
            border-top: 1px solid #eee;
            background-color: #f8f9fa;
            text-align: center;
        }
        .chart-dw-btn {
            background-color: #ad35fa;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: background-color 0.3s ease;
            position: relative;
        }
        .chart-dw-btn:hover {
            background-color: #9625e0;
        }
        .chart-dw-btn:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .chart-dw-btn.loading {
            padding-right: 30px;
        }
        .chart-dw-btn .btn-spinner {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s linear infinite;
            display: none;
        }
        .chart-dw-btn.loading .btn-spinner {
            display: block;
        }
        .no-charts-message {
            text-align: center;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 4px;
            width: 100%;
        }
       
        .btn-subtle-primary {
            background-color: #6c757d;
            color: white;
            border: 1px solid #6c757d;
        }
        .btn-subtle-primary:hover {
            background-color: #5a6268;
            border-color: #545b62;
        }
        .btn-subtle-danger {
            background-color: #6c757d;
            color: white;
            border: 1px solid #6c757d;
        }
        .btn-subtle-danger:hover {
            background-color: #dc3545;
            border-color: #dc3545;
        }
        .btn-subtle-danger:disabled {
            background-color: #e9ecef;
            color: #6c757d;
            border-color: #dee2e6;
            cursor: not-allowed;
        }
        .btn-warning {
            background-color: #ffc107;
            color: #212529;
            border: 1px solid #ffc107;
        }
        .btn-warning:hover {
            background-color: #e0a800;
            border-color: #d39e00;
        }
        .btn-warning:disabled {
            background-color: #e9ecef;
            color: #6c757d;
            border-color: #dee2e6;
            cursor: not-allowed;
        }
        
        
        /* Chart tabs styles */
        .chart-tabs {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }
        
        .chart-tab-buttons {
            display: flex;
            border-bottom: 1px solid #ddd;
            background-color: #f8f9fa;
        }
        
        .chart-tab-btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            background-color: transparent;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            color: #6c757d;
            transition: all 0.3s ease;
        }
        
        .chart-tab-btn:hover {
            background-color: #e9ecef;
            color: #495057;
        }
        
        .chart-tab-btn.active {
            background-color: #ad35fa;
            color: white;
            border-bottom: 2px solid #ad35fa;
        }
        
        .chart-tab-content {
            flex: 1;
            position: relative;
        }
        
        .chart-tab-pane {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }
        
        .chart-tab-pane.active {
            display: block;
        }
        
        .chart-tab-pane iframe {
            width: 100%;
            height: 100%;
            border: none;
        }
        
        /* Add styles for metric reordering modal */
        .metric-reorder-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
        }
        
        .metric-reorder-content {
            background-color: #fefefe;
            margin: 5% auto;
            padding: 20px;
            border: 1px solid #888;
            width: 80%;
            max-width: 600px;
            border-radius: 8px;
            position: relative;
            max-height: 90vh;
            overflow-y: auto;
        }
        
        .reorder-list {
            list-style: none;
            padding: 0;
            margin: 20px 0;
        }
        
        .reorder-item {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 10px;
            cursor: grab;
            transition: all 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .reorder-item:hover {
            background-color: #e9ecef;
            border-color: #adb5bd;
        }
        
        .reorder-item.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
        
        .reorder-item-info {
            flex: 1;
        }
        
        .reorder-item-title {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .reorder-item-details {
            font-size: 12px;
            color: #6c757d;
        }
        
        .reorder-item-controls {
            display: flex;
            gap: 5px;
        }
        
        .reorder-btn {
            background-color: #6c757d;
            color: white;
            border: none;
            padding: 5px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        
        .reorder-btn:hover {
            background-color: #5a6268;
        }
        
        .reorder-btn:disabled {
            background-color: #e9ecef;
            color: #6c757d;
            cursor: not-allowed;
        }
        
        .drag-handle {
            font-size: 18px;
            color: #6c757d;
            cursor: grab;
            margin-right: 10px;
        }
        
        .drag-handle:active {
            cursor: grabbing;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <div class="form-group">
                <label for="district-select">Select District:</label>
                <select id="district-select">
                    <option value="0">Citywide (All Districts)</option>
                    <option value="1">District 1</option>
                    <option value="2">District 2</option>
                    <option value="3">District 3</option>
                    <option value="4">District 4</option>
                    <option value="5">District 5</option>
                    <option value="6">District 6</option>
                    <option value="7">District 7</option>
                    <option value="8">District 8</option>
                    <option value="9">District 9</option>
                    <option value="10">District 10</option>
                    <option value="11">District 11</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="metric-select">Select Metric:</label>
                <select id="metric-select">
                    <option value="all">All Metrics</option>
                    <option value="1">Loading metrics...</option>
                </select>
            </div>
            
            <div class="form-group">
                <label for="period-type-select">Period Type:</label>
                <select id="period-type-select">
                    <option value="month">Monthly Analysis</option>
                    <option value="year">Annual Analysis</option>
                    <option value="week">Weekly Analysis</option>
                    <option value="both">Monthly & Annual Analysis</option>
                </select>
            </div>
            
            <div class="form-group">
                <button id="generate-metrics-btn" class="btn btn-secondary btn-with-spinner">
                    Generate Metrics
                    <span class="btn-spinner"></span>
                </button>
            </div>
        </div>
        
        <!-- Metric management buttons row -->
        <div class="metric-management-row">
            <div class="metric-actions">
                <button id="delete-metric-btn" class="btn btn-subtle btn-small" disabled>
                    Delete Metric
                </button>
                <button id="edit-metric-btn" class="btn btn-subtle btn-small" disabled>
                    Edit Metric
                </button>
                <button id="define-metric-btn" class="btn btn-subtle btn-small">
                    Create New Metric
                </button>
                <button id="reorder-metrics-btn" class="btn btn-subtle btn-small">
                    Reorder Metrics
                </button>
                <button id="backup-metrics-btn" class="btn btn-subtle btn-small">
                    Backup Metrics
                </button>
                <button id="migrate-dashboard-btn" class="btn btn-subtle btn-small">
                    Restore Metrics from Backup
                </button>
            </div>
        </div>
        
        <!-- Progress and status information moved below the controls -->
        <div id="generate-status" class="status-container"></div>
        <div id="generate-progress" class="progress-container" style="display: none;">
            <div class="progress-status">Initializing metric generation...</div>
            <div class="progress-bar">
                <div class="progress-bar-fill"></div>
            </div>
            <div class="progress-details" id="progress-log"></div>
        </div>
        
        <!-- Add column selection section -->
        <div id="column-selection" class="column-selection" style="display: none;">
            <h3>Select Columns for Enhanced Dashboard</h3>
            <div class="column-grid" id="column-grid">
                <!-- Columns will be populated here -->
            </div>
            <div class="column-actions">
                <button id="select-all-columns" class="btn btn-primary">Select All</button>
                <button id="deselect-all-columns" class="btn btn-primary">Deselect All</button>
                <button id="update-columns" class="btn btn-primary">Update Enhanced Queries</button>
            </div>
            <div id="column-update-status" style="margin-top: 10px; display: none;"></div>
        </div>
        
        <div class="output-windows">
            <div class="output-window">
                <h3>Dashboard Output</h3>
                <div id="dashboard-output" class="output-content">Select a metric to view dashboard output</div>
            </div>
            
            <div class="output-window">
                <h3>Annual Output</h3>
                <div id="annual-output" class="output-content">Select a metric to view annual output</div>
            </div>
            
            <!-- Add annual time series charts row -->
            <div class="output-window">
                <h3>Annual Time Series Charts</h3>
                <div class="charts-scrollable-container">
                    <div id="annual-time-series-charts" class="charts-row">
                        <div class="loading-charts">Loading charts...</div>
                    </div>
                </div>
            </div>
            
            <!-- Add annual anomaly charts row -->
            <div class="output-window">
                <h3>Annual Anomalies</h3>
                <div class="charts-scrollable-container">
                    <div id="annual-anomaly-charts" class="charts-row">
                        <div class="loading-charts">Loading charts...</div>
                    </div>
                </div>
            </div>
            
            <div class="output-window">
                <h3>Monthly Output</h3>
                <div id="monthly-output" class="output-content">Select a metric to view monthly output</div>
            </div>
            
            <!-- Add time series charts row -->
            <div class="output-window">
                <h3>Time Series Charts</h3>
                <div class="charts-scrollable-container">
                    <div id="time-series-charts" class="charts-row">
                        <div class="loading-charts">Loading charts...</div>
                    </div>
                </div>
            </div>
            
            <!-- Add anomaly charts row -->
            <div class="output-window">
                <h3>Anomalies</h3>
                <div class="charts-scrollable-container">
                    <div id="anomaly-charts" class="charts-row">
                        <div class="loading-charts">Loading charts...</div>
                    </div>
                </div>
            </div>
            
            <div class="output-window">
                <h3>Weekly Output</h3>
                <div id="weekly-output" class="output-content">Select a metric to view weekly output</div>
            </div>
            
            <!-- Add maps section -->
            <div class="output-window">
                <h3>District Maps</h3>
                <div class="charts-scrollable-container">
                    <div id="district-maps" class="charts-row">
                        <div class="loading-charts">Select a metric to view district maps</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Add the metric definition modal -->
    <div id="metricDefinitionModal" class="metric-definition-modal">
        <div class="metric-definition-content">
            <button type="button" class="close-modal-btn" onclick="closeMetricDefinitionModal()">&times;</button>
            <h2 id="metricModalTitle">Define New Metric</h2>
            <form id="metricDefinitionForm">
                <input type="hidden" id="isEditMode" value="false">
                <div class="metric-form-group">
                    <label for="metricName">Metric Name (with emoji)</label>
                    <input type="text" id="metricName" name="metricName" required>
                </div>
                
                <div class="metric-form-group">
                    <label for="metricId">ID</label>
                    <input type="text" id="metricId" name="metricId" required>
                </div>
                
                <div class="metric-form-group">
                    <label for="endpoint">Endpoint</label>
                    <input type="text" id="endpoint" name="endpoint" required>
                </div>
                
                <div class="metric-form-group">
                    <label for="summary">Summary</label>
                    <textarea id="summary" name="summary" required></textarea>
                </div>
                
                <div class="metric-form-group">
                    <label for="definition">Definition</label>
                    <textarea id="definition" name="definition" required></textarea>
                </div>
                
                <div class="metric-form-group">
                    <label for="dataSfUrl">Data SF URL</label>
                    <input type="text" id="dataSfUrl" name="dataSfUrl" required>
                </div>
                
                <div class="metric-form-group">
                    <label for="ytdQuery">YTD Query</label>
                    <textarea id="ytdQuery" name="ytdQuery" required></textarea>
                </div>
                
                <div class="metric-form-group">
                    <label for="metricQuery">Metric Query</label>
                    <textarea id="metricQuery" name="metricQuery" required></textarea>
                </div>
                
                <div class="metric-form-group">
                    <label for="datasetTitle">Dataset Title</label>
                    <input type="text" id="datasetTitle" name="datasetTitle" required>
                </div>
                
                <div class="metric-form-group">
                    <label for="datasetCategory">Dataset Category</label>
                    <input type="text" id="datasetCategory" name="datasetCategory" required>
                </div>
                
                <div class="metric-form-group">
                    <label for="itemNoun">Item Noun</label>
                    <input type="text" id="itemNoun" name="itemNoun" required placeholder="e.g. Items, Cases, Incidents">
                </div>
                
                <div class="metric-form-group">
                    <label for="greenDirection">Green Direction</label>
                    <select id="greenDirection" name="greenDirection" required>
                        <option value="up">Up (higher is better)</option>
                        <option value="down">Down (lower is better)</option>
                    </select>
                </div>
                
                <div class="metric-form-group">
                    <label for="isActive">Status</label>
                    <select id="isActive" name="isActive" required>
                        <option value="true">Active</option>
                        <option value="false">Inactive</option>
                    </select>
                </div>
                
                <div class="metric-form-group">
                    <label for="showOnDash">Show on Dashboard</label>
                    <select id="showOnDash" name="showOnDash" required>
                        <option value="true">Yes</option>
                        <option value="false">No</option>
                    </select>
                </div>
                
                <div class="metric-form-actions">
                    <button type="button" class="cancel-btn" onclick="closeMetricDefinitionModal()">Cancel</button>
                    <button type="submit" class="save-btn">Save Metric</button>
                </div>
            </form>
        </div>
    </div>
    
    <!-- Add the metric reordering modal -->
    <div id="metricReorderModal" class="metric-reorder-modal">
        <div class="metric-reorder-content">
            <button type="button" class="close-modal-btn" onclick="closeMetricReorderModal()">&times;</button>
            <h2>Reorder Metrics</h2>
            <p>Drag and drop metrics to reorder them, or use the arrow buttons. The order will affect how they appear in the dashboard and metric selection.</p>
            
            <div id="reorderLoadingState" style="display: none; text-align: center; padding: 20px;">
                <div class="spinner"></div>
                <p>Loading metrics...</p>
            </div>
            
            <ul id="metricReorderList" class="reorder-list">
                <!-- Metrics will be populated here -->
            </ul>
            
            <div class="metric-form-actions">
                <button type="button" class="cancel-btn" onclick="closeMetricReorderModal()">Cancel</button>
                <button type="button" class="save-btn" onclick="saveMetricOrder()">Save Order</button>
            </div>
        </div>
    </div>
    
    <script>
        // Define modal functions in global scope
        function openMetricDefinitionModal() {
            const isEditMode = document.getElementById('isEditMode').value === 'true';
            if (!isEditMode) {
                // Reset form for new metrics
                document.getElementById('metricDefinitionForm').reset();
                document.getElementById('locationFields').innerHTML = '';
                document.getElementById('categoryFields').innerHTML = '';
                document.getElementById('metricModalTitle').textContent = 'Define New Metric';
            }
            document.getElementById('metricDefinitionModal').style.display = 'block';
        }

        function closeMetricDefinitionModal() {
            const modal = document.getElementById('metricDefinitionModal');
            const form = document.getElementById('metricDefinitionForm');
            
            // Hide the modal
            if (modal) {
                modal.style.display = 'none';
            }
            
            // Reset the form
            if (form) {
                form.reset();
            }
            
            // Reset the edit mode flag
            const editModeInput = document.getElementById('isEditMode');
            if (editModeInput) {
                editModeInput.value = 'false';
            }
            
            // Clear any dynamic fields
            const locationFields = document.getElementById('locationFields');
            const categoryFields = document.getElementById('categoryFields');
            if (locationFields) {
                locationFields.innerHTML = '';
            }
            if (categoryFields) {
                categoryFields.innerHTML = '';
            }
            
            // Reset the modal title
            const modalTitle = document.getElementById('metricModalTitle');
            if (modalTitle) {
                modalTitle.textContent = 'Define New Metric';
            }
        }

        function openMetricReorderModal() {
            document.getElementById('metricReorderModal').style.display = 'block';
            loadMetricsForReordering();
        }

        function closeMetricReorderModal() {
            document.getElementById('metricReorderModal').style.display = 'none';
        }

        async function loadMetricsForReordering() {
            const loadingState = document.getElementById('reorderLoadingState');
            const reorderList = document.getElementById('metricReorderList');
            
            try {
                loadingState.style.display = 'block';
                reorderList.innerHTML = '';
                
                // Fetch metrics with their current order
                const response = await fetch('/api/metrics-with-order');
                if (!response.ok) {
                    throw new Error('Failed to load metrics');
                }
                
                const data = await response.json();
                const metricsWithOrder = data.metrics || [];
                
                // Sort by display_order
                metricsWithOrder.sort((a, b) => (a.display_order || 999) - (b.display_order || 999));
                
                // Create list items
                metricsWithOrder.forEach((metric, index) => {
                    const listItem = document.createElement('li');
                    listItem.className = 'reorder-item';
                    listItem.draggable = true;
                    listItem.dataset.metricId = metric.id;
                    listItem.dataset.currentOrder = metric.display_order || 999;
                    
                    listItem.innerHTML = `
                        <span class="drag-handle">⋮⋮</span>
                        <div class="reorder-item-info">
                            <div class="reorder-item-title">${metric.name}</div>
                            <div class="reorder-item-details">ID: ${metric.id} | Category: ${metric.category || 'N/A'} | Order: ${metric.display_order || 'Not set'}</div>
                        </div>
                        <div class="reorder-item-controls">
                            <button class="reorder-btn" onclick="moveMetricUp(this)" ${index === 0 ? 'disabled' : ''}>↑</button>
                            <button class="reorder-btn" onclick="moveMetricDown(this)" ${index === metricsWithOrder.length - 1 ? 'disabled' : ''}>↓</button>
                        </div>
                    `;
                    
                    // Add drag event listeners
                    listItem.addEventListener('dragstart', handleDragStart);
                    listItem.addEventListener('dragover', handleDragOver);
                    listItem.addEventListener('drop', handleDrop);
                    listItem.addEventListener('dragend', handleDragEnd);
                    
                    reorderList.appendChild(listItem);
                });
                
                loadingState.style.display = 'none';
            } catch (error) {
                console.error('Error loading metrics for reordering:', error);
                loadingState.innerHTML = `<p style="color: #dc3545;">Error loading metrics: ${error.message}</p>`;
            }
        }

        function moveMetricUp(button) {
            const listItem = button.closest('.reorder-item');
            const previousItem = listItem.previousElementSibling;
            
            if (previousItem) {
                listItem.parentNode.insertBefore(listItem, previousItem);
                updateArrowButtons();
            }
        }

        function moveMetricDown(button) {
            const listItem = button.closest('.reorder-item');
            const nextItem = listItem.nextElementSibling;
            
            if (nextItem) {
                listItem.parentNode.insertBefore(nextItem, listItem);
                updateArrowButtons();
            }
        }

        function updateArrowButtons() {
            const items = document.querySelectorAll('.reorder-item');
            items.forEach((item, index) => {
                const upBtn = item.querySelector('.reorder-btn:first-child');
                const downBtn = item.querySelector('.reorder-btn:last-child');
                
                upBtn.disabled = index === 0;
                downBtn.disabled = index === items.length - 1;
            });
        }

        async function saveMetricOrder() {
            const items = document.querySelectorAll('.reorder-item');
            const newOrder = Array.from(items).map((item, index) => ({
                id: parseInt(item.dataset.metricId),
                display_order: index + 1
            }));
            
            try {
                const saveBtn = document.querySelector('#metricReorderModal .save-btn');
                saveBtn.disabled = true;
                saveBtn.textContent = 'Saving...';
                
                const response = await fetch('/api/update-metric-order', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ metrics: newOrder })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to save metric order');
                }
                
                const result = await response.json();
                alert('Metric order saved successfully!');
                
                // Close modal and reload metrics
                closeMetricReorderModal();
                await loadMetrics(); // Reload the main metrics list
                
            } catch (error) {
                console.error('Error saving metric order:', error);
                alert(`Error saving metric order: ${error.message}`);
            } finally {
                const saveBtn = document.querySelector('#metricReorderModal .save-btn');
                saveBtn.disabled = false;
                saveBtn.textContent = 'Save Order';
            }
        }

        // Drag and drop functionality
        let draggedElement = null;

        function handleDragStart(e) {
            draggedElement = e.target;
            e.target.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/html', e.target.outerHTML);
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const afterElement = getDragAfterElement(e.target.closest('.reorder-list'), e.clientY);
            const dragging = document.querySelector('.dragging');
            
            if (afterElement == null) {
                e.target.closest('.reorder-list').appendChild(dragging);
            } else {
                e.target.closest('.reorder-list').insertBefore(dragging, afterElement);
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            updateArrowButtons();
        }

        function handleDragEnd(e) {
            e.target.classList.remove('dragging');
            draggedElement = null;
        }

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.reorder-item:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        document.addEventListener('DOMContentLoaded', function() {
            const districtSelect = document.getElementById('district-select');
            const metricSelect = document.getElementById('metric-select');
            const dashboardOutput = document.getElementById('dashboard-output');
            const annualOutput = document.getElementById('annual-output');
            const monthlyOutput = document.getElementById('monthly-output');
            const weeklyOutput = document.getElementById('weekly-output');
            const generateMetricsBtn = document.getElementById('generate-metrics-btn');
            const generateStatus = document.getElementById('generate-status');
            const periodTypeSelect = document.getElementById('period-type-select');
            
            let metrics = [];
            
            // Function to load metrics data
            async function loadMetrics() {
                try {
                    const response = await fetch('/api/enhanced-queries');
                    if (!response.ok) {
                        throw new Error('Failed to load metrics data');
                    }
                    
                    const data = await response.json();
                    metrics = [];
                    
                    // Extract all metrics from the data structure
                    Object.entries(data).forEach(([category, categoryData]) => {
                        Object.entries(categoryData).forEach(([subcategory, subcategoryData]) => {
                            if (subcategoryData.queries) {
                                Object.entries(subcategoryData.queries).forEach(([metricName, metricData]) => {
                                    metrics.push({
                                        id: metricData.id,
                                        name: metricName,
                                        category: category,
                                        subcategory: subcategory,
                                        endpoint: metricData.endpoint,
                                        is_active: metricData.is_active,
                                        display_order: metricData.display_order || 999
                                    });
                                });
                            }
                        });
                    });
                    
                    // Sort metrics by display_order, then by ID for any metrics without a display_order
                    metrics.sort((a, b) => {
                        // First sort by display_order
                        const orderA = a.display_order || 999;
                        const orderB = b.display_order || 999;
                        if (orderA !== orderB) {
                            return orderA - orderB;
                        }
                        // If display_order is the same, sort by ID
                        return a.id - b.id;
                    });
                    
                    // Group metrics by category and active status
                    const groupedMetrics = metrics.reduce((acc, metric) => {
                        if (!acc[metric.category]) {
                            acc[metric.category] = {
                                active: [],
                                inactive: []
                            };
                        }
                        if (metric.is_active) {
                            acc[metric.category].active.push(metric);
                        } else {
                            acc[metric.category].inactive.push(metric);
                        }
                        return acc;
                    }, {});
                    
                    // Build the select options HTML
                    let optionsHtml = '<option value="all">All Metrics</option>';
                    
                    // Add active metrics first
                    Object.entries(groupedMetrics).forEach(([category, {active, inactive}]) => {
                        if (active.length > 0) {
                            optionsHtml += `<optgroup label="${category}">`;
                            active.forEach(metric => {
                                optionsHtml += `<option value="${metric.id}">${metric.id} - ${metric.name}</option>`;
                            });
                            optionsHtml += '</optgroup>';
                        }
                    });
                    
                    // Add inactive metrics in grey
                    Object.entries(groupedMetrics).forEach(([category, {active, inactive}]) => {
                        if (inactive.length > 0) {
                            optionsHtml += `<optgroup label="${category} (Inactive)" style="color: #6c757d; font-style: italic;">`;
                            inactive.forEach(metric => {
                                optionsHtml += `<option value="${metric.id}" style="color: #6c757d; font-style: italic;">${metric.id} - ${metric.name}</option>`;
                            });
                            optionsHtml += '</optgroup>';
                        }
                    });
                    
                    // Update the select element
                    metricSelect.innerHTML = optionsHtml;
                    
                    // Load initial outputs
                    loadOutputs();
                } catch (error) {
                    console.error('Error loading metrics:', error);
                    metricSelect.innerHTML = '<option value="">Error loading metrics</option>';
                }
            }
            
            // Function to load output files
            async function loadOutputs() {
                const metricId = metricSelect.value;
                const districtId = districtSelect.value;
                
                if (!metricId) return;
                
                console.log(`Loading outputs for district ${districtId}, metric ${metricId}`);
                
                // Show loading state
                [dashboardOutput, annualOutput, monthlyOutput, weeklyOutput].forEach(output => {
                    output.innerHTML = '<div class="spinner"></div> Loading...';
                });
                
                try {
                    // Load dashboard output
                    const dashboardResponse = await fetch(`/output/dashboard/${districtId}/${metricId}.json`);
                    if (dashboardResponse.ok) {
                        const dashboardData = await dashboardResponse.json();
                        dashboardOutput.textContent = JSON.stringify(dashboardData, null, 2);
                    } else {
                        console.warn(`Dashboard output not found: /output/dashboard/${districtId}/${metricId}.json (${dashboardResponse.status})`);
                        dashboardOutput.textContent = 'No dashboard output available for this district/metric combination';
                    }
                    
                    // Load annual output
                    const annualResponse = await fetch(`/output/annual/${districtId}/${metricId}.md`);
                    if (annualResponse.ok) {
                        const annualText = await annualResponse.text();
                        annualOutput.innerHTML = marked.parse(annualText);
                        annualOutput.classList.add('markdown');
                    } else {
                        console.warn(`Annual output not found: /output/annual/${districtId}/${metricId}.md (${annualResponse.status})`);
                        annualOutput.textContent = 'No annual output available for this district/metric combination';
                    }
                    
                    // Load monthly output
                    const monthlyResponse = await fetch(`/output/monthly/${districtId}/${metricId}.md`);
                    if (monthlyResponse.ok) {
                        const monthlyText = await monthlyResponse.text();
                        monthlyOutput.innerHTML = marked.parse(monthlyText);
                        monthlyOutput.classList.add('markdown');
                    } else {
                        console.warn(`Monthly output not found: /output/monthly/${districtId}/${metricId}.md (${monthlyResponse.status})`);
                        monthlyOutput.textContent = 'No monthly output available for this district/metric combination';
                    }
                    
                    // Load weekly output
                    const weeklyResponse = await fetch(`/output/weekly/${districtId}/${metricId}.md`);
                    if (weeklyResponse.ok) {
                        const weeklyText = await weeklyResponse.text();
                        weeklyOutput.innerHTML = marked.parse(weeklyText);
                        weeklyOutput.classList.add('markdown');
                    } else {
                        console.warn(`Weekly output not found: /output/weekly/${districtId}/${metricId}.md (${weeklyResponse.status})`);
                        weeklyOutput.textContent = 'No weekly output available for this district/metric combination';
                    }
                } catch (error) {
                    console.error('Error loading outputs:', error);
                    [dashboardOutput, annualOutput, monthlyOutput, weeklyOutput].forEach(output => {
                        output.textContent = `Error loading output: ${error.message}`;
                    });
                }
            }
            
            // Event listeners
            districtSelect.addEventListener('change', loadOutputs);
            metricSelect.addEventListener('change', loadOutputs);
            
            // Generate metrics functionality
            generateMetricsBtn.addEventListener('click', async () => {
                const periodType = periodTypeSelect.value;
                const metricId = metricSelect.value;
                const districtId = districtSelect.value;
                const progressContainer = document.getElementById('generate-progress');
                const progressBar = progressContainer.querySelector('.progress-bar-fill');
                const progressStatus = progressContainer.querySelector('.progress-status');
                const progressLog = document.getElementById('progress-log');
                
                if (!metricId) {
                    generateStatus.style.display = 'block';
                    generateStatus.innerHTML = `
                        <div style="color: #dc3545;">
                            <h4>❌ Error</h4>
                            <p>Please select a metric first</p>
                        </div>
                    `;
                    return;
                }
                
                try {
                    // Reset and show progress UI
                    generateMetricsBtn.classList.add('loading');
                    generateMetricsBtn.disabled = true;
                    progressContainer.style.display = 'block';
                    progressBar.style.width = '0%';
                    progressStatus.textContent = 'Initializing metric generation...';
                    progressLog.innerHTML = '';
                    
                    // Add initial log entry
                    addLogEntry('Starting metric generation process...', 'info');
                    
                    // Handle "All Metrics" selection
                    if (metricId === 'all') {
                        // For 'both' period type, we need to make two separate calls for each metric
                        if (periodType === 'both') {
                            // First run monthly analysis for all metrics
                            progressStatus.textContent = 'Running monthly analysis for all metrics...';
                            progressBar.style.width = '25%';
                            addLogEntry('Starting monthly analysis for all metrics...', 'info');
                            
                            // Run monthly analysis for each metric
                            for (let i = 0; i < metrics.length; i++) {
                                const metric = metrics[i];
                                const progress = ((i + 1) / metrics.length) * 25;
                                progressBar.style.width = `${progress}%`;
                                progressStatus.textContent = `Running monthly analysis for metric ${metric.id} (${i + 1}/${metrics.length})...`;
                                addLogEntry(`Processing monthly analysis for metric ${metric.id} - ${metric.name}...`, 'info');
                                
                                const monthlyResponse = await fetch(`/backend/run_specific_metric?metric_id=${metric.id}&district_id=${districtId}&period_type=month`, {
                                    method: 'GET',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    }
                                });
                                
                                const monthlyData = await monthlyResponse.json();
                                if (monthlyData.status !== 'success') {
                                    addLogEntry(`Warning: Monthly analysis failed for metric ${metric.id}: ${monthlyData.message}`, 'warning');
                                } else {
                                    addLogEntry(`Completed monthly analysis for metric ${metric.id}`, 'success');
                                }
                            }
                            
                            progressBar.style.width = '50%';
                            addLogEntry('Monthly analysis completed for all metrics', 'success');
                            
                            // Then run annual analysis for all metrics
                            progressStatus.textContent = 'Running annual analysis for all metrics...';
                            addLogEntry('Starting annual analysis for all metrics...', 'info');
                            
                            // Run annual analysis for each metric
                            for (let i = 0; i < metrics.length; i++) {
                                const metric = metrics[i];
                                const progress = 50 + ((i + 1) / metrics.length) * 50;
                                progressBar.style.width = `${progress}%`;
                                progressStatus.textContent = `Running annual analysis for metric ${metric.id} (${i + 1}/${metrics.length})...`;
                                addLogEntry(`Processing annual analysis for metric ${metric.id} - ${metric.name}...`, 'info');
                                
                                const annualResponse = await fetch(`/backend/run_specific_metric?metric_id=${metric.id}&district_id=${districtId}&period_type=year`, {
                                    method: 'GET',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    }
                                });
                                
                                const annualData = await annualResponse.json();
                                if (annualData.status !== 'success') {
                                    addLogEntry(`Warning: Annual analysis failed for metric ${metric.id}: ${annualData.message}`, 'warning');
                                } else {
                                    addLogEntry(`Completed annual analysis for metric ${metric.id}`, 'success');
                                }
                            }
                            
                            progressBar.style.width = '100%';
                            progressStatus.textContent = 'Monthly and annual analysis completed for all metrics';
                            addLogEntry('All metric generation completed', 'success');
                            
                            generateStatus.innerHTML = `
                                <div style="color: #28a745;">
                                    <h4>✅ Generation Complete</h4>
                                    <p>Monthly and annual analysis completed for all metrics</p>
                                </div>
                            `;
                        } else if (periodType === 'week') {
                            // Weekly analysis - calls a different endpoint
                            progressStatus.textContent = 'Running weekly analysis for all metrics...';
                            progressBar.style.width = '50%';
                            addLogEntry('Starting weekly analysis for all metrics...', 'info');
                            
                            const response = await fetch(`/api/weekly-analysis?include_districts=true`, {
                                method: 'GET'
                            });
                            
                            const data = await response.json();
                            
                            if (data.success) {
                                progressBar.style.width = '100%';
                                progressStatus.textContent = 'Weekly analysis completed successfully for all default metrics';
                                addLogEntry('Weekly analysis completed successfully', 'success');
                                
                                generateStatus.innerHTML = `
                                    <div style="color: #28a745;">
                                        <h4>✅ Weekly Analysis Complete</h4>
                                        <p>Weekly analysis completed successfully for all default metrics</p>
                                        <p><a href="/weekly-report" target="_blank">View Weekly Report</a></p>
                                    </div>
                                `;
                            } else {
                                throw new Error(data.error || 'Unknown error');
                            }
                        } else {
                            // Single period type analysis for all metrics
                            progressStatus.textContent = `Running ${periodType} analysis for all metrics...`;
                            addLogEntry(`Starting ${periodType} analysis for all metrics...`, 'info');
                            
                            // Run analysis for each metric
                            for (let i = 0; i < metrics.length; i++) {
                                const metric = metrics[i];
                                const progress = ((i + 1) / metrics.length) * 100;
                                progressBar.style.width = `${progress}%`;
                                progressStatus.textContent = `Running ${periodType} analysis for metric ${metric.id} (${i + 1}/${metrics.length})...`;
                                addLogEntry(`Processing ${periodType} analysis for metric ${metric.id} - ${metric.name}...`, 'info');
                                
                                const response = await fetch(`/backend/run_specific_metric?metric_id=${metric.id}&district_id=${districtId}&period_type=${periodType}`, {
                                    method: 'GET',
                                    headers: {
                                        'Content-Type': 'application/json'
                                    }
                                });
                                
                                const data = await response.json();
                                if (data.status !== 'success') {
                                    addLogEntry(`Warning: ${periodType} analysis failed for metric ${metric.id}: ${data.message}`, 'warning');
                                } else {
                                    addLogEntry(`Completed ${periodType} analysis for metric ${metric.id}`, 'success');
                                }
                            }
                            
                            progressBar.style.width = '100%';
                            progressStatus.textContent = `${periodType} analysis completed for all metrics`;
                            addLogEntry(`All ${periodType} analysis completed`, 'success');
                            
                            generateStatus.innerHTML = `
                                <div style="color: #28a745;">
                                    <h4>✅ Generation Complete</h4>
                                    <p>${periodType} analysis completed for all metrics</p>
                                </div>
                            `;
                        }
                    } else {
                        // Handle single metric selection
                        // For 'both' period type, we need to make two separate calls
                        if (periodType === 'both') {
                            // First run monthly analysis
                            progressStatus.textContent = 'Running monthly analysis...';
                            progressBar.style.width = '25%';
                            addLogEntry(`Starting monthly analysis for metric ${metricId} in district ${districtId}...`, 'info');
                            
                            const monthlyResponse = await fetch(`/backend/run_specific_metric?metric_id=${metricId}&district_id=${districtId}&period_type=month`, {
                                method: 'GET',
                                headers: {
                                    'Content-Type': 'application/json'
                                }
                            });
                            
                            const monthlyData = await monthlyResponse.json();
                            if (monthlyData.status !== 'success') {
                                throw new Error(`Monthly analysis failed: ${monthlyData.message}`);
                            }
                            
                            progressBar.style.width = '50%';
                            addLogEntry('Monthly analysis completed successfully', 'success');
                            
                            // Then run annual analysis
                            progressStatus.textContent = 'Running annual analysis...';
                            addLogEntry(`Starting annual analysis for metric ${metricId} in district ${districtId}...`, 'info');
                            
                            const annualResponse = await fetch(`/backend/run_specific_metric?metric_id=${metricId}&district_id=${districtId}&period_type=year`, {
                                method: 'GET',
                                headers: {
                                    'Content-Type': 'application/json'
                                }
                            });
                            
                            const annualData = await annualResponse.json();
                            if (annualData.status !== 'success') {
                                throw new Error(`Annual analysis failed: ${annualData.message}`);
                            }
                            
                            progressBar.style.width = '100%';
                            progressStatus.textContent = 'Monthly and annual analysis completed successfully';
                            addLogEntry('Annual analysis completed successfully', 'success');
                            
                            generateStatus.innerHTML = `
                                <div style="color: #28a745;">
                                    <h4>✅ Generation Complete</h4>
                                    <p>Monthly and annual analysis completed successfully</p>
                                </div>
                            `;
                        } else if (periodType === 'week') {
                            // Weekly analysis - calls a different endpoint
                            progressStatus.textContent = 'Running weekly analysis...';
                            progressBar.style.width = '50%';
                            addLogEntry(`Starting weekly analysis for metric ${metricId} in district ${districtId}...`, 'info');
                            
                            const response = await fetch(`/api/weekly-analysis?metrics=${metricId}&include_districts=true`, {
                                method: 'GET'
                            });
                            
                            const data = await response.json();
                            
                            if (data.success) {
                                progressBar.style.width = '100%';
                                progressStatus.textContent = 'Weekly analysis completed successfully';
                                addLogEntry('Weekly analysis completed successfully', 'success');
                                
                                generateStatus.innerHTML = `
                                    <div style="color: #28a745;">
                                        <h4>✅ Weekly Analysis Complete</h4>
                                        <p>Weekly analysis completed successfully</p>
                                        <p><a href="/weekly-report" target="_blank">View Weekly Report</a></p>
                                    </div>
                                `;
                            } else {
                                throw new Error(data.error || 'Unknown error');
                            }
                        } else {
                            // Single period type analysis
                            progressStatus.textContent = `Running ${periodType} analysis...`;
                            progressBar.style.width = '50%';
                            addLogEntry(`Starting ${periodType} analysis for metric ${metricId} in district ${districtId}...`, 'info');
                            
                            const response = await fetch(`/backend/run_specific_metric?metric_id=${metricId}&district_id=${districtId}&period_type=${periodType}`, {
                                method: 'GET',
                                headers: {
                                    'Content-Type': 'application/json'
                                }
                            });
                            
                            const data = await response.json();
                            
                            if (data.status === 'success') {
                                progressBar.style.width = '100%';
                                progressStatus.textContent = `${periodType} analysis completed successfully`;
                                addLogEntry(`${periodType} analysis completed successfully`, 'success');
                                
                                generateStatus.innerHTML = `
                                    <div style="color: #28a745;">
                                        <h4>✅ Generation Complete</h4>
                                        <p>${data.message}</p>
                                    </div>
                                `;
                            } else {
                                throw new Error(data.message);
                            }
                        }
                    }
                    
                    // Reload outputs after successful generation
                    await loadOutputs();
                    
                    // Also reload charts
                    loadAllCharts(metricSelect.value, districtSelect.value);
                } catch (error) {
                    console.error('Error generating metrics:', error);
                    progressBar.style.width = '100%';
                    progressBar.style.backgroundColor = '#dc3545';
                    progressStatus.textContent = `Error: ${error.message}`;
                    addLogEntry(`Error: ${error.message}`, 'error');
                    
                    generateStatus.innerHTML = `
                        <div style="color: #dc3545;">
                            <h4>❌ Error</h4>
                            <p>An error occurred while generating metrics: ${error.message}</p>
                        </div>
                    `;
                } finally {
                    generateMetricsBtn.classList.remove('loading');
                    generateMetricsBtn.disabled = false;
                }
            });
            
            // Function to add a log entry with timestamp
            function addLogEntry(message, type = 'info') {
                const progressLog = document.getElementById('progress-log');
                const now = new Date();
                const timeString = now.toLocaleTimeString();
                
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.innerHTML = `<span class="log-time">[${timeString}]</span> ${message}`;
                
                progressLog.appendChild(logEntry);
                progressLog.scrollTop = progressLog.scrollHeight;
            }
            
            // Function to load columns for a metric
            async function loadColumns(metricId) {
                const metric = metrics.find(m => m.id === parseInt(metricId));
                if (!metric) return;

                const columnSelection = document.getElementById('column-selection');
                const columnGrid = document.getElementById('column-grid');
                const columnUpdateStatus = document.getElementById('column-update-status');

                try {
                    // Show loading state
                    columnSelection.style.display = 'block';
                    columnGrid.innerHTML = '<div class="spinner"></div> Loading columns...';
                    
                    // Update the header with endpoint information
                    columnSelection.querySelector('h3').textContent = `Select Columns for analysis from: ${metric.endpoint}`;
                    
                    // Fetch columns from the endpoint
                    const response = await fetch(`/backend/get-endpoint-columns/${encodeURIComponent(metric.endpoint)}`);
                    if (!response.ok) {
                        throw new Error('Failed to load columns');
                    }
                    
                    const data = await response.json();
                    
                    // Fetch currently selected columns - UPDATED to include metric_id
                    const selectedResponse = await fetch(`/backend/get-selected-columns/${encodeURIComponent(metric.endpoint)}?metric_id=${metricId}`);
                    const selectedData = await selectedResponse.json();
                    const selectedColumns = new Set(selectedData.columns || []);
                    
                    // Populate column grid
                    columnGrid.innerHTML = data.columns.map(column => `
                        <div class="column-item">
                            <input type="checkbox" id="col-${column}" value="${column}" 
                                ${selectedColumns.has(column) ? 'checked' : ''}>
                            <label for="col-${column}">${column}</label>
                        </div>
                    `).join('');
                    
                    // Add event listeners for select all/deselect all
                    document.getElementById('select-all-columns').onclick = () => {
                        columnGrid.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                            checkbox.checked = true;
                        });
                    };
                    
                    document.getElementById('deselect-all-columns').onclick = () => {
                        columnGrid.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                            checkbox.checked = false;
                        });
                    };
                    
                    // Add event listener for update button
                    document.getElementById('update-columns').onclick = async () => {
                        const selectedColumns = Array.from(columnGrid.querySelectorAll('input[type="checkbox"]:checked'))
                            .map(checkbox => checkbox.value);
                        
                        try {
                            columnUpdateStatus.style.display = 'block';
                            columnUpdateStatus.innerHTML = '<div class="spinner"></div> Updating columns...';
                            
                            const updateResponse = await fetch('/backend/update-selected-columns', {
                                method: 'POST',
                                headers: {
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify({
                                    endpoint: metric.endpoint,
                                    metric_id: metric.id,
                                    columns: selectedColumns
                                })
                            });
                            
                            const updateData = await updateResponse.json();
                            
                            if (updateData.status === 'success') {
                                columnUpdateStatus.innerHTML = `
                                    <div style="color: #28a745;">
                                        <h4>✅ Update Complete</h4>
                                        <p>${updateData.message}</p>
                                    </div>
                                `;
                                // Save the current selection before reloading metrics
                                const currentMetricId = metricSelect.value;
                                
                                // Reload metrics to refresh the enhanced queries
                                await loadMetrics();
                                
                                // Restore the previous selection
                                if (currentMetricId) {
                                    metricSelect.value = currentMetricId;
                                    // Trigger change event to update relevant UI
                                    metricSelect.dispatchEvent(new Event('change'));
                                }
                            } else {
                                throw new Error(updateData.message);
                            }
                        } catch (error) {
                            console.error('Error updating columns:', error);
                            columnUpdateStatus.innerHTML = `
                                <div style="color: #dc3545;">
                                    <h4>❌ Error</h4>
                                    <p>An error occurred while updating columns: ${error.message}</p>
                                </div>
                            `;
                        }
                    };
                } catch (error) {
                    console.error('Error loading columns:', error);
                    columnGrid.innerHTML = `
                        <div style="color: #dc3545;">
                            <h4>❌ Error</h4>
                            <p>Failed to load columns: ${error.message}</p>
                        </div>
                    `;
                }
            }

            // Add event listener for metric selection
            metricSelect.addEventListener('change', function() {
                loadOutputs();
                loadAllCharts(metricSelect.value, districtSelect.value);
                
                // Enable/disable delete and edit buttons based on selection
                const deleteBtn = document.getElementById('delete-metric-btn');
                const editBtn = document.getElementById('edit-metric-btn');
                const metricId = metricSelect.value;
                
                // Enable buttons only if a specific metric is selected (not "all" or empty)
                const shouldEnable = metricId && metricId !== 'all' && metricId !== '';
                deleteBtn.disabled = !shouldEnable;
                editBtn.disabled = !shouldEnable;
                
                // Load columns for the selected metric
                if (metricId && metricId !== 'all') {
                    loadColumns(metricId);
                } else {
                    document.getElementById('column-selection').style.display = 'none';
                }
            });
            
            // Add event listener for the delete metric button
            document.getElementById('delete-metric-btn').addEventListener('click', async function() {
                const metricId = metricSelect.value;
                
                if (!metricId || metricId === 'all' || metricId === '') {
                    alert('Please select a specific metric to delete.');
                    return;
                }
                
                // Get the metric name for confirmation
                const selectedOption = metricSelect.options[metricSelect.selectedIndex];
                const metricName = selectedOption.text;
                
                // Confirm deletion
                const confirmDelete = confirm(`Are you sure you want to delete the metric:\n\n${metricName}\n\nThis action cannot be undone. The metric will be marked as inactive and will no longer appear in the metrics list.`);
                
                if (!confirmDelete) {
                    return;
                }
                
                try {
                    const deleteBtn = document.getElementById('delete-metric-btn');
                    
                    // Show loading state
                    deleteBtn.disabled = true;
                    deleteBtn.textContent = 'Deleting...';
                    
                    // Call the delete API
                    const response = await fetch(`/api/metrics/${metricId}`, {
                        method: 'DELETE',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        alert(`Successfully deleted metric: ${result.metric_name}`);
                        
                        // Refresh the metrics list
                        await loadMetrics();
                        
                        // Reset selection to "All Metrics"
                        metricSelect.value = 'all';
                        
                        // Clear outputs
                        document.getElementById('dashboard-output').textContent = 'Select a metric to view dashboard output';
                        document.getElementById('annual-output').textContent = 'Select a metric to view annual output';
                        document.getElementById('monthly-output').textContent = 'Select a metric to view monthly output';
                        document.getElementById('weekly-output').textContent = 'Select a metric to view weekly output';
                        
                        // Clear charts
                        loadAllCharts('all', districtSelect.value);
                        
                    } else {
                        const error = await response.json();
                        alert(`Error deleting metric: ${error.detail || 'Unknown error'}`);
                    }
                } catch (error) {
                    console.error('Error deleting metric:', error);
                    alert(`Error deleting metric: ${error.message}`);
                } finally {
                    // Reset button state
                    const deleteBtn = document.getElementById('delete-metric-btn');
                    deleteBtn.disabled = true; // Keep disabled since we reset to "all"
                    deleteBtn.textContent = 'Delete Metric';
                }
            });
            
            // Load metrics when page loads
            loadMetrics();

            // Function to load time series charts
            async function loadTimeSeriesCharts(metricId, districtId, periodType = 'month', container = 'time-series-charts') {
                const timeSeriesChartsContainer = document.getElementById(container);
                
                if (metricId === 'all') {
                    timeSeriesChartsContainer.innerHTML = '<div class="no-charts-message">Please select a specific metric to view time series charts</div>';
                    return;
                }
                
                // Show loading state
                timeSeriesChartsContainer.innerHTML = '<div class="loading-charts">Loading time series charts...</div>';
                
                try {
                    // Fetch active charts from the backend API
                    const chartsResponse = await fetch(`/backend/api/active-charts?metric_id=${metricId}&district=${districtId}&period_type=${periodType}`);
                    
                    if (!chartsResponse.ok) {
                        throw new Error(`Failed to fetch charts: ${chartsResponse.status} ${chartsResponse.statusText}`);
                    }
                    
                    const chartsData = await chartsResponse.json();
                    
                    if (chartsData.status === "error") {
                        throw new Error(`API error: ${chartsData.message}`);
                    }
                    
                    const charts = chartsData.charts || [];
                    
                    if (charts.length > 0) {
                        let chartHtml = '';
                        
                        // Add a chart for each chart_id returned by the API
                        for (const chart of charts) {
                            const chartId = chart.chart_id;
                            const groupField = chart.group_field;
                            
                            // Check if this chart has a DW URL in metadata
                            let dwUrl = null;
                            try {
                                const metadataResponse = await fetch(`/backend/api/chart-metadata/${chartId}`);
                                if (metadataResponse.ok) {
                                    const metadataData = await metadataResponse.json();
                                    dwUrl = metadataData.metadata?.dw_url;
                                }
                            } catch (error) {
                                console.warn(`Could not fetch metadata for chart ${chartId}:`, error);
                            }
                            
                            // If the chart has a group field, include it in the URL
                            let iframeSrc = `/backend/time-series-chart?chart_id=${chartId}#chart-section`;
                            
                            chartHtml += `
                                <div class="chart-card">
                                    <div class="chart-card-body">
                                        ${dwUrl ? `
                                            <div class="chart-tabs">
                                                <div class="chart-tab-buttons">
                                                    <button class="chart-tab-btn active" onclick="showChartTab(${chartId}, 'original')">Original</button>
                                                    <button class="chart-tab-btn" onclick="showChartTab(${chartId}, 'dw')">Datawrapper</button>
                                                </div>
                                                <div class="chart-tab-content">
                                                    <div id="chart-original-${chartId}" class="chart-tab-pane active">
                                                        <iframe src="${iframeSrc}"></iframe>
                                                    </div>
                                                    <div id="chart-dw-${chartId}" class="chart-tab-pane">
                                                        <iframe src="${dwUrl}"></iframe>
                                                    </div>
                                                </div>
                                            </div>
                                        ` : `
                                            <iframe src="${iframeSrc}"></iframe>
                                        `}
                                    </div>
                                    <div class="chart-card-footer">
                                        ${dwUrl ? `
                                            <button class="chart-dw-btn" onclick="window.open('${dwUrl}', '_blank')" style="background-color: #28a745;">
                                                View DW Chart
                                            </button>
                                        ` : `
                                            <button class="chart-dw-btn" onclick="generateDWTimeSeriesChart(${chartId})">
                                                Generate DW Version
                                                <span class="btn-spinner"></span>
                                            </button>
                                        `}
                                    </div>
                                </div>
                            `;
                        }
                        
                        timeSeriesChartsContainer.innerHTML = chartHtml;
                    } else {
                        timeSeriesChartsContainer.innerHTML = '<div class="no-charts-message">No active charts found for this metric</div>';
                    }
                } catch (error) {
                    console.error('Error loading time series charts:', error);
                    timeSeriesChartsContainer.innerHTML = `<div class="no-charts-message">Error loading charts: ${error.message}</div>`;
                }
            }
            
            // Function to load anomaly charts
            async function loadAnomalyCharts(metricId, districtId, periodType = 'month', container = 'anomaly-charts') {
                const anomalyChartsContainer = document.getElementById(container);
                
                if (metricId === 'all') {
                    anomalyChartsContainer.innerHTML = '<div class="no-charts-message">Please select a specific metric to view anomalies</div>';
                    return;
                }
                
                // Show loading state
                anomalyChartsContainer.innerHTML = '<div class="loading-charts">Loading anomaly charts...</div>';
                
                try {
                    // Try the endpoint with anomaly-analyzer prefix
                    const anomaliesResponse = await fetch(`/anomaly-analyzer/api/query-anomalies?object_id=${metricId}&district=${districtId}&period_type=${periodType}&only_anomalies=true&only_active=true&limit=10`);
                    
                    if (!anomaliesResponse.ok) {
                        throw new Error(`Failed to fetch anomalies: ${anomaliesResponse.status} ${anomaliesResponse.statusText}`);
                    }
                    
                    const anomaliesData = await anomaliesResponse.json();
                    
                    if (anomaliesData.status === "error") {
                        throw new Error(`API error: ${anomaliesData.message}`);
                    }
                    
                    const anomalies = anomaliesData.anomalies || [];
                    
                    if (anomalies.length > 0) {
                        let chartHtml = '';
                        
                        // Add chart for each anomaly
                        for (const anomaly of anomalies) {
                            const anomalyId = anomaly.id;
                            const groupValue = anomaly.group_value || 'Total';
                            const fieldName = anomaly.group_field_name || 'Group';
                            const deltaStr = anomaly.percent_change > 0 ? `+${anomaly.percent_change.toFixed(1)}%` : `${anomaly.percent_change.toFixed(1)}%`;
                            const deltaClass = anomaly.percent_change > 0 ? 'text-danger' : 'text-success';
                            
                            // Check if this anomaly has a DW URL in metadata
                            let dwUrl = null;
                            try {
                                const metadataResponse = await fetch(`/backend/api/anomaly-metadata/${anomalyId}`);
                                if (metadataResponse.ok) {
                                    const metadataData = await metadataResponse.json();
                                    dwUrl = metadataData.metadata?.dw_url;
                                }
                            } catch (error) {
                                console.warn(`Could not fetch metadata for anomaly ${anomalyId}:`, error);
                            }
                            
                            chartHtml += `
                                <div class="chart-card">
                                    <div class="chart-card-body">
                                        ${dwUrl ? `
                                            <div class="chart-tabs">
                                                <div class="chart-tab-buttons">
                                                    <button class="chart-tab-btn active" onclick="showChartTab('anomaly-${anomalyId}', 'original')">Original</button>
                                                    <button class="chart-tab-btn" onclick="showChartTab('anomaly-${anomalyId}', 'dw')">Datawrapper</button>
                                                </div>
                                                <div class="chart-tab-content">
                                                    <div id="chart-original-anomaly-${anomalyId}" class="chart-tab-pane active">
                                                        <iframe src="/anomaly-analyzer/anomaly-chart?id=${anomalyId}"></iframe>
                                                    </div>
                                                    <div id="chart-dw-anomaly-${anomalyId}" class="chart-tab-pane">
                                                        <iframe src="${dwUrl}"></iframe>
                                                    </div>
                                                </div>
                                            </div>
                                        ` : `
                                            <iframe src="/anomaly-analyzer/anomaly-chart?id=${anomalyId}"></iframe>
                                        `}
                                    </div>
                                    <div class="chart-card-footer">
                                        ${dwUrl ? `
                                            <button class="chart-dw-btn" onclick="window.open('${dwUrl}', '_blank')" style="background-color: #28a745;">
                                                View DW Chart
                                            </button>
                                        ` : `
                                            <button class="chart-dw-btn" onclick="generateDWAnomalyChart(${anomalyId})">
                                                Generate DW Version
                                                <span class="btn-spinner"></span>
                                            </button>
                                        `}
                                    </div>
                                </div>
                            `;
                        }
                        
                        anomalyChartsContainer.innerHTML = chartHtml;
                    } else {
                        anomalyChartsContainer.innerHTML = '<div class="no-charts-message">No active anomalies found for this metric</div>';
                    }
                } catch (error) {
                    console.error('Error loading anomaly charts:', error);
                    anomalyChartsContainer.innerHTML = `<div class="no-charts-message">Error loading anomalies: ${error.message}</div>`;
                }
            }
            
            // Function to load all charts
            function loadAllCharts(metricId, districtId) {
                // Always load both monthly and annual charts
                loadTimeSeriesCharts(metricId, districtId, 'month', 'time-series-charts');
                loadAnomalyCharts(metricId, districtId, 'month', 'anomaly-charts');
                loadTimeSeriesCharts(metricId, districtId, 'year', 'annual-time-series-charts');
                loadAnomalyCharts(metricId, districtId, 'year', 'annual-anomaly-charts');
                loadDistrictMaps(metricId);
            }
            
            // Function to load district maps
            async function loadDistrictMaps(metricId) {
                const mapsContainer = document.getElementById('district-maps');
                
                if (metricId === 'all') {
                    mapsContainer.innerHTML = '<div class="no-charts-message">Please select a specific metric to view district maps</div>';
                    return;
                }
                
                // Show loading state
                mapsContainer.innerHTML = '<div class="loading-charts">Loading district maps...</div>';
                
                try {
                    // Try the main API endpoint first
                    let mapsResponse;
                    try {
                        mapsResponse = await fetch(`/api/district-maps?metric_id=${metricId}`);
                        if (!mapsResponse.ok) {
                            throw new Error(`Failed to fetch from main API: ${mapsResponse.status}`);
                        }
                    } catch (apiError) {
                        console.warn('Error using main API endpoint, falling back to backend:', apiError);
                        // Fall back to the backend endpoint
                        mapsResponse = await fetch(`/backend/api/district-maps?metric_id=${metricId}`);
                        if (!mapsResponse.ok) {
                            throw new Error(`Failed to fetch maps: ${mapsResponse.status} ${mapsResponse.statusText}`);
                        }
                    }
                    
                    const mapsData = await mapsResponse.json();
                    
                    if (mapsData.status === "error") {
                        throw new Error(`API error: ${mapsData.message}`);
                    }
                    
                    const maps = mapsData.maps || [];
                    
                    if (maps.length > 0) {
                        let mapsHtml = '';
                        
                        // Add each map
                        maps.forEach(map => {
                            const mapId = map.id;
                            const mapTitle = map.title;
                            const publishedUrl = map.published_url;
                            
                            if (publishedUrl) {
                                mapsHtml += `
                                    <div class="chart-card">
                                        <div class="chart-card-header">
                                            <h4>${mapTitle}</h4>
                                            <p><small>Map ID: ${mapId}</small></p>
                                        </div>
                                        <div class="chart-card-body">
                                            <iframe src="${publishedUrl}" frameborder="0" allowfullscreen></iframe>
                                        </div>
                                        <div class="chart-card-footer" style="padding: 10px; font-size: 12px; max-height: 100px; overflow-y: auto; background-color: #f8f9fa;">
                                            <p><strong>Metadata:</strong> <pre style="white-space: pre-wrap; word-break: break-word;">${JSON.stringify(map.metadata || {}, null, 2)}</pre></p>
                                        </div>
                                    </div>
                                `;
                            }
                        });
                        
                        if (mapsHtml) {
                            mapsContainer.innerHTML = mapsHtml;
                        } else {
                            mapsContainer.innerHTML = '<div class="no-charts-message">No maps found for this metric</div>';
                        }
                    } else {
                        mapsContainer.innerHTML = '<div class="no-charts-message">No maps found for this metric</div>';
                    }
                } catch (error) {
                    console.error('Error loading district maps:', error);
                    mapsContainer.innerHTML = `<div class="no-charts-message">Error loading maps: ${error.message}</div>`;
                }
            }
            
            // Update event listeners to use the new function
            districtSelect.addEventListener('change', function() {
                loadOutputs();
                loadAllCharts(metricSelect.value, districtSelect.value);
            });
            
            metricSelect.addEventListener('change', function() {
                loadOutputs();
                loadAllCharts(metricSelect.value, districtSelect.value);
            });
            
            // Also update when period type changes
            periodTypeSelect.addEventListener('change', function() {
                loadAllCharts(metricSelect.value, districtSelect.value);
            });
            
            // Load charts initially
            loadAllCharts(metricSelect.value, districtSelect.value);

            // Add event listener for the define metric button
            document.getElementById('define-metric-btn').addEventListener('click', openMetricDefinitionModal);
            
            // Add event listener for the reorder metrics button
            document.getElementById('reorder-metrics-btn').addEventListener('click', openMetricReorderModal);
            
            // Add event listener for clicking outside the modal to close it
            window.addEventListener('click', function(event) {
                const modal = document.getElementById('metricDefinitionModal');
                if (event.target === modal) {
                    closeMetricDefinitionModal();
                }
                
                const reorderModal = document.getElementById('metricReorderModal');
                if (event.target === reorderModal) {
                    closeMetricReorderModal();
                }
            });
            
            // Add event listener for the migrate dashboard button
            document.getElementById('migrate-dashboard-btn').addEventListener('click', async function() {
                const migrateBtn = document.getElementById('migrate-dashboard-btn');
                
                // Confirm restoration
                const confirmRestore = confirm(
                    'This will restore the metrics table from the backup file.\n\n' +
                    'This will replace all existing metrics in the database.\n\n' +
                    'Are you sure you want to proceed?'
                );
                
                if (!confirmRestore) {
                    return;
                }
                
                try {
                    // Show loading state
                    migrateBtn.disabled = true;
                    migrateBtn.textContent = 'Restoring...';
                    
                    // Add spinner if button has spinner support
                    if (migrateBtn.classList.contains('btn-with-spinner')) {
                        migrateBtn.classList.add('loading');
                    }
                    
                    // Call the restore API
                    const response = await fetch('/api/restore-metrics-from-backup', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok && result.status === 'success') {
                        alert('Metrics table successfully restored from backup!');
                        
                        // Refresh the metrics list
                        await loadMetrics();
                        
                        // Reset selection to "All Metrics"
                        metricSelect.value = 'all';
                        metricSelect.dispatchEvent(new Event('change'));
                        
                    } else {
                        alert(`Restore failed: ${result.message || 'Unknown error'}`);
                    }
                } catch (error) {
                    console.error('Error during restore:', error);
                    alert(`Error during restore: ${error.message}`);
                } finally {
                    // Reset button state
                    migrateBtn.disabled = false;
                    migrateBtn.textContent = 'Restore Metrics from Backup';
                    if (migrateBtn.classList.contains('btn-with-spinner')) {
                        migrateBtn.classList.remove('loading');
                    }
                }
            });
            
            // Add event listener for the backup metrics button
            document.getElementById('backup-metrics-btn').addEventListener('click', async function() {
                const backupBtn = document.getElementById('backup-metrics-btn');
                
                // Confirm backup
                const confirmBackup = confirm(
                    'This will create a new backup of the metrics table.\n\n' +
                    'Any existing backup file will be moved to the history folder.\n\n' +
                    'Are you sure you want to proceed?'
                );
                
                if (!confirmBackup) {
                    return;
                }
                
                try {
                    // Show loading state
                    backupBtn.disabled = true;
                    backupBtn.textContent = 'Creating Backup...';
                    
                    // Add spinner if button has spinner support
                    if (backupBtn.classList.contains('btn-with-spinner')) {
                        backupBtn.classList.add('loading');
                    }
                    
                    // Call the backup API
                    const response = await fetch('/api/backup-metrics-table', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                    
                    const result = await response.json();
                    
                    if (response.ok && result.status === 'success') {
                        alert(`Metrics table successfully backed up!\n\nBackup saved to: ${result.backup_file}\n${result.old_backup_moved ? `Previous backup moved to: ${result.old_backup_location}` : ''}`);
                    } else {
                        alert(`Backup failed: ${result.message || 'Unknown error'}`);
                    }
                } catch (error) {
                    console.error('Error during backup:', error);
                    alert(`Error during backup: ${error.message}`);
                } finally {
                    // Reset button state
                    backupBtn.disabled = false;
                    backupBtn.textContent = 'Backup Metrics';
                    if (backupBtn.classList.contains('btn-with-spinner')) {
                        backupBtn.classList.remove('loading');
                    }
                }
            });
            
            // Function to generate DW time series chart for individual chart
            window.generateDWTimeSeriesChart = async function(chartId) {
                const button = event.target;
                
                try {
                    // Show loading state
                    button.classList.add('loading');
                    button.disabled = true;
                    
                    // Call the backend endpoint to generate DW chart
                    const dwResponse = await fetch(`/backend/generate-dw-time-series?chart_id=${chartId}`, {
                        method: 'POST'
                    });
                    
                    if (!dwResponse.ok) {
                        throw new Error(`Failed to generate DW chart: ${dwResponse.status} ${dwResponse.statusText}`);
                    }
                    
                    const dwData = await dwResponse.json();
                    
                    if (dwData.status === 'success' && dwData.chart_url) {
                        // Update chart metadata with DW URL
                        await updateChartMetadata(chartId, 'time_series', dwData.chart_url);
                        
                        // Refresh the charts to show the new DW version
                        loadAllCharts(metricSelect.value, districtSelect.value);
                        
                        alert(`Successfully generated DW chart! Chart URL: ${dwData.chart_url}`);
                    } else {
                        throw new Error(dwData.message || 'Unknown error');
                    }
                    
                } catch (error) {
                    console.error('Error generating DW chart:', error);
                    alert(`Error generating DW chart: ${error.message}`);
                } finally {
                    button.classList.remove('loading');
                    button.disabled = false;
                }
            };
            
            // Function to generate DW anomaly chart for individual anomaly
            window.generateDWAnomalyChart = async function(anomalyId) {
                const button = event.target;
                
                try {
                    // Show loading state
                    button.classList.add('loading');
                    button.disabled = true;
                    
                    // Call the backend endpoint to generate DW anomaly chart
                    const dwResponse = await fetch(`/backend/generate-dw-anomaly?anomaly_id=${anomalyId}`, {
                        method: 'POST'
                    });
                    
                    if (!dwResponse.ok) {
                        throw new Error(`Failed to generate DW chart: ${dwResponse.status} ${dwResponse.statusText}`);
                    }
                    
                    const dwData = await dwResponse.json();
                    
                    if (dwData.status === 'success' && dwData.chart_url) {
                        // Update anomaly metadata with DW URL
                        await updateAnomalyMetadata(anomalyId, dwData.chart_url);
                        
                        // Refresh the charts to show the new DW version
                        loadAllCharts(metricSelect.value, districtSelect.value);
                        
                        alert(`Successfully generated DW anomaly chart! Chart URL: ${dwData.chart_url}`);
                    } else {
                        throw new Error(dwData.message || 'Unknown error');
                    }
                    
                } catch (error) {
                    console.error('Error generating DW anomaly chart:', error);
                    alert(`Error generating DW anomaly chart: ${error.message}`);
                } finally {
                    button.classList.remove('loading');
                    button.disabled = false;
                }
            };
            
            // Function to update chart metadata with DW URL
            async function updateChartMetadata(chartId, chartType, dwUrl) {
                try {
                    const response = await fetch('/backend/update-chart-metadata', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            chart_id: chartId,
                            chart_type: chartType,
                            dw_url: dwUrl
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to update chart metadata: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    console.log('Chart metadata updated:', result);
                } catch (error) {
                    console.error('Error updating chart metadata:', error);
                }
            }
            
            // Function to update anomaly metadata with DW URL
            async function updateAnomalyMetadata(anomalyId, dwUrl) {
                try {
                    const response = await fetch('/backend/update-anomaly-metadata', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            anomaly_id: anomalyId,
                            dw_url: dwUrl
                        })
                    });
                    
                    if (!response.ok) {
                        throw new Error(`Failed to update anomaly metadata: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    console.log('Anomaly metadata updated:', result);
                } catch (error) {
                    console.error('Error updating anomaly metadata:', error);
                }
            }
            
            // Function to switch between chart tabs
            window.showChartTab = function(chartId, tabType) {
                // Remove active class from all tab buttons for this chart
                const tabButtons = document.querySelectorAll(`[onclick*="${chartId}"]`);
                tabButtons.forEach(btn => {
                    if (btn.classList.contains('chart-tab-btn')) {
                        btn.classList.remove('active');
                    }
                });
                
                // Add active class to clicked button
                event.target.classList.add('active');
                
                // Hide all tab panes for this chart
                const originalPane = document.getElementById(`chart-original-${chartId}`);
                const dwPane = document.getElementById(`chart-dw-${chartId}`);
                
                if (originalPane) originalPane.classList.remove('active');
                if (dwPane) dwPane.classList.remove('active');
                
                // Show the selected tab pane
                if (tabType === 'original' && originalPane) {
                    originalPane.classList.add('active');
                } else if (tabType === 'dw' && dwPane) {
                    dwPane.classList.add('active');
                }
            };

            // Add event listener for the edit metric button
            document.getElementById('edit-metric-btn').addEventListener('click', async function() {
                const metricId = metricSelect.value;
                
                if (!metricId || metricId === 'all' || metricId === '') {
                    alert('Please select a specific metric to edit.');
                    return;
                }
                
                try {
                    // Fetch the metric data using the correct endpoint
                    const response = await fetch(`/api/metric/${metricId}`);
                    if (!response.ok) {
                        throw new Error('Failed to fetch metric data');
                    }
                    
                    const metricData = await response.json();
                    console.log('Received metric data:', metricData); // Debug log
                    
                    // Set modal title and edit mode
                    document.getElementById('metricModalTitle').textContent = 'Edit Metric';
                    document.getElementById('isEditMode').value = 'true';
                    
                    // Populate form fields with null checks
                    document.getElementById('metricName').value = metricData.name || '';
                    document.getElementById('metricId').value = metricData.id || '';
                    document.getElementById('endpoint').value = metricData.endpoint || '';
                    document.getElementById('summary').value = metricData.summary || '';
                    document.getElementById('definition').value = metricData.definition || '';
                    document.getElementById('dataSfUrl').value = metricData.data_sf_url || '';
                    document.getElementById('ytdQuery').value = metricData.ytd_query || '';
                    document.getElementById('metricQuery').value = metricData.metric_query || '';
                    document.getElementById('datasetTitle').value = metricData.dataset_title || '';
                    document.getElementById('datasetCategory').value = metricData.dataset_category || '';
                    document.getElementById('isActive').value = metricData.is_active !== false ? 'true' : 'false';
                    document.getElementById('showOnDash').value = metricData.show_on_dash !== false ? 'true' : 'false';
                    document.getElementById('itemNoun').value = metricData.item_noun || 'Items';
                    document.getElementById('greenDirection').value = metricData.greendirection || 'up';
                    
                    // Open the modal
                    openMetricDefinitionModal();
                    
                } catch (error) {
                    console.error('Error loading metric data:', error);
                    console.error('Error details:', {
                        message: error.message,
                        stack: error.stack
                    });
                    alert(`Error loading metric data: ${error.message}`);
                }
            });

            // Add event listener for the metric definition form
            document.getElementById('metricDefinitionForm').addEventListener('submit', async function(e) {
                e.preventDefault();
                
                const form = e.target;
                const isEditMode = document.getElementById('isEditMode').value === 'true';
                const metricId = document.getElementById('metricId').value;
                
                // Collect form data
                const formData = {
                    metric_name: document.getElementById('metricName').value,
                    metric_key: document.getElementById('metricId').value,
                    category: document.getElementById('datasetCategory').value,
                    endpoint: document.getElementById('endpoint').value,
                    summary: document.getElementById('summary').value,
                    definition: document.getElementById('definition').value,
                    data_sf_url: document.getElementById('dataSfUrl').value,
                    ytd_query: document.getElementById('ytdQuery').value,
                    metric_query: document.getElementById('metricQuery').value,
                    dataset_title: document.getElementById('datasetTitle').value,
                    dataset_category: document.getElementById('datasetCategory').value,
                    is_active: document.getElementById('isActive').value === 'true',
                    show_on_dash: document.getElementById('showOnDash').value === 'true',
                    item_noun: document.getElementById('itemNoun').value,
                    greendirection: document.getElementById('greenDirection').value
                };
                
                try {
                    const saveBtn = form.querySelector('.save-btn');
                    saveBtn.disabled = true;
                    saveBtn.textContent = 'Saving...';
                    
                    const url = isEditMode ? `/api/metrics/${metricId}` : '/api/metrics';
                    const method = isEditMode ? 'PUT' : 'POST';
                    
                    console.log('Sending request:', { url, method, formData }); // Debug log
                    
                    const response = await fetch(url, {
                        method: method,
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(formData)
                    });
                    
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.detail || 'Failed to save metric');
                    }
                    
                    const result = await response.json();
                    alert(`Successfully ${isEditMode ? 'updated' : 'created'} metric: ${result.message}`);
                    
                    // Close the modal
                    closeMetricDefinitionModal();
                    
                    // Refresh the metrics list
                    await loadMetrics();
                    
                    // If editing, keep the same metric selected
                    if (isEditMode) {
                        metricSelect.value = metricId;
                    } else {
                        // For new metrics, select the newly created one
                        metricSelect.value = result.metric_id;
                    }
                    
                    // Trigger change event to update UI
                    metricSelect.dispatchEvent(new Event('change'));
                    
                } catch (error) {
                    console.error('Error saving metric:', error);
                    alert(`Error saving metric: ${error.message}`);
                } finally {
                    const saveBtn = form.querySelector('.save-btn');
                    saveBtn.disabled = false;
                    saveBtn.textContent = 'Save Metric';
                }
            });
        });
    </script>
</body>
</html>